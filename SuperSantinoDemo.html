<!DOCTYPE HTML>
<html>

<!-- HEADER -->

<!-- Borksy 6.4.1 -->
<!-- bitsy-hacks 22.1.0 -->
<!-- Bitsy 8.12 -->
<head>

<meta charset="UTF-8">

<title>Super Santino DEMO</title>

<script type="text/bitsyGameData" id="exportedGameData">
"""
> Opstartbestand gevonden
> Demo laden
"""

# BITSY VERSION 8.12

! VER_MAJ 8
! VER_MIN 12
! ROOM_FORMAT 1
! DLG_COMPAT 0
! TXT_MODE 0

PAL 0
0,82,204
128,159,255
254,236,170
NAME blueprint

PAL 2
0,82,204
255,250,221
253,35,92

PAL 3
0,82,204
128,159,255
253,35,92

PAL 4
0,82,204
155,255,254
253,35,92

PAL 5
0,82,204
216,254,62
253,35,92

PAL 6
0,0,0
255,250,221
253,35,92

ROOM 0
k0,oi,o1,o2,o3,o4,o5,o6,o7,o8,o7,oa,ob,oc,oi,oj
ok,od,oe,of,ol,oh,np,98,om,27,9b,on,oo,op,0,or
ok,os,ot,ou,ov,ow,np,c6,ox,oy,np,oz,p0,p1,0,or
ok,p2,p3,1d,p4,np,p5,b6,p6,p7,np,p8,p9,pa,pb,or
pc,pd,pe,pf,pg,ph,pi,2w,pj,pk,pl,pm,pn,po,pj,pp
pq,pr,ps,pt,pu,pv,np,pw,px,py,pz,q0,np,np,q1,q2
q3,q4,q5,q6,q7,q8,q9,qa,np,qb,qc,qd,qe,qf,qg,qh
ok,0,qi,qj,qk,ql,qm,qn,qo,qp,qq,qr,qs,qt,0,or
ok,0,qu,qv,qw,qx,qy,qz,r0,r1,r2,r3,r4,r5,0,or
ok,0,0,0,0,0,0,f6,0,0,0,0,0,0,0,or
ok,0,0,0,0,0,r6,r7,r8,0,0,0,0,0,0,or
ok,0,0,0,0,0,r9,ra,rb,s9,s9,s9,s9,s9,s9,or
ok,0,0,0,0,0,rc,rd,re,0,0,0,0,0,s9,or
ok,ho,rf,rf,rg,rf,rh,s2,s3,ri,rj,rk,rl,rm,rn,or
ok,0,ro,rp,rq,rr,rs,rt,ru,rv,rw,rx,ry,rz,0,or
v,s0,s0,s0,s0,s0,s0,s0,s0,s0,s0,s0,s0,s0,s0,w
PAL 5

ROOM 1
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
4,0,0,0,7,8,8,8,8,8,8,9,0,0,0,6
4,0,0,0,6,b,c,d,e,f,g,4,0,0,0,6
4,0,0,0,6,h,f,f,f,f,i,4,0,0,0,6
4,0,0,0,6,f,f,f,j,k,l,4,0,0,0,6
4,0,0,0,6,f,f,f,m,n,o,4,0,0,0,6
4,0,0,0,6,f,f,f,f,f,f,4,0,0,0,6
4,0,0,0,6,f,f,f,p,q,r,4,0,0,0,6
4,0,0,0,s,3,t,1,2,2,2,u,0,0,0,6
4,0,0,0,0,s,2,u,0,0,0,0,0,0,0,6
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
v,8,8,8,8,8,8,8,8,8,8,8,8,8,8,w
NAME 01_Kamer
EXT 6,11 2 2,12 FX tunnel DLG 1
PAL 2

ROOM 2
g,5,x,y,x,x,x,x,z,x,x,10,11,12,x,13
14,15,16,17,18,f,f,19,1a,1b,1c,1d,1e,1f,1g,1h
1i,f,f,1j,f,1k,f,f,1l,f,f,1m,1n,1n,0,1p
1q,1r,1s,1t,f,1u,1v,f,f,f,f,1w,1x,1y,0,1z
20,21,22,f,f,23,f,24,25,26,27,28,29,2a,2b,1h
2c,2d,2e,2f,f,f,f,f,2g,f,f,2h,f,f,2i,2j
2k,2l,2m,f,2n,f,1h,f,f,2o,2p,f,f,2q,2r,2s
2t,2u,f,f,f,f,2v,2w,f,2x,f,2y,2z,30,31,32
33,34,f,1k,35,f,36,f,37,f,38,f,39,3a,3b,3c
3d,3e,f,f,3f,f,3g,3h,f,f,f,1c,15,2f,3i,3j
3k,3l,2f,f,3m,f,f,f,1c,15,f,f,f,f,3n,3o
3p,3q,no,3r,3s,25,3t,no,3u,3v,no,3w,2i,no,3x,1h
3y,3z,40,f,f,nw,f,42,nx,f,f,f,44,45,46,47
48,49,4a,4b,4c,4c,4c,4c,4c,4c,4c,4c,4d,4e,4f,4g
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME 02_Buiten
EXT 2,12 1 6,11 FX tunnel
EXT 15,12 3 0,12 FX tunnel
PAL 3

ROOM 3
g,x,1o,4h,4i,4j,x,4k,x,4l,4m,x,x,4n,4o,4p
4q,f,4r,4s,1k,4t,f,25,4u,15,f,4v,4w,4r,4x,1h
4y,4z,50,f,3v,51,52,53,4r,54,42,55,56,57,58,59
5a,5b,5c,5d,f,5e,3v,f,5f,4x,f,5g,5f,5h,5i,5j
4q,5k,5l,5m,5n,5o,5p,f,5q,5r,f,5s,f,5t,5u,5v
5w,5x,5y,5z,60,60,61,38,f,62,f,63,f,64,65,0
67,68,69,0,6a,6b,6c,f,f,6d,3g,6e,6e,6f,0,0
6g,6h,6i,6j,6k,6l,6m,6n,6o,6p,6q,0,0,0,0,0
6r,6s,6t,6u,6v,f,6w,6x,f,2i,6y,6z,70,71,72,73
74,75,76,f,f,77,78,79,f,7a,7b,7c,7d,7e,7f,7g
7h,7i,7j,7k,7l,7m,f,7n,3g,7o,7p,0,0,0,0,0
7q,7r,7s,19,19,19,7u,no,7v,7v,7w,7x,7y,7z,80,7y
81,82,83,2g,78,f,37,np,f,84,85,0,0,0,0,0
86,87,88,4c,4c,4c,4c,4c,89,8a,8b,8c,8d,8e,8f,8g
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME 03_BuitenCinema
EXT 0,12 2 15,12 FX tunnel
EXT 9,12 4 2,10 FX tunnel
PAL 3

ROOM 4
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
4,7,8,8,8,8,8,8,8,8,8,8,8,8,9,6
4,6,8h,8i,8j,8k,8l,f,f,f,f,f,f,f,4,6
4,6,8m,2p,8n,0,8l,f,8o,8p,8q,f,f,f,4,6
4,6,8r,4q,f,0,8l,f,8o,8s,8t,f,f,f,4,6
4,6,8,8,8,8u,f,f,f,f,f,f,f,f,4,6
4,6,8l,8l,f,f,f,f,f,f,8v,8p,8q,f,4,6
4,6,f,f,f,f,f,f,f,f,f,8s,8t,f,4,6
4,6,8w,f,f,f,f,f,f,f,f,f,f,f,4,6
4,6,f,f,f,8l,8x,8l,f,f,f,f,f,f,4,6
4,s,2,2,2,2,2,2,2,2,3,t,1,2,u,6
4,0,0,0,0,0,0,0,0,0,s,2,u,0,0,6
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
v,8,8,8,8,8,8,8,8,8,8,8,8,8,8,w
NAME 04_CinemaBinnen
EXT 11,12 5 5,12 FX tunnel DLG 9
EXT 2,10 3 9,12 FX tunnel
PAL 2

ROOM 5
g,66,8y,x,x,8z,x,4h,90,x,x,x,x,91,x,92
4q,2m,93,7t,94,f,3g,f,95,5r,96,f,f,4r,4x,1h
97,f,98,f,f,37,f,18,f,99,9a,54,9b,9c,f,1h
9d,9e,9f,9g,f,7m,f,5d,9h,9i,f,2p,f,9j,f,9k
9l,22,9m,96,9n,f,f,19,9o,94,f,f,f,9p,9q,1h
0,9s,9t,9u,37,f,9v,f,9w,9x,f,3w,9y,f,f,1h
0,0,9z,a0,6e,a1,a2,a3,1h,f,5b,f,54,f,2p,a4
0,0,0,0,0,a5,a6,f,15,a3,f,42,43,f,a7,a8
0,0,0,0,0,a9,f,f,f,7l,4x,aa,f,1t,7v,1h
0,0,0,0,0,ab,3w,ac,ad,f,f,ae,7k,f,f,1h
0,0,0,0,0,f,54,7k,af,99,ag,ah,7v,f,53,ai
0,0,0,0,0,ag,24,24,24,aj,2p,ak,77,77,43,1h
0,0,0,0,nq,40,1s,f,1k,al,f,f,f,f,7l,o0
an,ao,ap,aq,ar,as,at,au,au,au,au,au,au,au,av,aw
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME 05_CinemaAchter
EXT 5,12 4 11,12 FX tunnel
EXT 15,12 6 0,12 FX tunnel DLG a
PAL 3

ROOM 6
9r,x,x,x,ax,x,x,ay,x,x,az,x,x,4m,x,92
b0,3m,b1,7m,1c,f,b2,f,3w,b3,f,b4,b5,b6,42,1h
4q,b7,b8,b9,4x,ba,27,bb,f,5r,f,bb,9e,4q,bc,1h
bd,be,be,bf,bg,19,f,bh,f,2p,1k,f,f,1j,f,1h
bi,bj,bj,0,bl,f,bm,bn,f,f,f,bo,4x,f,f,bp
bq,br,bs,bt,bu,f,f,bv,f,bw,94,f,1u,7u,bx,1h
4q,by,bz,c0,58,f,f,f,19,5e,f,c1,c2,3t,f,1h
4q,2f,9u,f,c3,7s,bb,f,f,f,9q,f,c4,9q,1t,c5
4q,9y,f,f,f,f,f,2f,43,f,c6,c7,c8,c9,f,1h
ca,3u,cb,f,5t,f,99,f,1c,f,f,cc,cd,ce,cf,1h
4q,f,f,f,1c,cg,ch,f,41,ci,cj,ck,cl,cm,cn,co
nz,7m,54,9u,ag,1c,41,1c,41,1h,cp,cq,cq,cr,cq,cs
ct,f,7t,58,5r,bb,f,bb,f,84,cu,cv,cw,cx,cy,cz
d0,4c,4c,4c,4c,4c,4c,4c,d1,d2,d3,d4,d5,d6,d7,d8
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME 05_Jacobiberg
EXT 0,12 5 15,12 FX tunnel
EXT 9,12 7 10,4 FX tunnel
PAL 3

ROOM 7
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
4,7,8,8,8,8,8,8,8,8,8,8,8,8,9,6
4,6,d9,da,db,dc,f,f,f,f,dd,f,f,de,4,6
4,6,df,dg,f,f,f,f,f,f,f,f,f,dh,4,6
4,6,f,f,f,di,dj,f,f,dk,dk,dk,dl,f,4,6
4,6,f,f,f,dm,dn,f,f,do,dp,dq,dr,f,4,6
4,6,f,f,f,ds,dt,du,f,f,f,f,dv,f,4,6
4,6,dw,f,f,dx,dy,c0,f,f,f,f,f,f,4,6
4,6,dz,e0,f,f,f,f,f,9a,e1,e2,f,e3,4,6
4,6,e4,f,f,f,f,f,f,e5,0,e6,f,f,4,6
4,s,2,2,2,2,2,2,2,2,2,2,2,2,u,6
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
v,8,8,8,8,8,8,8,8,8,8,8,8,8,8,w
NAME 07_Knokpoeg
EXT 10,4 6 9,12 FX tunnel
EXT 10,11 8 1,12 FX wave DLG i
PAL 2

ROOM 8
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3
4,bk,e7,e8,e9,0,0,0,1x,eb,0,0,0,ec,ed,6
4,ee,ef,eg,eh,0,0,0,ei,ej,0,0,0,ek,el,6
4,em,en,eo,ep,0,0,0,0,0,eq,er,es,0,0,6
4,0,0,0,0,0,0,0,0,0,et,eu,ev,0,0,6
4,0,0,1x,ew,ex,ey,ez,0,0,f0,f1,f2,0,0,6
4,0,0,f3,f4,f4,f,f5,0,0,0,0,f6,f7,0,6
4,0,0,f8,f,8m,f,f9,0,0,fa,fb,f,fc,fd,fe
4,0,0,ff,fg,fh,fi,f2,0,fj,f,f,f,f,f,fk
4,0,0,0,0,0,0,0,0,fl,f,fm,f,fm,f,f
4,0,0,0,0,0,0,0,fn,f,f,fo,f,fo,f,f
fp,nt,nq,nq,nq,nq,nq,nq,fr,ns,ns,fs,ft,fu,f,f
ny,fv,0,0,0,0,0,0,0,fw,f,fx,fy,fz,f,f
g0,g1,g1,g1,g1,g1,g1,g1,g1,g2,g3,g4,g5,g6,f,g7
4,0,0,0,0,0,0,0,0,0,g8,g9,8m,ga,gb,6
v,8,8,8,8,8,8,8,8,8,8,8,8,8,8,w
NAME 08_Gat
EXT 11,12 9 3,12 FX wave
PAL 4

ROOM 9
1,ea,gc,gd,ge,2,2,gf,2,2,2,2,gg,2,gh,3
gi,0,gk,0,gl,gm,6a,gn,go,0,0,gp,gq,gr,f2,gs
gt,gu,gv,gw,0,0,0,gx,0,0,gy,0,gz,0,0,h0
h1,0,h2,0,h3,0,0,0,0,h4,h5,0,h6,h7,h8,h9
ha,0,hb,0,hc,hd,he,hf,gv,0,hg,0,0,hh,hi,hj
4,hk,0,0,hl,0,0,hm,0,0,0,0,hn,ho,hp,hq
hr,gm,hs,f6,0,0,ht,0,0,hu,0,hv,0,hw,hx,hy
hz,i0,2e,f,i1,i2,0,0,1f,i3,0,0,0,0,i4,i5
i6,f,f,f,f,f,i7,i8,0,i9,0,ia,gy,0,ib,ic
f,f,id,f,id,f,ie,0,if,ig,0,ih,0,0,ii,ij
f,f,ik,f,ik,f,f,il,0,0,0,im,0,hn,in,io
f,f,ip,iq,ir,ns,ns,is,nq,it,hf,iu,iv,nq,iw,ix
f,f,iy,iz,j0,f,j1,0,j2,0,j3,0,0,j4,j5,j6
j7,f,j8,j9,ja,jb,jc,au,au,au,au,au,av,jd,je,jf
4,jg,jh,8m,ji,jj,0,0,0,0,0,0,0,0,0,6
v,8,8,8,8,8,8,8,8,8,8,8,8,8,8,w
NAME 09_GatBuiten
EXT 3,12 8 11,12 FX wave
EXT 13,12 a 6,11 FX wave
PAL 4

ROOM a
gj,x,jk,jl,jm,2,jn,jo,jp,jq,jr,js,2,jt,ju,jv
jw,jx,jy,jz,0,0,k1,k2,k3,k4,k5,k6,k7,k8,k9,ka
kb,kc,kd,ke,kf,kg,kh,ki,0,kj,kk,kl,0,km,kn,ko
kp,f,kq,kr,0,ks,0,0,0,0,kt,ku,0,kv,kw,6
kx,ky,kz,l0,7,8,8,8,8,8,8,l1,l2,l3,l4,l5
l6,l7,0,0,6,b,c,d,e,f,g,4,l8,0,l9,1h
4,la,lb,lc,6,h,f,f,f,f,i,ld,le,lf,lg,lh
li,lj,lk,0,6,f,f,f,j,k,l,4,ll,lm,ln,lo
4,lp,lq,0,6,f,f,f,m,n,o,hr,0,lr,ls,lt
lu,lv,0,0,6,f,f,f,f,f,f,lw,lx,ly,0,lz
m0,hd,m1,0,6,f,f,f,p,q,r,4,m2,f2,m3,m4
4,m5,m6,0,s,3,t,1,2,2,m7,m8,0,0,m9,ma
mb,mc,md,0,0,s,m7,me,0,mf,mg,mh,mi,mj,0,mk
ml,mm,0,mn,mo,mp,mq,mr,0,0,ms,0,mt,mu,mv,mw
mx,my,mz,n0,f,n1,n2,n3,n4,0,n5,n6,n7,n8,f,n9
na,nb,nc,nd,ne,nf,ng,nh,ni,8,nj,nk,nl,8,nm,nn
NAME 10_Eindfeest
EXT 6,11 9 13,12 FX wave
PAL 5

ROOM b
1,2,o1,o2,o3,o4,o5,o6,o7,o8,o7,oa,ob,oc,2,3
4,od,oe,of,og,oh,0,0,0,0,0,0,0,0,0,6
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6
v,8,8,8,8,8,8,8,8,8,8,8,8,8,8,w
NAME SplashScreen
PAL 0

ROOM c
k0,oi,o1,o2,o3,o4,o5,o6,o7,o8,o7,oa,ob,oc,oi,oj
ok,od,oe,of,ol,oh,np,98,om,27,9b,on,oo,op,0,or
ok,os,ot,ou,ov,ow,np,c6,ox,oy,np,oz,p0,p1,0,or
ok,p2,p3,1d,p4,np,p5,b6,p6,p7,np,p8,p9,pa,pb,or
pc,pd,pe,pf,pg,ph,pi,2w,pj,pk,pl,pm,pn,po,pj,pp
pq,pr,ps,pt,pu,pv,np,pw,px,py,pz,q0,np,np,q1,q2
q3,q4,q5,q6,q7,q8,q9,qa,np,qb,qc,qd,qe,qf,qg,qh
ok,0,0,0,0,0,0,0,0,0,0,0,0,0,0,or
ok,0,0,0,0,0,0,0,0,0,0,0,0,0,0,or
ok,0,0,0,0,0,0,0,0,0,0,0,0,0,0,or
ok,0,0,0,0,0,0,0,0,0,0,0,0,0,0,or
ok,0,0,sc,sc,sc,sc,sc,sc,sc,sc,sc,sc,sc,0,or
ok,0,0,sc,0,0,0,0,0,0,0,0,0,sc,0,or
ok,ho,sb,sb,sb,sb,sb,sb,sb,sb,sb,sb,sb,sb,rn,or
ok,0,0,0,0,0,0,0,0,0,0,0,0,0,0,or
v,s0,s0,s0,s0,s0,s0,s0,s0,s0,s0,s0,s0,s0,s0,w
EXT 8,12 1 6,7 FX fade_w
EXT 6,12 1 6,7 FX fade_w
PAL 6

TIL 1
00000000
01111111
01000000
01000000
01000000
01000000
01000000
01000000
NAME 01_Kamer (0,0)
WAL true

TIL 2
00000000
11111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME 01_Kamer (1,0)
WAL true

TIL 3
00000000
11111110
00000010
00000010
00000010
00000010
00000010
00000010
NAME 01_Kamer (15,0)
WAL true

TIL 4
01000000
01000000
01000000
01000000
01000000
01000000
01000000
01000000
NAME 01_Kamer (0,1)
WAL true

TIL 5
00000000
11111111
11111111
11111111
11111111
11111111
11111101
11111100
NAME 02_Buiten (1,0)

TIL 6
00000010
00000010
00000010
00000010
00000010
00000010
00000010
00000010
NAME 01_Kamer (15,1)
WAL true

TIL 7
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00000010
NAME 01_Kamer (4,4)
WAL true

TIL 8
00000000
00000000
00000000
00000000
00000000
00000000
11111111
00000000
NAME 01_Kamer (5,4)
WAL true

TIL 9
00000000
00000000
00000000
00000000
00000000
00000000
11000000
01000000
NAME 01_Kamer (11,4)
WAL true

TIL 10
00000000
11111111
11111111
01111111
11111111
11111111
11111111
11111111
NAME 02_Buiten (11,0)

TIL 11
00000000
11111111
11111111
11111111
11111101
11111111
11111111
11111111
NAME 02_Buiten (12,0)

TIL 12
00000000
11111111
11111111
11111111
11111011
11111011
11111111
11111111
NAME 02_Buiten (13,0)

TIL 13
00000000
11111110
11111110
11111110
11111110
11111100
11111110
11111110
NAME 02_Buiten (15,0)

TIL 14
01111111
01111111
01111111
01110111
01111111
01111111
01111111
01111111
NAME 02_Buiten (0,1)

TIL 15
11111110
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 02_Buiten (1,1)

TIL 16
11111111
11111111
11111111
11111111
11111111
11111100
11111111
11111111
NAME 02_Buiten (2,1)

TIL 17
01111111
01111111
01111111
01111111
01111111
00011111
01111111
01111111
NAME 02_Buiten (3,1)

TIL 18
11111111
11111111
11111111
11111111
11111111
11111011
11111111
11111111
NAME 02_Buiten (4,1)

TIL 19
11111111
11111111
11111111
11111111
11111111
11111111
10111111
11111111
NAME 02_Buiten (7,1)
WAL true

TIL 20
01111111
01111111
01111111
00000000
00000000
00000000
00000000
00000000
NAME 02_Buiten (0,4)

TIL 21
01100111
01000111
00000111
00000001
00000000
00000000
00000000
00000000
NAME 02_Buiten (1,4)

TIL 22
11111111
11111111
11111111
11111111
11111111
01111111
00111111
00011111
NAME 02_Buiten (2,4)

TIL 23
11101111
11101111
11101111
11101111
11101111
11101111
11111110
11111111
NAME 02_Buiten (5,4)

TIL 24
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11101111
NAME 02_Buiten (7,4)
WAL true

TIL 25
11111111
11011111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 02_Buiten (8,4)
WAL true

TIL 26
11111111
11101111
11101111
11101111
11111111
11111111
11111111
11111111
NAME 02_Buiten (9,4)

TIL 27
11110111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 02_Buiten (10,4)

TIL 28
11111100
11111110
11111110
11111111
11111111
11111111
11111111
11111111
NAME 02_Buiten (11,4)

TIL 29
00000000
00000000
00000000
00000000
11000000
11100000
11111000
11111111
NAME 02_Buiten (12,4)

TIL 30
11111110
11111111
11111111
01111111
01111111
10111111
11011111
01001111
NAME 02_Buiten (13,7)

TIL 31
11110110
11111011
11111101
11011110
11101101
11110101
11110011
11111011
NAME 02_Buiten (14,7)

TIL 32
11100110
11110010
01110000
01111000
00111100
10011100
11011100
11101110
NAME 02_Buiten (15,7)

TIL 33
01110101
01110101
01110111
01110111
01110111
01110111
01110000
01111111
NAME 02_Buiten (0,8)

TIL 34
11011110
11011110
11011110
11011110
11011010
11011110
00011110
11111110
NAME 02_Buiten (1,8)

TIL 35
11111111
11111111
11111111
11101111
11101111
11101111
11101111
11101111
NAME 02_Buiten (4,8)

TIL 36
11111110
11111110
11111110
11111110
11111110
11111111
11111111
11111111
NAME 02_Buiten (6,8)

TIL 37
11111111
11101111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 02_Buiten (8,8)

TIL 38
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111011
NAME 02_Buiten (10,8)

TIL 39
11101111
11111111
11111111
11111111
11111111
11111110
11111011
11101111
NAME 02_Buiten (12,8)

TIL 40
00000000
10101010
10101010
10101110
10101010
10101110
10101010
10101010
NAME 02_Buiten (2,12)

TIL 41
11111111
11111111
11111111
11111111
11111111
11110111
11111111
11111111
NAME 02_Buiten (5,12)
WAL true

TIL 42
11111111
11111111
11111111
11111011
11111111
11111111
11111111
11111111
NAME 02_Buiten (7,12)

TIL 43
11111111
11111111
11111111
11111110
11111111
11111111
11111111
11111111
NAME 02_Buiten (8,12)
WAL true

TIL 44
11111111
11111111
11111111
11111111
11111111
11110011
11111111
11111111
NAME 02_Buiten (12,12)

TIL 45
11111111
11111111
11111111
11111111
11111111
11111110
11110000
10000000
NAME 02_Buiten (13,12)

TIL 46
11000001
11000000
11000000
10000000
10000000
00000000
00000000
00000000
NAME 02_Buiten (14,12)

TIL 47
11111110
11111110
11111110
11111110
01111110
01111110
00111110
00011110
NAME 02_Buiten (15,12)

TIL 48
00000000
01011011
01110110
01101111
00000000
00000000
00000000
00000000
NAME 02_Buiten (0,13)

TIL 49
00000000
10110011
01101110
10110011
00000000
00000000
00000000
00000000
NAME 02_Buiten (1,13)
WAL true

TIL 50
11011111
11011111
11011111
11011111
00000111
00000111
11011111
11011111
NAME 03_BuitenCinema (2,2)

TIL 51
11111101
11110000
11111101
11111101
01111101
11111101
11111101
11111101
NAME 03_BuitenCinema (5,2)

TIL 52
11111111
00011111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (6,2)

TIL 53
11111111
11111111
11111111
11111111
11111111
11011111
11111111
11111111
NAME 03_BuitenCinema (7,2)

TIL 54
11111111
11111111
11111101
11111111
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (9,2)
WAL true

TIL 55
11110111
11110111
11000001
11110111
11110111
11110111
11110111
11110111
NAME 03_BuitenCinema (11,2)

TIL 56
00000011
11011111
11011111
11011111
11011111
11011111
11011111
11011111
NAME 03_BuitenCinema (12,2)

TIL 57
11011111
11011111
11011111
00000111
11011111
11011111
11011111
11011111
NAME 03_BuitenCinema (13,2)

TIL 58
11111111
11111101
11111111
11111111
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (14,2)

TIL 59
11111110
11111110
11111110
11111110
11101110
11111110
11111110
10111110
NAME 03_BuitenCinema (15,2)

TIL 60
00000000
00000000
00010000
00010000
00010000
00010000
00010000
00000000
NAME 03_BuitenCinema (4,5)

TIL 61
00000111
00000111
00000011
00000011
00000011
00000001
00000001
00000001
NAME 03_BuitenCinema (6,5)

TIL 62
11111111
11111111
11111111
11111111
11111101
01111101
11111101
11111101
NAME 03_BuitenCinema (9,5)

TIL 63
11111111
11101111
11111111
11111111
11111111
11111111
11111110
11111111
NAME 03_BuitenCinema (11,5)

TIL 64
11111111
11111111
11111111
11111111
11111111
11111111
11101111
11111110
NAME 03_BuitenCinema (13,5)

TIL 65
11110000
11100000
11000000
10000000
10000000
00000000
00000000
00000000
NAME 03_BuitenCinema (14,5)

TIL 66
00000000
11111111
11111111
11111111
11111111
11001111
11001111
11001111
NAME 05_CinemaAchter (1,0)

TIL 67
01111111
01110111
01111111
01111111
01111111
01111111
01111111
01111111
NAME 03_BuitenCinema (0,6)

TIL 68
01111101
11011101
11101101
11110101
11111000
01111100
10110110
11010111
NAME 03_BuitenCinema (1,6)

TIL 69
10001110
11001110
11100010
11100000
11110000
11111000
01111100
00111100
NAME 03_BuitenCinema (2,6)

TIL 70
00000000
10011001
10011001
00000000
00000000
00000000
00000000
11111111
NAME 03_BuitenCinema (12,8)

TIL 71
00000000
10110011
10110011
00000000
00000011
00000110
00000100
11100100
NAME 03_BuitenCinema (13,8)

TIL 72
00000000
00110011
00110011
00000000
10001000
00001000
00001000
00001000
NAME 03_BuitenCinema (14,8)

TIL 73
00000000
00110011
00110011
00000000
11001001
11101001
10101001
10101001
NAME 03_BuitenCinema (15,8)

TIL 74
01111111
01111110
01111111
01111111
01111111
01111111
01111111
01111111
NAME 03_BuitenCinema (0,9)

TIL 75
11100011
11110001
11110000
11110000
11110000
11110000
11110000
11110000
NAME 03_BuitenCinema (1,9)

TIL 76
11100001
11100011
11000011
10000111
00000111
00001111
00011111
00011111
NAME 03_BuitenCinema (2,9)

TIL 77
11111011
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (5,9)
WAL true

TIL 78
11011111
11011111
11011111
11011111
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (6,9)

TIL 79
11110111
01110111
11110111
11110111
11000011
11110111
11110111
11110111
NAME 03_BuitenCinema (7,9)

TIL 80
11001111
11001111
11001111
11001111
11001111
11001111
11001111
11001111
NAME 03_BuitenCinema (14,11)

TIL 81
01111110
01111110
01111110
01111100
01111100
01110000
00000000
00000000
NAME 03_BuitenCinema (0,12)

TIL 82
00000011
00000011
00000011
00000001
00000001
00000000
00000000
00000000
NAME 03_BuitenCinema (1,12)

TIL 83
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00111111
NAME 03_BuitenCinema (2,12)

TIL 84
00000000
01010101
01010101
01110101
01010101
01110101
01010101
01010101
NAME 03_BuitenCinema (9,12)

TIL 85
00000000
00000000
00000000
00111110
00000000
00000000
00000000
00000000
NAME 03_BuitenCinema (10,12)
WAL true

TIL 86
00000000
01001101
01011111
01101110
00000000
00000000
00000000
00000000
NAME 03_BuitenCinema (0,13)
WAL true

TIL 87
00000000
10110111
11101111
11111111
00000000
00000000
00000000
00000000
NAME 03_BuitenCinema (1,13)
WAL true

TIL 88
00000000
00110110
11111110
11011100
00000000
00000000
00000000
00000000
NAME 03_BuitenCinema (2,13)
WAL true

TIL 89
00000000
11111011
11111010
11111011
00000000
00000000
00000000
00000000
NAME 03_BuitenCinema (8,13)
WAL true

TIL 90
00000000
11111111
11111111
11111111
11111111
11111110
11111111
11111111
NAME 05_CinemaAchter (8,0)

TIL 91
00000000
11111111
11111111
11011111
11111111
11111111
11111111
11111111
NAME 05_CinemaAchter (13,0)

TIL 92
00000000
11111110
11111110
11111110
11111110
11111110
11111110
11111110
NAME 05_CinemaAchter (15,0)

TIL 93
11111111
11111111
11111111
11111111
11111111
10111111
10111111
10111111
NAME 05_CinemaAchter (2,1)

TIL 94
01111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 05_CinemaAchter (4,1)

TIL 95
11111111
11111111
11111111
11101111
11111111
11111111
11111111
11111111
NAME 05_CinemaAchter (8,1)

TIL 96
11111111
11111111
11111111
11111111
11101111
11111111
11111111
11111111
NAME 05_CinemaAchter (10,1)

TIL 97
01111111
01111111
01111111
01111011
01111111
01111111
01111111
01110111
NAME 05_CinemaAchter (0,2)

TIL 98
10111111
10111111
10111111
10111111
10111111
10111111
10111111
10111111
NAME 05_CinemaAchter (2,2)

TIL 99
11111111
11111111
11111111
11111111
11111111
11111111
01111111
01111111
NAME 05_CinemaAchter (9,2)

TIL a
11111111
10000001
10000001
10011001
10011001
10000001
10000001
11111111
NAME block

TIL b
00100101
00100101
11111111
00111111
11111111
00000010
10101010
10101010
NAME 01_Kamer (5,5)
WAL true

TIL c
10100010
10110110
10111110
10000000
11111111
00000000
11111111
00000000
NAME 01_Kamer (6,5)
WAL true

TIL d
11110111
11110000
11110111
11110000
11111111
00000000
11111111
00000000
NAME 01_Kamer (7,5)
WAL true

TIL e
11111010
00000010
11111010
00000010
11111110
00000000
11111101
00000001
NAME 01_Kamer (8,5)
WAL true

TIL f
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 01_Kamer (9,5)
WAL false

TIL g
00000000
01111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME 01_Kamer (10,5)
WAL true

TIL h
00000010
10101010
10101010
00000010
11111110
00000000
11111101
00000001
NAME 01_Kamer (5,6)
WAL true

TIL i
01111111
01111111
01111111
01111111
01111111
00000000
10111111
10000000
NAME 01_Kamer (10,6)
WAL true

TIL j
11000000
11011110
11000000
11011110
00000000
01111111
01000000
01000101
NAME 01_Kamer (8,7)
WAL true

TIL k
11110000
11110111
11110000
11110111
00000000
11111111
01011111
01011111
NAME 01_Kamer (9,7)
WAL true

TIL l
00111111
10111111
00111111
10111111
00000000
11111111
11110001
11110001
NAME 01_Kamer (10,7)
WAL true

TIL m
01000010
01000000
01111111
00000000
00000000
10111111
10111111
11111111
NAME 01_Kamer (8,8)
WAL true

TIL n
01011111
01111111
11111111
00000000
00000000
11111111
11111111
11111111
NAME 01_Kamer (9,8)
WAL true

TIL o
11111111
11111001
11111111
00000000
00000000
11111101
11111101
11111111
NAME 01_Kamer (10,8)
WAL true

TIL p
11111111
10000000
10111101
10011010
10101111
10111111
10101101
10111011
NAME 01_Kamer (8,10)
WAL true

TIL q
11111111
00000000
11101111
11011010
11111111
11010110
11111111
10111011
NAME 01_Kamer (9,10)
WAL true

TIL r
11111111
00000011
11111011
11011011
11110011
11111011
11101011
10111011
NAME 01_Kamer (10,10)
WAL true

TIL s
00000010
00000011
00000000
00000000
00000000
00000000
00000000
00000000
NAME 01_Kamer (4,11)
WAL true

TIL t
00000000
11111111
00000000
11111111
00000000
11111111
00000000
11111111
NAME 01_Kamer (6,11)

TIL u
01000000
11000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 01_Kamer (11,11)
WAL true

TIL v
01000000
01000000
01000000
01000000
01000000
01000000
01111111
00000000
NAME 01_Kamer (0,15)

TIL w
00000010
00000010
00000010
00000010
00000010
00000010
11111110
00000000
NAME 01_Kamer (15,15)

TIL x
00000000
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 02_Buiten (2,0)

TIL y
00000000
11111111
11111111
11111111
01111111
01111111
01111111
01111111
NAME 02_Buiten (3,0)

TIL z
00000000
11111111
11111111
11111111
11111111
11111111
01111111
11111111
NAME 02_Buiten (8,0)

TIL 1a
11111111
11111111
11111110
11111110
11111110
11111110
11111110
11000000
NAME 02_Buiten (8,1)

TIL 1b
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000111
NAME 02_Buiten (9,1)

TIL 1c
11111111
11111111
11110111
11111111
11111111
11111111
11111111
11111111
NAME 02_Buiten (10,1)
WAL true

TIL 1d
11111111
11111111
11111111
11111111
11111111
11111110
11111110
11111100
NAME 02_Buiten (11,1)

TIL 1e
11111111
11111000
11100000
11000000
00000000
00000000
00000000
00000000
NAME 02_Buiten (12,1)

TIL 1f
00000011
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 02_Buiten (13,1)

TIL 1g
11111111
01111111
00011111
00001111
00000011
00000001
00000001
00000000
NAME 02_Buiten (14,1)

TIL 1h
11111110
11111110
11111110
11111110
11111110
11111110
11111110
11111110
NAME 02_Buiten (15,1)
WAL true

TIL 1i
01111111
01111111
01111111
01111111
01111111
01111111
01111110
01111111
NAME 02_Buiten (0,2)

TIL 1j
01111111
01111111
01111111
01111111
01111111
11111111
11111111
11111111
NAME 02_Buiten (3,2)

TIL 1k
11111111
11111111
11111111
11111111
11111111
01111111
11111111
11111111
NAME 02_Buiten (5,2)

TIL 1l
11111110
11111110
11111110
11111110
11111110
11111110
11111111
11111111
NAME 02_Buiten (8,2)

TIL 1m
11111000
11111000
11110000
11110000
11110000
11100000
11100000
11100000
NAME 02_Buiten (11,2)

TIL 1n
00000000
00000000
00000010
00000010
00000010
00000010
00000010
00000000
NAME 02_Buiten (12,2)

TIL 1p
01111110
01111110
00111110
00111110
00111110
00011110
00011110
00011110
NAME 02_Buiten (15,2)

TIL 1q
01111111
01111111
01111111
01111111
01111111
01111111
01111111
01111110
NAME 02_Buiten (0,3)

TIL 1r
11111111
11111111
11111111
11111111
11111111
11011011
11000011
11000011
NAME 02_Buiten (1,3)

TIL 1s
11111111
11111111
11111111
11111111
11111011
11111111
11111111
11111111
NAME 02_Buiten (2,3)

TIL 1t
11111111
11111111
11111111
11111111
11111111
11111111
11110111
11111111
NAME 02_Buiten (3,3)

TIL 1u
11111111
11111111
11111111
11111111
11111111
11111111
11101111
11101111
NAME 02_Buiten (5,3)

TIL 1v
11111111
11111111
11110011
11110011
11110011
11110011
11111111
11111111
NAME 02_Buiten (6,3)

TIL 1w
11100000
10100000
11100000
11110000
11110000
11110000
11111000
11111000
NAME 02_Buiten (11,3)

TIL 1x
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME 02_Buiten (12,3)

TIL 1y
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111110
NAME 02_Buiten (13,3)

TIL 1z
00011110
00011110
00011110
00111110
00111110
00111110
01111110
01111110
NAME 02_Buiten (15,3)

TIL 2a
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000011
NAME 02_Buiten (13,4)

TIL 2b
00000000
00000001
00000001
00000011
00001111
00011111
01111111
11111111
NAME 02_Buiten (14,4)

TIL 2c
00000000
01111111
00001111
01111111
01111111
01100000
01100000
01110111
NAME 02_Buiten (0,5)

TIL 2d
00000000
11111110
11111010
11111110
11111110
00001110
00001110
11011110
NAME 02_Buiten (1,5)

TIL 2e
00001111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 02_Buiten (2,5)

TIL 2f
11111111
11111111
11111111
11111111
01111111
11111111
11111111
11111111
NAME 02_Buiten (3,5)

TIL 2g
11111111
11111111
11111111
11111111
11111101
11111111
11111111
11111111
NAME 02_Buiten (8,5)

TIL 2h
11111001
11111001
11111001
11111111
11111111
11111111
11111111
11111001
NAME 02_Buiten (11,5)

TIL 2i
11111111
11111111
11111111
11111111
11111111
11111110
11111111
11111111
NAME 02_Buiten (14,5)
WAL true

TIL 2j
11111110
11111110
11111110
11111110
11111110
11111110
11111100
01111100
NAME 02_Buiten (15,5)

TIL 2k
01110101
01110101
01110101
01110111
01110111
01110111
01110000
01111111
NAME 02_Buiten (0,6)

TIL 2l
11011110
11011110
11011110
11011110
11011110
11011110
00011110
11111110
NAME 02_Buiten (1,6)

TIL 2m
11001111
11001111
11001111
11111111
11111111
11111111
11111111
11111111
NAME 02_Buiten (2,6)

TIL 2n
11111111
11111111
11111111
11111111
10111111
11111011
11111111
11111111
NAME 02_Buiten (4,6)

TIL 2o
11111111
11111111
11111111
11110101
11111101
11111101
11111101
11000000
NAME 02_Buiten (9,6)

TIL 2p
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01111111
NAME 02_Buiten (10,6)
WAL true

TIL 2q
11111111
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME 02_Buiten (13,6)

TIL 2r
11111111
11110111
11111101
11111110
10111111
10111110
11011110
11101110
NAME 02_Buiten (14,6)

TIL 2s
01111110
11111110
11110110
10111110
00111110
10001110
11001110
11001110
NAME 02_Buiten (15,6)

TIL 2t
01100001
01111111
01110001
00111111
01111111
01100000
01100000
01110111
NAME 02_Buiten (0,7)

TIL 2u
11111110
10001110
11111010
11111110
11111110
00001110
00001110
11011110
NAME 02_Buiten (1,7)

TIL 2v
11000000
11111110
11111110
11111110
11111110
11111110
11111110
11111110
NAME 02_Buiten (6,7)

TIL 2w
00111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 02_Buiten (7,7)

TIL 2x
11111101
11111101
11111101
11111101
11111101
11111101
11111111
11111111
NAME 02_Buiten (9,7)

TIL 2y
11101111
11101111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 02_Buiten (11,7)

TIL 2z
11111101
11111110
11111111
11111101
11111111
11111111
11111111
11101010
NAME 02_Buiten (12,7)

TIL 3a
10001111
11100011
11111000
11111110
11111111
01111111
11101000
10111111
NAME 02_Buiten (13,8)

TIL 3b
11111011
11110011
01110111
00010111
10000111
11000111
01100111
10010111
NAME 02_Buiten (14,8)

TIL 3c
11110110
11110110
11111000
11111000
11111000
11111000
11111100
11111000
NAME 02_Buiten (15,8)

TIL 3d
00011111
01111111
01110011
01100111
01111111
01100000
01100000
01110111
NAME 02_Buiten (0,9)

TIL 3e
00011110
11111110
11111010
11111110
11111110
00001110
00001110
11011110
NAME 02_Buiten (1,9)

TIL 3f
11000011
11101111
11101111
11101111
11101111
11101111
11101111
11101111
NAME 02_Buiten (4,9)

TIL 3g
11111111
11111111
01111111
11111111
11111111
11111111
11111111
11111111
NAME 02_Buiten (6,9)

TIL 3h
11111111
11111111
11111111
11111101
11111101
11111101
11111101
11111101
NAME 02_Buiten (7,9)

TIL 3i
11000011
11100011
11110001
11111001
11111000
11111100
11111100
11111100
NAME 02_Buiten (14,9)

TIL 3j
11111000
11111000
11111000
11110000
11110000
01100010
01100010
00000110
NAME 02_Buiten (15,9)

TIL 3k
01110101
01110101
01110101
00010101
01110111
01110111
01110000
00011111
NAME 02_Buiten (0,10)

TIL 3l
11011110
11011110
11011000
11011110
11011110
11011110
00011110
11111110
NAME 02_Buiten (1,10)

TIL 3m
11101111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 02_Buiten (4,10)

TIL 3n
11111100
11111100
11111100
11111000
11111000
11111000
11110000
11110000
NAME 02_Buiten (14,10)

TIL 3o
00000110
00001110
00001110
00111110
00111110
01111110
11111110
11111110
NAME 02_Buiten (15,10)

TIL 3p
01111111
01111111
00011111
01111111
01111111
01100000
01100000
01110111
NAME 02_Buiten (0,11)
WAL true

TIL 3q
11111000
11111110
11001110
11111110
11111000
00001110
00001110
11011110
NAME 02_Buiten (1,11)
WAL true

TIL 3r
11111001
11111001
11111111
11111111
11111111
11111111
11111111
11111111
NAME 02_Buiten (3,11)
WAL true

TIL 3s
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11011111
NAME 02_Buiten (4,11)
WAL true

TIL 3t
11111111
11111111
11111111
11111111
11110111
11111111
11111111
11111111
NAME 02_Buiten (6,11)
WAL true

TIL 3u
11111111
11111111
11111111
11111111
11111111
11111111
11101111
11111111
NAME 02_Buiten (8,11)
WAL true

TIL 3v
11111111
11111111
11111111
11111111
11111110
11111111
11111111
11111111
NAME 02_Buiten (9,11)
WAL true

TIL 3w
11111111
10111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 02_Buiten (11,11)
WAL true

TIL 3x
11110000
11100001
11100001
11100001
11100001
11100001
11000001
11000001
NAME 02_Buiten (14,11)
WAL true

TIL 3y
01110101
01110101
01000111
01110111
01110111
01110111
01110000
01111111
NAME 02_Buiten (0,12)

TIL 3z
11011110
11011000
11011110
11011110
11010110
11011110
00011100
11111110
NAME 02_Buiten (1,12)
WAL true

TIL 4a
00000000
01111100
11001110
11101010
00000000
00000000
00000000
00000000
NAME 02_Buiten (2,13)
WAL true

TIL 4b
00000000
11011111
10011100
11011111
00000000
00000000
00000000
00000000
NAME 02_Buiten (3,13)
WAL true

TIL 4c
00000000
11111111
11111100
11111111
00000000
00000000
00000000
00000000
NAME 02_Buiten (4,13)
WAL true

TIL 4d
00000000
11111011
11111001
11111010
00000000
00000000
00000000
00000000
NAME 02_Buiten (12,13)
WAL true

TIL 4e
00000000
00110100
01111010
01101111
00000000
00000000
00000000
00000000
NAME 02_Buiten (13,13)
WAL true

TIL 4f
00000000
00110011
11011011
11011110
00000000
00000000
00000000
00000000
NAME 02_Buiten (14,13)
WAL true

TIL 4g
00000000
00111010
11101100
01110110
00000000
00000000
00000000
00000000
NAME 02_Buiten (15,13)
WAL true

TIL 1o
00000000
11111111
11111111
11111111
11111111
01111111
11111111
11111111
NAME 03_BuitenCinema (2,0)

TIL 4h
00000000
11111111
11111111
11111111
11111111
11111111
11111111
11101111
NAME 03_BuitenCinema (3,0)

TIL 4i
00000000
11111111
11111111
11111111
11111111
11101111
11111111
11111111
NAME 03_BuitenCinema (4,0)

TIL 4j
00000000
11111111
11111111
11111111
11111111
11111111
11111101
11111111
NAME 03_BuitenCinema (5,0)

TIL 4k
00000000
11111111
11111111
11111111
11111111
11111111
11111011
11111111
NAME 03_BuitenCinema (7,0)

TIL 4l
00000000
11111111
11111111
11111111
11111111
11111111
11110111
11111111
NAME 03_BuitenCinema (9,0)

TIL 4m
00000000
11111111
11111111
11111011
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (10,0)

TIL 4n
00000000
11111111
11111111
11111111
11111111
11011111
11111111
11111111
NAME 03_BuitenCinema (13,0)

TIL 4o
00000000
11111111
11111111
11111111
11111111
11111111
10111111
11111111
NAME 03_BuitenCinema (14,0)

TIL 4p
00000000
11111110
11111110
11111110
11111110
11111110
11111110
11011110
NAME 03_BuitenCinema (15,0)

TIL 4q
01111111
01111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME 03_BuitenCinema (0,1)

TIL 4r
11111111
11111111
11111111
11011111
11011111
11011111
11011111
11011111
NAME 03_BuitenCinema (2,1)

TIL 4s
11111111
11111111
11111111
11111111
11111111
11111010
11111111
11111111
NAME 03_BuitenCinema (3,1)

TIL 4t
11111111
11111111
11111101
11111101
11111101
11111101
11111101
11111101
NAME 03_BuitenCinema (5,1)

TIL 4u
11111111
11111111
11111111
11111111
11011111
11111111
11111111
11111111
NAME 03_BuitenCinema (8,1)

TIL 4v
11111111
11111111
11110111
11110111
11110111
11110111
11110111
11110111
NAME 03_BuitenCinema (11,1)

TIL 4w
11111111
11011111
11011111
11011111
11011111
11011111
11011111
11011111
NAME 03_BuitenCinema (12,1)

TIL 4x
11111111
11111111
11111111
11110111
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (14,1)

TIL 4y
01111111
01111111
01110111
01111111
01111111
01111111
01111111
01111111
NAME 03_BuitenCinema (0,2)

TIL 4z
11111111
11011111
11111111
11111111
11111110
11111110
11111111
11111111
NAME 03_BuitenCinema (1,2)

TIL 5a
01111111
01111111
01111111
01111111
01111111
01111111
01111111
01101111
NAME 03_BuitenCinema (0,3)

TIL 5b
11111111
11111111
10111111
11111111
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (1,3)

TIL 5c
11011111
11011111
11011111
11011111
11011111
11011111
11111111
11111111
NAME 03_BuitenCinema (2,3)

TIL 5d
11111111
11111111
11111111
11011111
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (3,3)

TIL 5e
11111101
11111101
11111101
11111101
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (5,3)

TIL 5f
11011111
11011111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (8,3)

TIL 5g
11110111
11110111
11110111
11110111
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (11,3)

TIL 5h
11011111
11011111
11011111
11011111
11011111
11011111
11011111
11111111
NAME 03_BuitenCinema (13,3)

TIL 5i
11111111
11111111
11111111
11111111
11111111
11100111
11111111
11111111
NAME 03_BuitenCinema (14,3)

TIL 5j
11111110
11111110
11111110
11111110
11111110
11101110
11111110
11111110
NAME 03_BuitenCinema (15,3)

TIL 5k
11111111
11111111
11111111
11111111
11111011
11111110
11111100
11111110
NAME 03_BuitenCinema (1,4)

TIL 5l
11111111
11111111
11111111
11111111
11111111
11111111
11111011
11111110
NAME 03_BuitenCinema (2,4)

TIL 5m
11111111
11111111
11111110
11111100
11110000
11100000
10100000
11000000
NAME 03_BuitenCinema (3,4)

TIL 5n
11110000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 03_BuitenCinema (4,4)

TIL 5o
00111111
00000111
00000001
00000000
00000000
00000000
00000000
00000000
NAME 03_BuitenCinema (5,4)

TIL 5p
11111111
11111111
11111111
11111111
00111111
00011111
00011111
00001111
NAME 03_BuitenCinema (6,4)

TIL 5q
11011111
11111111
11111111
11111111
11111111
11111111
11111111
11111011
NAME 03_BuitenCinema (8,4)

TIL 5r
11111111
11111111
11111110
11111111
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (9,4)

TIL 5s
11111111
11111111
11111101
00111111
00111111
11111111
11111111
11111111
NAME 03_BuitenCinema (11,4)

TIL 5t
11111111
11111111
11011111
11111111
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (13,4)

TIL 5u
11111111
11111111
11111111
11111111
11111111
11111110
11111100
11111000
NAME 03_BuitenCinema (14,4)

TIL 5v
11111110
11111110
11111110
11111000
11000000
00000000
00000000
00000000
NAME 03_BuitenCinema (15,4)

TIL 5w
01111111
01111111
01110111
01111011
01111111
01111101
01111101
01111110
NAME 03_BuitenCinema (0,5)

TIL 5x
01111110
11011110
11100110
11111010
11111100
11111110
11111011
11111011
NAME 03_BuitenCinema (1,5)

TIL 5y
11111011
11110111
11101111
01111111
01111111
00111110
00011110
10011110
NAME 03_BuitenCinema (2,5)

TIL 5z
00000000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 03_BuitenCinema (3,5)

TIL 6a
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00011111
NAME 03_BuitenCinema (4,6)

TIL 6b
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11100000
NAME 03_BuitenCinema (5,6)

TIL 6c
00000001
00000001
00000001
00000011
00000011
00000011
00000111
00000111
NAME 03_BuitenCinema (6,6)

TIL 6d
11111101
11111101
11111000
11111101
11111101
11111101
11111101
11111101
NAME 03_BuitenCinema (9,6)

TIL 6e
11111111
11111111
11111111
11111111
11111111
11111111
00000000
00000000
NAME 03_BuitenCinema (11,6)

TIL 6f
11111110
11111110
11111100
11111100
11111100
11111100
00000000
00000000
NAME 03_BuitenCinema (13,6)

TIL 6g
01111111
01111111
01111111
00111111
00001111
01000011
01110000
01111000
NAME 03_BuitenCinema (0,7)

TIL 6h
11001111
11001111
11001111
11001111
11011111
11011111
11011111
00011111
NAME 03_BuitenCinema (1,7)

TIL 6i
10011100
11011110
11001110
11100110
11110000
11110000
11111000
11111000
NAME 03_BuitenCinema (2,7)

TIL 6j
01000000
01100000
01100000
01110000
01110000
01000010
00001111
00011111
NAME 03_BuitenCinema (3,7)

TIL 6k
00000000
00000000
00000000
00000000
00000000
00000000
10000000
11110000
NAME 03_BuitenCinema (4,7)

TIL 6l
00000000
00000000
00000000
00000000
00000000
00000001
00000111
00111111
NAME 03_BuitenCinema (5,7)

TIL 6m
00001111
00011111
00011111
00111111
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (6,7)

TIL 6n
11111111
11111111
11111111
11111111
11111111
11111111
11011111
11111111
NAME 03_BuitenCinema (7,7)

TIL 6o
01111111
11111111
11111111
11111111
11111111
11111111
11111111
11101111
NAME 03_BuitenCinema (8,7)

TIL 6p
11111101
11111101
11111111
11111111
10111111
11111111
11111111
11111111
NAME 03_BuitenCinema (9,7)

TIL 6q
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111000
NAME 03_BuitenCinema (10,7)

TIL 6r
01111110
00000111
01111001
01111100
01111110
01111111
01111111
01111111
NAME 03_BuitenCinema (0,8)

TIL 6s
00011111
00011111
10011111
10001111
00001111
00001111
11000111
11100111
NAME 03_BuitenCinema (1,8)

TIL 6t
11111000
11111000
01111000
11111000
11111000
11110000
11110000
11110000
NAME 03_BuitenCinema (2,8)

TIL 6u
00111111
01111111
01111111
11111111
11000011
00111111
01111111
11111111
NAME 03_BuitenCinema (3,8)

TIL 6v
11111111
11111111
11011111
00111111
11110111
11111111
11111111
11111111
NAME 03_BuitenCinema (4,8)

TIL 6w
11111111
11111111
11111111
11111111
11111111
11111111
11011111
11011111
NAME 03_BuitenCinema (6,8)

TIL 6x
11111111
11111111
11111111
11111111
11110111
11110111
11110111
11110111
NAME 03_BuitenCinema (7,8)

TIL 6y
11111000
11111001
11111001
11111000
11111001
11111001
11111000
11111000
NAME 03_BuitenCinema (10,8)

TIL 6z
00000000
10011001
10011001
00000000
10000000
10000000
00000000
00001111
NAME 03_BuitenCinema (11,8)

TIL 7a
01111111
11110111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (9,9)

TIL 7b
11111001
11111001
11111000
11111001
11111001
11111000
11111000
11111110
NAME 03_BuitenCinema (10,9)

TIL 7c
10000000
10000000
00000000
10011001
10011001
00000000
00000000
00000000
NAME 03_BuitenCinema (11,9)

TIL 7d
00000000
00000000
00000000
10011001
10011001
00000000
00000000
00000000
NAME 03_BuitenCinema (12,9)

TIL 7e
00000111
00000011
00000000
10110011
10110011
00000000
00000000
00000000
NAME 03_BuitenCinema (13,9)

TIL 7f
10001000
10001000
00000000
00110011
00110011
00000000
00000000
00000000
NAME 03_BuitenCinema (14,9)

TIL 7g
10011001
10011001
00000000
00110011
00110011
00000000
00000000
00000000
NAME 03_BuitenCinema (15,9)

TIL 7h
01111111
01111111
00111111
01111111
01111111
01111111
01111111
01111111
NAME 03_BuitenCinema (0,10)

TIL 7i
11110000
11100000
11100000
11000001
11000001
11000011
10000011
10000011
NAME 03_BuitenCinema (1,10)

TIL 7j
00111111
01111111
11111111
11111111
11111111
11111111
11111110
11111111
NAME 03_BuitenCinema (2,10)

TIL 7k
11111111
11111111
11111111
11111101
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (3,10)

TIL 7l
11111111
11111111
11111111
11111111
11111111
11111111
11111101
11111111
NAME 03_BuitenCinema (4,10)

TIL 7m
11111111
11111111
11111011
11111111
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (5,10)
WAL true

TIL 7n
11110111
11110111
11110111
11110111
11110111
11110111
11111111
11111111
NAME 03_BuitenCinema (7,10)

TIL 7o
11111111
11111100
11111100
11111111
11111111
01111111
11111111
11111111
NAME 03_BuitenCinema (9,10)

TIL 7p
11111110
00000000
00000000
00111110
00111110
00111110
00111110
00111110
NAME 03_BuitenCinema (10,10)

TIL 7q
01111111
01111111
01111111
01111111
01111111
01111110
01111110
01111110
NAME 03_BuitenCinema (0,11)
WAL true

TIL 7r
10000011
00000111
00000111
00000111
00000111
00000111
00000011
00000011
NAME 03_BuitenCinema (1,11)
WAL true

TIL 7s
11111111
11111111
11111111
10111111
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (2,11)
WAL true

TIL 7t
11111111
11111111
11111111
11111111
11111111
11111101
11111111
11111111
NAME 03_BuitenCinema (3,11)

TIL 7u
11111111
11111111
11101111
11111111
11111111
11111111
11111111
11111111
NAME 03_BuitenCinema (6,11)
WAL true

TIL 7v
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11110111
NAME 03_BuitenCinema (8,11)
WAL true

TIL 7w
00111110
00111110
00111110
00111110
00111110
00111110
00111110
00111110
NAME 03_BuitenCinema (10,11)
WAL true

TIL 7x
00001111
00001111
00001111
00001111
00001111
00001111
00001111
00001111
NAME 03_BuitenCinema (11,11)

TIL 7y
00111100
00111100
00111100
00111100
00111100
00111100
00111100
00111100
NAME 03_BuitenCinema (12,11)

TIL 7z
11110011
11110011
11110011
11110011
11110011
11110011
11110011
11110011
NAME 03_BuitenCinema (13,11)

TIL 8a
00000000
01011011
01101010
01110111
00000000
00000000
00000000
00000000
NAME 03_BuitenCinema (9,13)
WAL true

TIL 8b
00000000
10110101
10000110
11000110
00000000
00000000
00000000
00000000
NAME 03_BuitenCinema (10,13)
WAL true

TIL 8c
00000000
11010101
11101111
01101100
00000000
00000000
00000000
00000000
NAME 03_BuitenCinema (11,13)

TIL 8d
00000000
10111001
01001111
11110011
00000000
00000000
00000000
00000000
NAME 03_BuitenCinema (12,13)

TIL 8e
00000000
11101111
10111110
01110111
00000000
00000000
00000000
00000000
NAME 03_BuitenCinema (13,13)

TIL 8f
00000000
11110011
11011100
11110110
00000000
00000000
00000000
00000000
NAME 03_BuitenCinema (14,13)

TIL 8g
00000000
01110110
01100100
11011110
00000000
00000000
00000000
00000000
NAME 03_BuitenCinema (15,13)

TIL 8h
00000000
11111110
00000000
10110111
00000000
11111101
00000000
00000000
NAME 04_CinemaBinnen (2,4)

TIL 8i
00000000
11111110
00000000
11101110
00000000
11111010
00000000
00000000
NAME 04_CinemaBinnen (3,4)

TIL 8j
10000001
10101001
10010101
10000001
10111101
10110001
10111101
10000001
NAME 04_CinemaBinnen (4,4)

TIL 8k
00000000
00100000
00010000
00111000
00101000
00111000
00111000
00000000
NAME 04_CinemaBinnen (5,4)
WAL true

TIL 8l
11111111
11111111
11000011
11011011
11000011
11100111
11000011
11111111
NAME 04_CinemaBinnen (6,4)
WAL true

TIL 8m
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000000
NAME 04_CinemaBinnen (2,5)

TIL 8n
11111111
11100011
11100011
11000001
11000010
11000011
11101011
11101011
NAME 04_CinemaBinnen (4,5)

TIL 8o
10111111
10111111
10000001
10111101
10111101
10000001
10111101
11111111
NAME 04_CinemaBinnen (8,5)
WAL true

TIL 8p
00000000
01111110
01101010
01010110
01001010
01100110
01100110
01100110
NAME 04_CinemaBinnen (9,5)
WAL true

TIL 8q
11111101
11111101
10000001
10111101
10111101
10000001
10111101
11111111
NAME 04_CinemaBinnen (10,5)
WAL true

TIL 8r
11111111
10000001
10101001
10101001
10010101
10101001
10000001
11111111
NAME 04_CinemaBinnen (2,6)

TIL 8s
01111110
01111110
01111110
01111110
01111110
00000000
10111101
11111111
NAME 04_CinemaBinnen (9,6)
WAL true

TIL 8t
11111111
11111101
10000001
10111101
10111101
10000001
10111101
11111111
NAME 04_CinemaBinnen (10,6)
WAL true

TIL 8u
00000000
00000000
00000000
00000000
00000000
00000000
11111101
00000001
NAME 04_CinemaBinnen (5,7)
WAL true

TIL 8v
11111111
10111111
10111111
10000001
10111101
10111101
10000001
10111101
NAME 04_CinemaBinnen (10,8)
WAL true

TIL 8w
00000000
10101010
10101110
10101010
10101110
10101010
10101010
00000000
NAME 04_CinemaBinnen (2,10)

TIL 8x
00000000
01111110
01111110
01111110
01111110
01111110
01111110
01111110
NAME 04_CinemaBinnen (6,11)
WAL true

TIL 8y
00000000
11111111
11111111
11111111
11111111
11111111
11111111
11111101
NAME 05_CinemaAchter (2,0)

TIL 8z
00000000
11111111
11111111
11110111
11110111
11110111
11110111
11111111
NAME 05_CinemaAchter (5,0)

TIL 9a
11111111
11111111
11111111
11111111
11111111
11111111
11111011
11111111
NAME 05_CinemaAchter (10,2)

TIL 9b
11111111
11111111
11111111
11111111
11111111
11111111
11111000
11111111
NAME 05_CinemaAchter (12,2)

TIL 9c
11011111
11011111
11011111
11011111
11011111
11011111
00000001
11011111
NAME 05_CinemaAchter (13,2)

TIL 9d
01110111
01110111
01110111
01111111
01111111
01111111
01111111
01111111
NAME 05_CinemaAchter (0,3)

TIL 9e
11111000
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 05_CinemaAchter (1,3)

TIL 9f
00001111
10111111
10111111
10111111
10111111
10111111
10111111
10111111
NAME 05_CinemaAchter (2,3)

TIL 9g
11111111
11110111
11111111
11111111
11111111
11111111
10111111
11111111
NAME 05_CinemaAchter (3,3)

TIL 9h
11111111
11111100
11111111
11111111
11111111
11111111
11111111
11111111
NAME 05_CinemaAchter (8,3)

TIL 9i
01111111
00111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME 05_CinemaAchter (9,3)

TIL 9j
11011111
11011111
11011111
11011111
11011111
11011111
11011111
11011111
NAME 05_CinemaAchter (13,3)

TIL 9k
10111110
00111110
00111110
10111110
10111110
11111110
11111110
11111110
NAME 05_CinemaAchter (15,3)

TIL 9l
01111111
01111111
01111111
00011111
00000011
00000000
00000000
00000000
NAME 05_CinemaAchter (0,4)

TIL 9m
10111111
10111111
10111111
10111111
10111111
10111111
11111111
11111111
NAME 05_CinemaAchter (2,4)

TIL 9n
11111111
11110111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 05_CinemaAchter (4,4)

TIL 9o
11111111
11111111
11111111
11111111
11111111
11111110
11111110
11111110
NAME 05_CinemaAchter (8,4)

TIL 9p
11011111
11011111
11011111
11011111
11011111
11111111
11111111
11111111
NAME 05_CinemaAchter (13,4)

TIL 9q
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10111111
NAME 05_CinemaAchter (14,4)

TIL 9s
00001111
00000111
00000011
00000001
00000001
00000000
00000000
00000000
NAME 05_CinemaAchter (1,5)

TIL 9t
11111111
11111111
11111111
11110111
11111111
11111111
11111111
01111111
NAME 05_CinemaAchter (2,5)

TIL 9u
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111110
NAME 05_CinemaAchter (3,5)
WAL true

TIL 9v
10111111
11111111
11111111
11111111
11111111
11111111
11111101
11111101
NAME 05_CinemaAchter (6,5)

TIL 9w
11111110
11111110
11111110
11111110
11111110
11111110
11110000
11111110
NAME 05_CinemaAchter (8,5)

TIL 9x
11111111
11111111
11111111
11111111
11111111
11111111
00111111
11111111
NAME 05_CinemaAchter (9,5)

TIL 9y
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111101
NAME 05_CinemaAchter (12,5)

TIL 9z
01111111
01111111
00111111
00111111
00111111
00111111
00000000
00000000
NAME 05_CinemaAchter (2,6)

TIL a0
11111111
10111111
11111111
11111111
11111111
11111111
00000000
00000000
NAME 05_CinemaAchter (3,6)

TIL a1
11111111
11111111
11111111
00111111
00111111
11111111
11111111
11111111
NAME 05_CinemaAchter (5,6)

TIL a2
11111101
11111101
11111101
11111101
11111101
11110000
11111101
11111101
NAME 05_CinemaAchter (6,6)

TIL a3
11111111
11111111
11111111
11111111
11111111
00111111
11111111
11111111
NAME 05_CinemaAchter (7,6)

TIL a4
11111110
10111110
11111110
11111110
11111110
11111110
11111110
11111110
NAME 05_CinemaAchter (15,6)

TIL a5
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00011111
NAME 05_CinemaAchter (5,7)

TIL a6
11111101
11111101
11111101
11111101
11111101
11111101
11111101
11111101
NAME 05_CinemaAchter (6,7)

TIL a7
01111111
01111111
01111111
11111111
11111111
11111111
11111111
11111111
NAME 05_CinemaAchter (14,7)

TIL a8
11111110
11111110
11111110
11111110
11111110
11111110
10111110
11111110
NAME 05_CinemaAchter (15,7)

TIL a9
00011111
00011111
00011111
00011111
00011111
00011111
00011111
00011111
NAME 05_CinemaAchter (5,8)

TIL aa
11111111
11111111
11111111
11111111
11111111
10111111
11111111
11111111
NAME 05_CinemaAchter (11,8)

TIL ab
00011111
00011111
00011111
00011111
00011111
00011111
00011111
11111111
NAME 05_CinemaAchter (5,9)

TIL ac
10011111
10011111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 05_CinemaAchter (7,9)

TIL ad
11111111
11111111
11111111
11101111
11101111
11111111
11111111
11111111
NAME 05_CinemaAchter (8,9)

TIL ae
11111111
11111111
11111111
11111111
11111111
11111111
11111101
11101111
NAME 05_CinemaAchter (11,9)

TIL af
11111111
11111111
11111111
11111111
11111111
11111111
11111100
11111100
NAME 05_CinemaAchter (8,10)

TIL ag
11111111
11111011
11111111
11111111
11111111
11111111
11111111
11111111
NAME 05_CinemaAchter (10,10)
WAL true

TIL ah
11101111
11101111
11101111
11101111
11101111
11101111
11101111
10001111
NAME 05_CinemaAchter (11,10)

TIL ai
11111110
11111110
11111010
11111110
11111110
11111110
11111110
11111110
NAME 05_CinemaAchter (15,10)

TIL aj
11111101
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 05_CinemaAchter (9,11)
WAL true

TIL ak
11101111
11101111
11101111
11101111
11101111
11101111
11101111
11101111
NAME 05_CinemaAchter (11,11)
WAL true

TIL al
11111111
11111111
11111111
11111111
11111111
11111111
11111110
11111111
NAME 05_CinemaAchter (9,12)

TIL am
11110011
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 05_CinemaAchter (12,12)

TIL an
00000000
01101110
00100110
01111011
00000000
00000000
00000000
00000000
NAME 05_CinemaAchter (0,13)

TIL ao
00000000
11001111
00111011
01101111
00000000
00000000
00000000
00000000
NAME 05_CinemaAchter (1,13)

TIL ap
00000000
11110111
01111101
11101110
00000000
00000000
00000000
00000000
NAME 05_CinemaAchter (2,13)

TIL aq
00000000
10011101
11110010
11001111
00000000
00000000
00000000
00000000
NAME 05_CinemaAchter (3,13)

TIL ar
00000000
10101011
11110111
00110110
00000000
00000000
00000000
00000000
NAME 05_CinemaAchter (4,13)
WAL true

TIL as
00000000
11011010
01010110
11101110
00000000
00000000
00000000
00000000
NAME 05_CinemaAchter (5,13)
WAL true

TIL at
00000000
11011111
01011111
11011111
00000000
00000000
00000000
00000000
NAME 05_CinemaAchter (6,13)
WAL true

TIL au
00000000
11111111
00111111
11111111
00000000
00000000
00000000
00000000
NAME 05_CinemaAchter (7,13)
WAL true

TIL av
00000000
11111011
00111001
11111011
00000000
00000000
00000000
00000000
NAME 05_CinemaAchter (14,13)
WAL true

TIL aw
00000000
10101010
00111110
11101100
00000000
00000000
00000000
00000000
NAME 05_CinemaAchter (15,13)
WAL true

TIL 9r
00000000
01111111
01111111
01111111
01111011
01111011
01100011
01100011
NAME 05_Jacobiberg (0,0)

TIL ax
00000000
11111111
11111111
11111111
11111111
11111101
11111111
11111111
NAME 05_Jacobiberg (4,0)

TIL ay
00000000
11111111
11111111
11111111
11111011
11111111
11111111
11111111
NAME 05_Jacobiberg (7,0)

TIL az
00000000
11111111
11111111
11101111
11111111
11111111
11111111
11111111
NAME 05_Jacobiberg (10,0)

TIL b0
01110011
01111011
01111111
01111111
01111111
01111111
01101111
01101111
NAME 05_Jacobiberg (0,1)

TIL b1
11110001
11011111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 05_Jacobiberg (2,1)

TIL b2
11111111
11111111
10011111
11111111
11111111
11111111
11111111
11111111
NAME 05_Jacobiberg (6,1)

TIL b3
11111111
11110111
11110111
11110111
11110111
11110111
11110111
11110111
NAME 05_Jacobiberg (9,1)

TIL b4
11111111
11111111
11111111
11111111
11111111
10011111
11011111
11011111
NAME 05_Jacobiberg (11,1)

TIL b5
11111111
11111111
11110011
11110011
11111111
11111111
11111111
11111111
NAME 05_Jacobiberg (12,1)

TIL b6
11111111
11111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME 05_Jacobiberg (13,1)

TIL b7
11111111
11111111
11111111
11111111
11111111
11111000
11100000
11000000
NAME 05_Jacobiberg (1,2)

TIL b8
11111111
11111111
11111111
11111111
00000011
00000000
00000000
00000000
NAME 05_Jacobiberg (2,2)

TIL b9
00011111
11111111
11111111
11111111
11111111
01111111
00011111
00001111
NAME 05_Jacobiberg (3,2)

TIL ba
11111111
11100011
11111111
11111111
11111111
11111111
11111111
11111111
NAME 05_Jacobiberg (5,2)

TIL bb
11011111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 05_Jacobiberg (7,2)

TIL bc
11111111
11111111
11111111
11111111
11111111
11101111
11111111
11111111
NAME 05_Jacobiberg (14,2)

TIL bd
01111111
01111110
01111110
01111100
01111000
01111000
01110000
01110000
NAME 05_Jacobiberg (0,3)

TIL be
00000000
00000000
00000000
00000000
00000000
00000000
00000010
00000010
NAME 05_Jacobiberg (1,3)

TIL bf
00000011
00000001
00000001
00000000
00000000
00000000
00000000
00000000
NAME 05_Jacobiberg (3,3)

TIL bg
11111111
11111111
11111111
11111111
01111111
01111111
00111111
00111111
NAME 05_Jacobiberg (4,3)

TIL bh
11111111
11111111
10111111
10111111
10111111
10111111
10111111
10111111
NAME 05_Jacobiberg (7,3)

TIL bi
01110000
01100000
01100000
01100000
01100000
01100000
01100000
01110000
NAME 05_Jacobiberg (0,4)

TIL bj
00000010
00000010
00000010
00000000
00000000
00000000
00000000
00000000
NAME 05_Jacobiberg (1,4)

TIL bl
00111111
00011111
00011111
00011111
00011111
00011111
00011111
00111111
NAME 05_Jacobiberg (4,4)

TIL bm
11111111
11111111
11111110
01111111
01111111
11111111
11111111
11111111
NAME 05_Jacobiberg (6,4)

TIL bn
10111111
10111111
00001111
10111111
10111111
10111111
10111111
10111111
NAME 05_Jacobiberg (7,4)

TIL bo
11111111
11111110
11111111
11111111
11111111
11111111
11111111
11011111
NAME 05_Jacobiberg (11,4)

TIL bp
11101110
11111110
11111110
11111110
11111110
11111110
11111110
11111110
NAME 05_Jacobiberg (15,4)

TIL bq
01110000
01110000
01111000
01111000
01111100
01111110
01111110
01111111
NAME 05_Jacobiberg (0,5)

TIL br
00000000
00000000
00000000
00000001
00000000
00000000
00000000
00000000
NAME 05_Jacobiberg (1,5)

TIL bs
00000000
00000000
00000000
11111110
00000000
00000000
00000000
00000000
NAME 05_Jacobiberg (2,5)

TIL bt
00000000
00000000
00000000
00000000
00000000
00000001
00000001
00000011
NAME 05_Jacobiberg (3,5)

TIL bu
00111111
00111111
01111111
01111111
11111111
11111111
11111111
11111111
NAME 05_Jacobiberg (4,5)

TIL bv
10111111
10111111
10111111
10111111
11111111
11111111
11111111
11111111
NAME 05_Jacobiberg (7,5)

TIL bw
11111111
11111111
11111111
11111111
11111111
11111101
11111101
11111101
NAME 05_Jacobiberg (9,5)

TIL bx
11111111
11011011
11111111
11111111
11111111
11111111
11111111
11111111
NAME 05_Jacobiberg (14,5)

TIL by
11000000
11100000
11111000
11111111
11111111
11111111
11111111
11111111
NAME 05_Jacobiberg (1,6)

TIL bz
00000000
00000000
00000000
00000011
11111111
11111111
11111111
11111111
NAME 05_Jacobiberg (2,6)

TIL c0
00001111
00011111
01111111
11111111
11111111
11111111
11111111
11111111
NAME 05_Jacobiberg (3,6)

TIL c1
11111111
11111111
11111111
11111111
10111111
11111111
11111111
11111111
NAME 05_Jacobiberg (11,6)

TIL c2
11101111
11101111
11111111
11111111
11111111
11111111
11111111
11110101
NAME 05_Jacobiberg (12,6)

TIL c3
11111111
11111111
11111111
11111111
10011111
11111111
11111111
11111111
NAME 05_Jacobiberg (4,7)

TIL c4
11110101
11110101
11100101
11100100
11100100
11100100
10100100
10100100
NAME 05_Jacobiberg (12,7)

TIL c5
11111110
11111110
11111110
11111110
11111110
01111110
11111110
11111110
NAME 05_Jacobiberg (15,7)

TIL c6
10111111
10111111
10111111
11111111
11111111
11111111
11111111
11111111
NAME 05_Jacobiberg (10,8)

TIL c7
11111111
11111111
11111110
11111110
11111110
11111111
11111101
11111101
NAME 05_Jacobiberg (11,8)

TIL c8
00100100
10100101
10110101
10010101
11010101
01010101
01010101
11110101
NAME 05_Jacobiberg (12,8)

TIL c9
10111111
10111111
00101111
01101111
01001111
01011111
11010111
10111111
NAME 05_Jacobiberg (13,8)

TIL ca
01111111
01111111
01111111
01111111
01111111
01110111
01111111
01111111
NAME 05_Jacobiberg (0,9)

TIL cb
11111111
11111111
11111111
11111111
11111101
11111101
11111111
11111111
NAME 05_Jacobiberg (2,9)
WAL true

TIL cc
11100110
11110011
11011011
11101011
10011101
11100011
00001111
11111010
NAME 05_Jacobiberg (11,9)

TIL cd
10110101
00110101
11111111
11000011
10101100
01011011
00010001
01100000
NAME 05_Jacobiberg (12,9)

TIL ce
10101000
10110111
01101100
11011011
01110111
00011000
00101111
10111000
NAME 05_Jacobiberg (13,9)

TIL cf
11111111
11111111
01111111
11111111
00111101
11111111
10011111
11111111
NAME 05_Jacobiberg (14,9)

TIL cg
11111111
11111111
11111000
11111111
11111111
11111111
11111111
11111111
NAME 05_Jacobiberg (5,10)

TIL ch
01111111
01111111
00000111
01111111
01111111
01111111
01111111
11111111
NAME 05_Jacobiberg (6,10)

TIL ci
11111100
11111101
11111101
11111100
11111110
11111110
11111110
11111110
NAME 05_Jacobiberg (9,10)

TIL cj
00000000
11111111
11111111
10000000
11011110
10000000
10001111
10001000
NAME 05_Jacobiberg (10,10)

TIL ck
00000000
11111111
11111111
00000000
00000110
00000000
11111111
00000000
NAME 05_Jacobiberg (11,10)

TIL cl
00000000
11111111
11111111
11100000
00000000
00000000
11111111
00000000
NAME 05_Jacobiberg (12,10)

TIL cm
00000000
11111111
11111111
00000000
00011111
00000000
11001111
01001000
NAME 05_Jacobiberg (13,10)

TIL cn
00000000
11111111
11111111
00000000
00000000
00000000
11111111
00000000
NAME 05_Jacobiberg (14,10)

TIL co
00000000
11111110
11111110
00000000
00011110
00000000
11111110
00000000
NAME 05_Jacobiberg (15,10)

TIL cp
10111010
10001010
10001000
10001111
10001111
11100000
10001111
10001000
NAME 05_Jacobiberg (10,11)

TIL cq
00000000
00000000
00000000
11111111
11111111
00000000
11111111
00000000
NAME 05_Jacobiberg (11,11)

TIL cr
01001010
01001010
01001000
11001111
11001111
00000000
11001111
01001000
NAME 05_Jacobiberg (13,11)

TIL cs
00000000
00000000
00000000
11111110
11111110
00000000
11111110
00000000
NAME 05_Jacobiberg (15,11)

TIL ct
01111101
01111101
01111101
01111111
01111111
01111111
01111111
01111111
NAME 05_Jacobiberg (0,12)

TIL cu
10001010
10001010
00001000
00101111
00001111
01110000
00000001
01111000
NAME 05_Jacobiberg (10,12)
WAL true

TIL cv
00000000
00000000
00000000
11111111
11111111
00000000
11001100
00000000
NAME 05_Jacobiberg (11,12)

TIL cw
00000000
00000000
00000000
11111111
11111111
00000000
00000100
00000000
NAME 05_Jacobiberg (12,12)

TIL cx
01001010
01001010
01001000
11001111
11001111
00000000
00001111
00100000
NAME 05_Jacobiberg (13,12)

TIL cy
00000000
00000000
00000000
11111111
11111111
00000000
00000000
00000000
NAME 05_Jacobiberg (14,12)

TIL cz
00000000
00000000
00000000
11111110
11111110
00000000
00000000
11100000
NAME 05_Jacobiberg (15,12)

TIL d0
00000000
01111111
01111100
01111111
00000000
00000000
00000000
00000000
NAME 05_Jacobiberg (0,13)
WAL true

TIL d1
00000000
11111010
11111000
11111010
00000000
00000000
00000000
00000000
NAME 05_Jacobiberg (8,13)
WAL true

TIL d2
00000000
11011111
01010000
11110011
00000000
00000000
00000000
00000000
NAME 05_Jacobiberg (9,13)
WAL true

TIL d3
00000000
10101101
01001100
11111011
00000000
00000000
00000000
00000000
NAME 05_Jacobiberg (10,13)
WAL true

TIL d4
00000000
11110111
10111100
11110111
00000000
00000000
00000000
00000000
NAME 05_Jacobiberg (11,13)

TIL d5
00000000
01110110
11101011
11011101
00000000
00000000
00000000
00000000
NAME 05_Jacobiberg (12,13)

TIL d6
00000000
11111011
00011100
11100111
00000000
00000000
00000000
00000000
NAME 05_Jacobiberg (13,13)

TIL d7
00000000
11001101
01011011
10111010
00000000
00000000
00000000
00000000
NAME 05_Jacobiberg (14,13)

TIL d8
00000000
11100110
11000110
11011100
00000000
00000000
00000000
00000000
NAME 05_Jacobiberg (15,13)

TIL d9
00000000
11111110
11111110
11111110
00000000
11111110
11111110
11111110
NAME 07_Knokpoeg (2,4)
WAL true

TIL da
00000000
11111111
11111111
11111111
00000000
11111111
00000000
01111111
NAME 07_Knokpoeg (3,4)
WAL true

TIL db
00000000
01111111
01111111
01111111
00000000
11111111
00000000
01111111
NAME 07_Knokpoeg (4,4)
WAL true

TIL dc
00000000
01111110
01111110
01111110
00000000
11111110
00000000
01111110
NAME 07_Knokpoeg (5,4)
WAL true

TIL dd
00101010
01101010
00101110
00101010
00101110
01101010
00101010
00000000
NAME 07_Knokpoeg (10,4)

TIL de
11110000
11110000
11110110
11110000
11110110
11110000
11110000
11110000
NAME 07_Knokpoeg (13,4)
WAL true

TIL df
11111110
11111110
11111110
11111110
00000000
11111110
00000000
10111101
NAME 07_Knokpoeg (2,5)
WAL true

TIL dg
11111111
11111111
11111111
11000011
11011011
11000011
11100111
11000011
NAME 07_Knokpoeg (3,5)
WAL true

TIL dh
11110000
11110110
11110000
11110110
11110000
11110000
11111111
11111111
NAME 07_Knokpoeg (13,5)
WAL true

TIL di
11111111
11111111
11111111
11111111
11111000
11110000
11100000
10000100
NAME 07_Knokpoeg (5,6)

TIL dj
11111111
11111111
11111111
11111111
01111111
00111111
00111111
00111111
NAME 07_Knokpoeg (6,6)

TIL dk
11111111
11111111
11111111
10111101
10000001
10111101
10000001
10111101
NAME 07_Knokpoeg (9,6)
WAL true

TIL dl
00000000
00111110
00111110
00100010
00101010
00101010
01000010
01111110
NAME 07_Knokpoeg (12,6)
WAL true

TIL dm
11111100
11111100
11111100
11111100
11111100
11111000
11110000
11110000
NAME 07_Knokpoeg (5,7)

TIL dn
00111111
01111111
01111111
01111111
11111111
11111111
11111111
11111111
NAME 07_Knokpoeg (6,7)

TIL do
00000000
01111111
01111111
01111111
01111111
01111111
00000000
10111111
NAME 07_Knokpoeg (9,7)
WAL true

TIL dp
00000000
11111111
11111111
11111111
11111111
11111111
00000000
11111111
NAME 07_Knokpoeg (10,7)
WAL true

TIL dq
00000000
11111111
11111111
11111111
11111111
11111111
00000000
11111101
NAME 07_Knokpoeg (11,7)
WAL true

TIL dr
01000010
01000010
01000010
01000010
01011010
01000010
01000010
01000010
NAME 07_Knokpoeg (12,7)
WAL true

TIL ds
11100000
11000000
11000000
11000000
11000000
11000000
11110000
11111000
NAME 07_Knokpoeg (5,8)

TIL dt
00111111
00000111
00000011
00000001
00000000
00000001
00011100
00000000
NAME 07_Knokpoeg (6,8)

TIL du
11111111
11111111
11111111
11111011
11000011
00000111
00000111
00000111
NAME 07_Knokpoeg (7,8)

TIL dv
01111110
00000000
00111100
00101100
00111100
00000000
10111101
10000001
NAME 07_Knokpoeg (12,8)
WAL true

TIL dw
10000001
10111101
10111101
10000001
10111101
10111101
10000001
10111101
NAME 07_Knokpoeg (2,9)
WAL true

TIL dx
11111100
11111110
11111110
11111110
11111110
11110000
11100001
11111110
NAME 07_Knokpoeg (5,9)

TIL dy
00000000
00000000
11000000
11100111
11110111
00110111
11100111
00000111
NAME 07_Knokpoeg (6,9)

TIL dz
10111100
10111101
10111101
10111101
10000001
10111100
10111101
10111101
NAME 07_Knokpoeg (2,10)
WAL true

TIL e0
00000000
10000010
10100010
10000010
10000010
00000000
11111101
11111101
NAME 07_Knokpoeg (3,10)
WAL true

TIL e1
11111111
11111111
11101111
11111111
11111011
10111011
11010011
11010101
NAME 07_Knokpoeg (10,10)

TIL e2
11111111
11111111
11111111
11111111
11011111
11111111
11111111
10111111
NAME 07_Knokpoeg (11,10)

TIL e3
11111000
11111011
11111000
11111010
11111001
11111000
11111011
11111000
NAME 07_Knokpoeg (13,10)
WAL true

TIL e4
10111101
10111101
10111101
10111101
10000001
10111101
11111111
11111111
NAME 07_Knokpoeg (2,11)
WAL true

TIL e5
11110101
10111110
11111111
11110000
11111101
11111110
11011001
11111110
NAME 07_Knokpoeg (9,11)

TIL e6
01111111
11001111
11111111
00011111
11111111
10010111
10111111
01111011
NAME 07_Knokpoeg (11,11)

TIL bk
00000000
00000000
00000000
00000000
00000001
00000011
00000011
00000011
NAME 08_Gat (1,1)

TIL e7
00000011
00111111
01111111
11111111
11111111
11111111
11111111
11111111
NAME 08_Gat (2,1)

TIL e8
11000000
11111100
11111110
11111111
11111111
11111111
11111111
11111111
NAME 08_Gat (3,1)

TIL e9
00000000
00000000
00000000
00000000
10000000
11000000
11100000
11100000
NAME 08_Gat (4,1)

TIL eb
00000000
00000000
00000000
00000000
00000000
00000000
11100000
11110000
NAME 08_Gat (9,1)

TIL ec
00001111
00111111
01111111
11110110
11110110
11111111
11111111
11111111
NAME 08_Gat (13,1)

TIL ed
00000000
11000000
11100000
11110000
11110000
11110000
11110000
11110000
NAME 08_Gat (14,1)

TIL ee
00000111
00000111
00001111
00001111
00001111
00001111
00000111
00000111
NAME 08_Gat (1,2)

TIL ef
11110111
11110111
11110111
11111111
11111111
11111111
11111111
11111111
NAME 08_Gat (2,2)

TIL eg
11011111
11011111
11011111
11111111
11111111
11111111
11111111
11111111
NAME 08_Gat (3,2)

TIL eh
11100000
11100000
11110000
11110000
11110000
11110000
11100000
11100000
NAME 08_Gat (4,2)

TIL ei
00000001
00000001
00000001
00000000
00000000
00000000
00000000
00000000
NAME 08_Gat (8,2)

TIL ej
11110000
11110000
10110000
11100000
00000000
00000000
00000000
00000000
NAME 08_Gat (9,2)

TIL ek
01111111
00111111
00001111
00000000
00000000
00000000
00000000
00000000
NAME 08_Gat (13,2)

TIL el
11100000
11000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 08_Gat (14,2)

TIL em
00000111
00000011
00000011
00000001
00000000
00000000
00000000
00000000
NAME 08_Gat (1,3)

TIL en
11111111
11111000
11111111
11111111
11111111
01111111
00111111
00000011
NAME 08_Gat (2,3)

TIL eo
11111111
00011111
11111111
11111111
11111111
11111110
11111100
11000000
NAME 08_Gat (3,3)

TIL ep
11100000
11100000
11000000
10000000
00000000
00000000
00000000
00000000
NAME 08_Gat (4,3)

TIL eq
00000000
00000000
00000000
00000000
00000001
00000111
00000111
00001111
NAME 08_Gat (10,3)

TIL er
00000000
00000000
00000000
11111100
11111111
11111111
11111111
11111111
NAME 08_Gat (11,3)

TIL es
00000000
00000000
00000000
00000000
00000000
10000000
11000000
11000000
NAME 08_Gat (12,3)

TIL et
00001111
00011111
00011111
00011111
00001111
00001111
00001111
00000111
NAME 08_Gat (10,4)

TIL eu
11111111
11111111
11111111
11111111
11111111
11111111
10000111
11111111
NAME 08_Gat (11,4)

TIL ev
11100000
11100000
11100000
11100000
11100000
11100000
11000000
10000000
NAME 08_Gat (12,4)

TIL ew
00000000
00000011
00001111
00011111
01111111
11111111
11111111
11111111
NAME 08_Gat (4,5)

TIL ex
01111110
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 08_Gat (5,5)

TIL ey
00000000
11000000
11110000
11111000
11111110
11111111
11111111
11111111
NAME 08_Gat (6,5)

TIL ez
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000000
NAME 08_Gat (7,5)

TIL f0
00000011
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME 08_Gat (10,5)

TIL f1
11111111
11111110
00111000
00000000
00000000
00000000
00000000
00000000
NAME 08_Gat (11,5)

TIL f2
10000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 08_Gat (12,5)

TIL f3
00000011
00000011
00000111
00000111
00000111
00001111
00001111
00001111
NAME 08_Gat (3,6)

TIL f4
11111111
11111111
11111110
11111110
11111110
11111110
11111110
11111111
NAME 08_Gat (4,6)

TIL f5
11000000
11000000
11100000
11100000
11100000
11110000
11110000
11110000
NAME 08_Gat (7,6)

TIL f6
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111111
NAME 08_Gat (12,6)

TIL f7
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11110000
NAME 08_Gat (13,6)

TIL f8
00001111
00001111
00001111
00000111
00000111
00000111
00000011
00000011
NAME 08_Gat (3,7)

TIL f9
11110000
11110000
11110000
11100000
11100000
11100000
11000000
11000000
NAME 08_Gat (7,7)

TIL fa
00000000
00000000
00000000
00000011
00000011
00001111
00001111
11111111
NAME 08_Gat (10,7)

TIL fb
00000000
00111111
00111111
11111111
11111111
11111111
11111111
11111111
NAME 08_Gat (11,7)

TIL fc
11110000
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 08_Gat (13,7)

TIL fd
00000000
11000000
11000000
11111100
11111100
11111111
11111111
11111111
NAME 08_Gat (14,7)

TIL fe
00000010
00000010
00000010
00000010
00000010
00000010
00000010
11110010
NAME 08_Gat (15,7)

TIL ff
00000001
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 08_Gat (3,8)

TIL fg
11111111
11111111
11111111
01111111
00011111
00001111
00000011
00000000
NAME 08_Gat (4,8)

TIL fh
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01111110
NAME 08_Gat (5,8)

TIL fi
11111111
11111111
11111111
11111110
11111000
11110000
11000000
00000000
NAME 08_Gat (6,8)

TIL fj
00000000
00000011
00000011
00000011
00000011
00001111
00001111
00111111
NAME 08_Gat (9,8)

TIL fk
11110010
11111110
11111110
11111110
11111110
11111111
11111111
11111111
NAME 08_Gat (15,8)

TIL fl
00111111
00111111
00111111
11111111
11111111
11111111
11111111
11111111
NAME 08_Gat (9,9)

TIL fm
11111111
11111111
11111111
11110011
11110011
11110011
11110011
11110011
NAME 08_Gat (11,9)

TIL fn
00000000
00000011
00000011
00000011
00000011
00000011
00000011
00000011
NAME 08_Gat (8,10)

TIL fo
11110011
11110011
11110011
11110011
11110011
11111111
11111111
11111111
NAME 08_Gat (11,10)

TIL fp
01010000
01000100
01001000
01000011
01001000
01011100
01101100
01111001
NAME 08_Gat (0,11)
WAL true

TIL fq
01000000
00000000
00001000
01000000
01000000
00001100
00010000
10000000
NAME 08_Gat (1,11)

TIL fr
00000011
00000011
00000011
00000011
00000011
00000000
00000000
00000000
NAME 08_Gat (8,11)
WAL true

TIL fs
11111111
11111111
11111111
11111111
11111111
11111111
11111110
11111100
NAME 08_Gat (11,11)
WAL true

TIL ft
11111111
11111111
11111111
11100000
10000000
00000000
00000000
00000000
NAME 08_Gat (12,11)
WAL true

TIL fu
11111111
11111111
11111111
01111111
00011111
00001111
00000111
00000011
NAME 08_Gat (13,11)
WAL true

TIL fv
00011100
10000000
11000000
10000000
11100000
10011000
10000000
10111000
NAME 08_Gat (1,12)

TIL fw
11111111
11111111
11111111
00111111
00111111
00111111
00111111
00001111
NAME 08_Gat (9,12)

TIL fx
11111000
11111000
11110000
11110000
11110000
11110000
11110000
11110000
NAME 08_Gat (11,12)

TIL fy
00000000
00000000
00001100
00011110
00111111
00111111
00011110
00001100
NAME 08_Gat (12,12)

TIL fz
00000001
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME 08_Gat (13,12)
WAL true

TIL g0
01111111
01000000
01000000
01000000
01000000
01000000
01000000
01000000
NAME 08_Gat (0,13)
WAL true

TIL g1
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 08_Gat (1,13)
WAL true

TIL g2
11110000
00000011
00000011
00000011
00000011
00000000
00000000
00000000
NAME 08_Gat (9,13)
WAL true

TIL g3
00000000
11111111
11111111
11111111
11111111
11111111
11111111
00001111
NAME 08_Gat (10,13)
WAL true

TIL g4
00000000
11111000
11111100
11111110
11111111
11111111
11111111
11111111
NAME 08_Gat (11,13)
WAL true

TIL g5
00000000
00000000
00000000
00000000
00000000
10000000
11100000
11111111
NAME 08_Gat (12,13)
WAL true

TIL g6
00000001
00000001
00000011
00000111
00001111
00011111
01111111
11111111
NAME 08_Gat (13,13)
WAL true

TIL g7
11111111
11111110
11111110
11111110
11111110
11110010
11110010
00000010
NAME 08_Gat (15,13)

TIL g8
00001111
00000011
00000011
00000000
00000000
00000000
00000000
00000000
NAME 08_Gat (10,14)

TIL g9
11111111
11111111
11111111
00111111
00111111
00000000
00000000
00000000
NAME 08_Gat (11,14)

TIL ga
11111111
11111111
11111111
11111111
11111111
11110000
11110000
00000000
NAME 08_Gat (13,14)

TIL gb
11111111
11111100
11111100
11000000
11000000
00000000
00000000
00000000
NAME 08_Gat (14,14)

TIL ea
00000000
11111111
00000000
00000000
00000000
00000000
00000000
00100000
NAME 09_GatBuiten (1,0)

TIL gc
00000000
11111111
00000000
00000000
00100000
00100000
00000000
00000000
NAME 09_GatBuiten (2,0)

TIL gd
00000000
11111111
00000000
00000000
01000000
00000000
00000000
00000000
NAME 09_GatBuiten (3,0)

TIL ge
00000000
11111111
00000000
00000001
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (4,0)

TIL gf
00000000
11111111
00000000
00000000
00000000
00000000
00000001
00000000
NAME 09_GatBuiten (7,0)

TIL gg
00000000
11111111
00000000
00000000
00000001
00000001
00000001
00000001
NAME 09_GatBuiten (12,0)

TIL gh
00000000
11111111
00000000
00000000
00000000
00000000
01000000
11000000
NAME 09_GatBuiten (14,0)

TIL gi
01000000
01000000
01000000
01000000
01000001
01000001
01000001
01000001
NAME 09_GatBuiten (0,1)

TIL gk
00000000
00000000
00000000
00000000
00000000
01000000
00000000
00000000
NAME 09_GatBuiten (2,1)

TIL gl
00000000
00000000
00000000
01000000
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (4,1)

TIL gm
00000000
00000000
00010000
00000000
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (5,1)

TIL gn
00000000
00000000
10000000
10000000
10000000
10000000
10000000
11111100
NAME 09_GatBuiten (7,1)

TIL go
00000000
00000000
00000000
00000000
00000000
00000000
00000010
00000000
NAME 09_GatBuiten (8,1)

TIL gp
00000000
00000000
00000000
00000000
00000000
00100000
00000000
00000000
NAME 09_GatBuiten (11,1)

TIL gq
00000001
00000001
00000001
00000001
00000001
00000111
00000001
00000001
NAME 09_GatBuiten (12,1)

TIL gr
00000000
00000000
00000000
00000000
00000000
11000000
00000000
00000000
NAME 09_GatBuiten (13,1)

TIL gs
00000010
00000010
00000010
00010010
00000010
00000010
00000010
00000010
NAME 09_GatBuiten (15,1)

TIL gt
01000001
01000001
01000001
01000111
01000001
01000001
01000001
01000001
NAME 09_GatBuiten (0,2)

TIL gu
00000000
00000000
00000000
11000000
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (1,2)

TIL gv
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001000
NAME 09_GatBuiten (2,2)

TIL gw
00000000
00000000
00000000
00000000
00000000
00000010
00000000
00000000
NAME 09_GatBuiten (3,2)

TIL gx
10000000
10000000
10000000
10000000
10000000
10000000
00000000
00000000
NAME 09_GatBuiten (7,2)

TIL gy
00000000
00000000
00000000
00000000
00000000
00000001
00000000
00000000
NAME 09_GatBuiten (10,2)

TIL gz
00000001
00000001
00000001
00000001
00000001
00000000
00000000
00000000
NAME 09_GatBuiten (12,2)

TIL h0
00000010
00000010
00000010
00000010
00000010
00000010
10000010
00000010
NAME 09_GatBuiten (15,2)

TIL h1
01000001
01000001
01000000
01000000
01000000
01000000
01000000
01000000
NAME 09_GatBuiten (0,3)

TIL h2
00001000
00001000
00011110
00001000
00001000
00001000
00001000
00000000
NAME 09_GatBuiten (2,3)

TIL h3
00000000
00000010
00000000
00000000
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (4,3)

TIL h4
00000000
00000000
00010000
00010000
00010000
00010000
00000000
00000000
NAME 09_GatBuiten (9,3)

TIL h5
00000000
00000000
00000000
00000000
00000000
00000000
00001000
00001000
NAME 09_GatBuiten (10,3)

TIL h6
00000000
00000000
00000000
00000000
00000000
00000000
00010000
00000000
NAME 09_GatBuiten (12,3)

TIL h7
00000000
00000000
00000000
00000000
00100000
00000000
00000000
00000000
NAME 09_GatBuiten (13,3)

TIL h8
00000000
00000000
00000000
00000000
00000000
00100100
00111100
00111100
NAME 09_GatBuiten (14,3)

TIL h9
00000010
00000010
00000010
00000010
00000010
00000010
00000010
10000010
NAME 09_GatBuiten (15,3)

TIL ha
01000000
01000000
01000000
01001000
01000000
01000000
01000000
01000000
NAME 09_GatBuiten (0,4)

TIL hb
00000000
00000000
00000000
00000010
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (2,4)

TIL hc
00000000
00000000
00100000
00000000
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (4,4)

TIL hd
00010000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (5,4)

TIL he
00000000
00001000
00001000
00001000
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (6,4)

TIL hf
00000000
00000100
00000000
00000000
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (7,4)
WAL true

TIL hg
00001000
00001000
00001000
00001000
00001000
00001000
10000000
00000000
NAME 09_GatBuiten (10,4)

TIL hh
00000000
00000000
00000000
00000000
00000000
00000001
00000011
00000111
NAME 09_GatBuiten (13,4)

TIL hi
00011001
00011101
00011111
01111111
11111111
11111111
11111111
11111111
NAME 09_GatBuiten (14,4)

TIL hj
00000010
00000010
00000010
11111110
11111110
11111110
11111110
11111110
NAME 09_GatBuiten (15,4)

TIL hk
00010000
00000000
00000000
00000000
00000000
00000000
10000000
00000000
NAME 09_GatBuiten (1,5)

TIL hl
01000000
01000000
01000000
00000000
00000000
00000000
00000000
01100000
NAME 09_GatBuiten (4,5)

TIL hm
00000000
00000000
00000000
00000000
01000000
00000000
00000000
00000000
NAME 09_GatBuiten (7,5)

TIL hn
00000000
00000000
00000000
00000000
00000001
00000000
00000000
00000000
NAME 09_GatBuiten (12,5)

TIL ho
00001111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (13,5)

TIL hp
11111111
10000000
10100000
10000000
10000000
10001111
10001111
10000100
NAME 09_GatBuiten (14,5)

TIL hq
11111110
00000010
00001110
00000010
00000010
11111010
11111010
00010010
NAME 09_GatBuiten (15,5)

TIL hr
01000000
01000000
01000000
01000000
01000000
01000000
01000000
01000100
NAME 09_GatBuiten (0,6)

TIL hs
00000000
00000000
00010000
00000000
00000000
00000000
00000000
00001111
NAME 09_GatBuiten (2,6)

TIL ht
00000000
00000000
00000000
01010000
01000000
00000000
00000000
00000000
NAME 09_GatBuiten (6,6)

TIL hu
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME 09_GatBuiten (9,6)

TIL hv
00000000
00000000
00000000
00000000
00000010
00100000
00000000
00000000
NAME 09_GatBuiten (11,6)

TIL hw
00001100
00001100
00001100
00000000
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (13,6)

TIL hx
10000100
10000100
10000100
10000100
10000100
10000100
10000111
10000000
NAME 09_GatBuiten (14,6)

TIL hy
01010010
01010010
01010010
00010010
00010010
00010010
11110010
00000010
NAME 09_GatBuiten (15,6)

TIL hz
01000000
01000000
01000000
01000000
01000000
01000000
01000000
01001111
NAME 09_GatBuiten (0,7)

TIL i0
00000000
00000011
00000011
00111111
00111111
11111111
11111111
11111111
NAME 09_GatBuiten (1,7)

TIL i1
00000000
11111100
11111100
11111111
11111111
11111111
11111111
11111111
NAME 09_GatBuiten (4,7)

TIL i2
00000000
00000000
00000000
11000000
11000000
11110000
11110000
11111111
NAME 09_GatBuiten (5,7)

TIL i3
11111100
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME 09_GatBuiten (9,7)

TIL i4
10000000
10001110
10100000
10000000
10000000
10001111
10001111
10000100
NAME 09_GatBuiten (14,7)

TIL i5
01111010
00000010
01110010
00000010
00000010
11111010
11111010
00010010
NAME 09_GatBuiten (15,7)

TIL i6
01001111
01111111
01111111
01111111
01111111
11111111
11111111
11111111
NAME 09_GatBuiten (0,8)

TIL i7
00000000
11000000
11000000
11000000
11000000
11110000
11110000
11111100
NAME 09_GatBuiten (6,8)

TIL i8
00000000
00001000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (7,8)

TIL i9
10000000
10000000
10000000
10000000
10000000
00000000
00000000
00000000
NAME 09_GatBuiten (9,8)

TIL ia
00000000
00000000
00000000
00001000
00001000
00001000
00001000
00001000
NAME 09_GatBuiten (11,8)

TIL ib
10000100
10000100
10000100
10000100
10100100
10000100
10000111
10000000
NAME 09_GatBuiten (14,8)

TIL ic
01010010
01010010
00010010
00010010
00010010
00010010
11110010
00000010
NAME 09_GatBuiten (15,8)

TIL id
11111111
11111111
11111111
11001111
11001111
11001111
11001111
11001111
NAME 09_GatBuiten (2,9)

TIL ie
11111100
11111100
11111100
11111111
11111111
11111111
11111111
11111111
NAME 09_GatBuiten (6,9)

TIL if
00000000
00000000
00000000
01000000
01000000
01000000
01000000
01000000
NAME 09_GatBuiten (8,9)

TIL ig
00000000
00000000
00000001
00000000
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (9,9)

TIL ih
00111100
00001000
00001000
00001000
00001000
00001000
00001000
00001000
NAME 09_GatBuiten (11,9)

TIL ii
10000111
10000000
10100000
10000000
10000000
10001111
10001111
10000100
NAME 09_GatBuiten (14,9)

TIL ij
00000110
00000010
00110010
00011010
00000010
11111010
11111010
00010010
NAME 09_GatBuiten (15,9)

TIL ik
11001111
11001111
11001111
11001111
11001111
11111111
11111111
11111111
NAME 09_GatBuiten (2,10)

TIL il
00000000
11000000
11010000
11000000
11000000
11000000
11000000
11000000
NAME 09_GatBuiten (7,10)

TIL im
00001000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (11,10)

TIL in
10000100
10000100
11100100
10000100
10000100
10000100
10000111
10000000
NAME 09_GatBuiten (14,10)

TIL io
01010010
01010010
01010010
01010110
00010010
00010010
11110010
00000110
NAME 09_GatBuiten (15,10)

TIL ip
11111111
11111111
11111111
11111110
11111000
11110000
11100000
11000000
NAME 09_GatBuiten (2,11)
WAL true

TIL iq
11111111
11111111
11111111
00000111
00000001
00000000
00000000
00000000
NAME 09_GatBuiten (3,11)
WAL true

TIL ir
11111111
11111111
11111111
11111111
11111111
11111111
01111111
00111111
NAME 09_GatBuiten (4,11)
WAL true

TIL is
11000000
11000000
11000000
11000000
11000000
00000000
00001000
00000000
NAME 09_GatBuiten (7,11)
WAL true

TIL it
00000000
00000000
00000000
00000000
00010000
00000000
00000000
00000000
NAME 09_GatBuiten (9,11)
WAL true

TIL iu
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000100
NAME 09_GatBuiten (11,11)
WAL true

TIL iv
01100000
01100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (12,11)
WAL true

TIL iw
11100000
10000000
10001100
10000000
11100000
10001111
10001111
10000100
NAME 09_GatBuiten (14,11)

TIL ix
00000010
00000010
00000110
00000010
00000010
11111010
11111010
00010010
NAME 09_GatBuiten (15,11)
WAL true

TIL iy
10000000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (2,12)
WAL true

TIL iz
00000000
00000000
00110000
01111000
11111100
11111100
01111000
00110000
NAME 09_GatBuiten (3,12)

TIL j0
00011111
00011111
00001111
00001111
00001111
00001111
00001111
00001111
NAME 09_GatBuiten (4,12)

TIL j1
11111111
11111111
11111111
11111100
11111100
11111100
11111100
11110000
NAME 09_GatBuiten (6,12)

TIL j2
00000000
00000000
00000000
00100000
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (8,12)

TIL j3
00000000
00000000
00000000
00000000
00000000
00010000
00000000
00000000
NAME 09_GatBuiten (10,12)

TIL j4
11111111
10101010
10101010
10001010
10101010
10001010
10101010
10101010
NAME 09_GatBuiten (13,12)

TIL j5
10000100
11100100
10000100
10000100
10010100
10000100
11000111
10000000
NAME 09_GatBuiten (14,12)
WAL true

TIL j6
01010010
01010010
00011110
00010010
00010010
00010010
11110010
00000010
NAME 09_GatBuiten (15,12)

TIL j7
11111111
01111111
01111111
01111111
01111111
01001111
01001111
01000000
NAME 09_GatBuiten (0,13)

TIL j8
10000000
10000000
11000000
11100000
11110000
11111000
11111110
11111111
NAME 09_GatBuiten (2,13)
WAL true

TIL j9
00000000
00000000
00000000
00000000
00000000
00000001
00000111
11111111
NAME 09_GatBuiten (3,13)
WAL true

TIL ja
00000000
00011111
00111111
01111111
11111111
11111111
11111111
11111111
NAME 09_GatBuiten (4,13)
WAL true

TIL jb
00000000
11111111
11111111
11111111
11111111
11111111
11111111
11110000
NAME 09_GatBuiten (5,13)
WAL true

TIL jc
00000000
11111111
11111111
11111111
11000000
00000000
00000000
00000000
NAME 09_GatBuiten (6,13)
WAL true

TIL jd
00000000
00111110
01110011
01010111
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (13,13)
WAL true

TIL je
00000000
11001101
01110110
11001101
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (14,13)
WAL true

TIL jf
00000010
11011010
01101110
11110110
00000010
00000010
00000010
00000010
NAME 09_GatBuiten (15,13)

TIL jg
11111111
00111111
00111111
00000011
00000011
00000000
00000000
00000000
NAME 09_GatBuiten (1,14)

TIL jh
11111111
11111111
11111111
11111111
11111111
00001111
00001111
00000000
NAME 09_GatBuiten (2,14)

TIL ji
11111111
11111111
11111111
11111100
11111100
00000000
00000000
00000000
NAME 09_GatBuiten (4,14)

TIL jj
11110000
11000000
11000000
00000000
00000000
00000000
00000000
00000000
NAME 09_GatBuiten (5,14)

TIL gj
00000000
01111111
01111111
01111111
01111111
01111111
01011111
01011111
NAME 10_Eindfeest (0,0)

TIL jk
00000000
11111111
11100000
11100011
11000001
11000000
10000000
10000000
NAME 10_Eindfeest (2,0)

TIL jl
00000000
11111111
11111110
11111100
11111000
00001100
00011110
00111111
NAME 10_Eindfeest (3,0)

TIL jm
00000000
11111111
01110000
01110000
01110000
01110000
00000000
00000000
NAME 10_Eindfeest (4,0)

TIL jn
00000000
11111111
00011111
00001111
00001111
00000111
00001111
00111111
NAME 10_Eindfeest (6,0)

TIL jo
00000000
11111111
00011111
10011110
10001100
11000000
11000000
11100000
NAME 10_Eindfeest (7,0)

TIL jp
00000000
11111111
10000000
00000000
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (8,0)

TIL jq
00000000
11111111
00001111
00000111
00000111
00000111
00000011
00000001
NAME 10_Eindfeest (9,0)

TIL jr
00000000
11111111
11111111
11111111
11111111
11111111
11111110
11111100
NAME 10_Eindfeest (10,0)

TIL js
00000000
11111111
10000000
10000000
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (11,0)

TIL jt
00000000
11111111
00000011
00000001
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (13,0)

TIL ju
00000000
11111111
11111111
11111111
11111111
01111110
00000000
00000000
NAME 10_Eindfeest (14,0)

TIL jv
00000000
11111110
11000010
10000010
00000010
00000010
00000010
00000010
NAME 10_Eindfeest (15,0)

TIL jw
01001111
01000111
01000011
01000000
01000000
01000000
01000000
01000000
NAME 10_Eindfeest (0,1)

TIL jx
11111111
11111110
11111110
11110000
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (1,1)

TIL jy
00000000
00000000
00000000
00000110
00000110
00011010
00011100
00011100
NAME 10_Eindfeest (2,1)

TIL jz
00111111
00111111
00111111
00111111
00111111
00111111
00011110
11001100
NAME 10_Eindfeest (3,1)

TIL k1
00111111
01111111
01111111
01111111
11111111
11111111
11111111
01111111
NAME 10_Eindfeest (6,1)

TIL k2
11100000
11110000
11110000
11110000
11111000
11111000
11011000
11010000
NAME 10_Eindfeest (7,1)

TIL k3
00000000
00000000
00011000
00111000
00111100
00111000
00111000
00011000
NAME 10_Eindfeest (8,1)

TIL k4
00000000
00000000
00011000
00111000
00111100
00111100
00011110
00011110
NAME 10_Eindfeest (9,1)

TIL k5
11111000
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME 10_Eindfeest (10,1)

TIL k6
00000000
00000000
00000000
00000000
00000000
00000000
11000000
11100000
NAME 10_Eindfeest (11,1)

TIL k7
00011000
00111100
00111100
00111100
00111100
00011100
00001000
00000000
NAME 10_Eindfeest (12,1)

TIL k8
00000010
00000011
00000001
00000001
00000001
00000000
00000000
00000000
NAME 10_Eindfeest (13,1)

TIL k9
00000000
00000000
00000000
10000000
10000000
10000000
11000000
01000000
NAME 10_Eindfeest (14,1)

TIL ka
00000010
00000010
00000010
01000010
11110010
11110010
11110010
11110010
NAME 10_Eindfeest (15,1)

TIL kb
01000000
01000000
01000000
01000001
01000001
01000011
01000011
01000011
NAME 10_Eindfeest (0,2)

TIL kc
00000000
00000000
01100000
11111000
11111000
11111100
11111111
11111111
NAME 10_Eindfeest (1,2)

TIL kd
00011100
00000000
00000000
00000000
00000000
00000000
11100000
11110000
NAME 10_Eindfeest (2,2)

TIL ke
11100000
11100000
11100000
01100000
01100000
00000000
00000000
00000000
NAME 10_Eindfeest (3,2)

TIL kf
00001000
00001100
00011100
00001100
00000011
00000011
00000000
00000000
NAME 10_Eindfeest (4,2)

TIL kg
00001000
00001000
00001000
00010000
00010000
00000000
00000000
00000000
NAME 10_Eindfeest (5,2)

TIL kh
01111111
01111111
00111111
00011111
00001110
00000000
00000000
00000000
NAME 10_Eindfeest (6,2)

TIL ki
11000000
10000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (7,2)

TIL kj
00001100
00001100
00011000
00000000
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (9,2)

TIL kk
00001111
00001111
00001111
00001111
00001110
00000110
00000000
00000000
NAME 10_Eindfeest (10,2)

TIL kl
11100000
11100000
11100000
11000000
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (11,2)

TIL km
00000000
00000000
00000000
11000000
11100000
11100000
00001000
00001110
NAME 10_Eindfeest (13,2)

TIL kn
01000000
00100000
00100000
00100000
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (14,2)

TIL ko
11110010
01100010
00000010
00000010
00000010
00000010
00000010
00000010
NAME 10_Eindfeest (15,2)

TIL kp
01000011
01000111
01000011
01000011
01000011
01000011
01000001
01000000
NAME 10_Eindfeest (0,3)

TIL kq
11110000
11111000
11111000
11111000
11111000
11111000
11111000
11111000
NAME 10_Eindfeest (2,3)

TIL kr
00000000
00000000
00011000
00110000
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (3,3)

TIL ks
00000000
00001000
00001000
00000100
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (5,3)

TIL kt
00000000
00000111
00000111
00000111
00000111
00000111
00000111
00000011
NAME 10_Eindfeest (10,3)

TIL ku
00110000
11100000
11000000
11000000
11000000
11000000
10000000
10000000
NAME 10_Eindfeest (11,3)

TIL kv
00000111
00000111
00000011
00000011
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (13,3)

TIL kw
00000000
10000000
10000000
10000000
10000000
00000000
00000000
00000000
NAME 10_Eindfeest (14,3)

TIL kx
01000000
01000000
01000000
01100000
01110000
01111000
01111100
01111110
NAME 10_Eindfeest (0,4)

TIL ky
00001111
00001111
00001111
00000111
00000011
00000000
00100000
01110000
NAME 10_Eindfeest (1,4)

TIL kz
11111000
11110000
11110000
11100000
11000000
00000000
00000000
00000000
NAME 10_Eindfeest (2,4)

TIL l0
00000000
00000000
00000000
00011100
00011100
00011100
00000000
00000000
NAME 10_Eindfeest (3,4)

TIL l1
00000000
00000000
00001100
00001100
00000000
00000000
11000000
01000000
NAME 10_Eindfeest (11,4)

TIL l2
00000000
00000111
00000111
00001111
00001111
00001111
00000111
00110111
NAME 10_Eindfeest (12,4)

TIL l3
00000000
00000000
10000000
10000000
10000000
10000000
10000000
00000000
NAME 10_Eindfeest (13,4)

TIL l4
00000011
00001111
00011111
00111111
00111111
01111111
01111111
01111111
NAME 10_Eindfeest (14,4)

TIL l5
11000010
11100010
11110010
11111010
11111110
11111110
11111110
11111110
NAME 10_Eindfeest (15,4)

TIL l6
01111110
01111111
01111111
01111111
01111111
01001111
01000111
01000001
NAME 10_Eindfeest (0,5)

TIL l7
00110000
00100000
10000000
10000000
11000000
11000000
11001100
10001100
NAME 10_Eindfeest (1,5)

TIL l8
01111000
01111000
01111000
01111000
00111000
00000000
00000000
00000000
NAME 10_Eindfeest (12,5)

TIL l9
01111111
11111111
11111111
11111111
11111111
01111111
01111111
01111111
NAME 10_Eindfeest (14,5)

TIL la
00000000
00000000
00000000
00000000
00000000
00000001
00000011
00000011
NAME 10_Eindfeest (1,6)

TIL lb
00000001
00001111
00011111
00111111
11111111
11111110
11111100
11110000
NAME 10_Eindfeest (2,6)

TIL lc
10000000
11000000
11000000
10000000
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (3,6)

TIL ld
01000000
01000000
01000100
01000100
01000100
01000000
01000000
01000000
NAME 10_Eindfeest (11,6)

TIL le
00000000
00000000
00000000
00000000
00000000
00000000
00111000
00111100
NAME 10_Eindfeest (12,6)

TIL lf
00000000
00000000
00000000
00000000
00000000
00000100
00000100
00000000
NAME 10_Eindfeest (13,6)

TIL lg
01111111
00111111
00111111
00011111
00011111
00001111
00000001
00000000
NAME 10_Eindfeest (14,6)

TIL lh
11111110
11111110
11111110
11111110
11111110
11111110
10011110
00001110
NAME 10_Eindfeest (15,6)

TIL li
01100000
01100000
01100000
01100000
01100000
01100000
01000000
01000000
NAME 10_Eindfeest (0,7)

TIL lj
00000011
00000011
00000000
00000000
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (1,7)

TIL lk
11100000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (2,7)

TIL ll
00111100
00111110
00111100
00111100
00011100
00000000
00000000
00000000
NAME 10_Eindfeest (12,7)

TIL lm
00000000
00000000
00000000
00000011
00000011
00000111
00000111
00000111
NAME 10_Eindfeest (13,7)

TIL ln
00000000
00000000
00000000
00000000
00000000
10000000
10000000
10000000
NAME 10_Eindfeest (14,7)

TIL lo
00000110
00000010
00000010
00000010
00000010
00000010
00000010
00000010
NAME 10_Eindfeest (15,7)

TIL lp
00000000
00000000
00000000
00001100
00001110
00000110
00000111
00000011
NAME 10_Eindfeest (1,8)

TIL lq
00000010
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (2,8)

TIL lr
00000111
00001111
00011111
00111111
00111111
01111111
11111111
11111111
NAME 10_Eindfeest (13,8)

TIL ls
10000001
10000001
10000000
10000000
10000000
10000000
10000000
10000000
NAME 10_Eindfeest (14,8)

TIL lt
00000010
00000010
00000010
00000010
00000010
00000010
00000110
00000110
NAME 10_Eindfeest (15,8)

TIL lu
01000000
01000000
01000000
01000000
01000000
01000000
01000000
01111100
NAME 10_Eindfeest (0,9)

TIL lv
00000000
00000000
00000000
00000000
00000000
01000000
01100000
00110000
NAME 10_Eindfeest (1,9)

TIL lw
01000100
01001100
01001000
01001000
01000000
01000000
01000000
01000000
NAME 10_Eindfeest (11,9)
WAL true

TIL lx
00000001
00000001
00000011
00000011
00000011
00000111
00000111
00000111
NAME 10_Eindfeest (12,9)

TIL ly
11111111
11111111
11111111
11111111
11110110
11100000
11100000
11000000
NAME 10_Eindfeest (13,9)

TIL lz
00000110
00000110
00000110
00000110
00000110
00000110
00000010
00000010
NAME 10_Eindfeest (15,9)

TIL m0
01111110
01111110
01111110
01111110
01111110
01111110
01111100
01000000
NAME 10_Eindfeest (0,10)

TIL m1
01100000
01110000
00100000
00000000
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (2,10)

TIL m2
00000111
00000010
00000000
00000000
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (12,10)

TIL m3
00000001
00000001
00000001
00000000
00000000
01000000
01100000
01100000
NAME 10_Eindfeest (14,10)

TIL m4
11000010
11100010
11100010
11110010
11111010
01111010
01111110
00011110
NAME 10_Eindfeest (15,10)

TIL m5
00000000
00000100
00001110
00001110
00000100
00000000
00000000
00000000
NAME 10_Eindfeest (1,11)

TIL m6
00000000
00000000
00000000
00000000
00010000
00010110
00000100
00000000
NAME 10_Eindfeest (2,11)

TIL m7
00000000
11111111
00000000
00000000
00000000
00000000
00000001
00000001
NAME 10_Eindfeest (10,11)
WAL true

TIL m8
01000010
11000010
00000000
00000000
00000000
11000000
11100000
11100000
NAME 10_Eindfeest (11,11)

TIL m9
01100000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (14,11)

TIL ma
00011110
00000010
00000010
00000010
00000010
00000010
00000010
00000010
NAME 10_Eindfeest (15,11)

TIL mb
01000000
01000000
01000000
01000000
01000000
01000000
01000000
01001110
NAME 10_Eindfeest (0,12)

TIL mc
00000001
00000011
00000000
00000000
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (1,12)

TIL md
10010000
00010000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (2,12)

TIL me
01000000
11000000
00000000
00000000
00000000
00000000
00000000
10000000
NAME 10_Eindfeest (7,12)
WAL true

TIL mf
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00110000
NAME 10_Eindfeest (9,12)

TIL mg
00000001
00000001
00001111
00011111
00011111
00011111
00011111
00011111
NAME 10_Eindfeest (10,12)

TIL mh
11110000
11110000
11100000
11100000
11000001
00000001
00000001
00000000
NAME 10_Eindfeest (11,12)

TIL mi
00000000
00000000
00000000
00000000
00000000
10010000
10011000
11011100
NAME 10_Eindfeest (12,12)

TIL mj
00000000
00000000
00001100
00011100
00011110
00011110
00011110
00011110
NAME 10_Eindfeest (13,12)

TIL mk
00000010
00000010
00000010
00000110
00011110
00111110
01111110
11111110
NAME 10_Eindfeest (15,12)

TIL ml
01011111
01011111
01011111
01011111
01011111
01011111
01011111
01011111
NAME 10_Eindfeest (0,13)

TIL mm
00000000
10000000
10000000
10000000
10000000
10000000
10000011
10001111
NAME 10_Eindfeest (1,13)

TIL mn
01100000
01100001
01000011
00000000
00011000
00111000
00011000
00000000
NAME 10_Eindfeest (3,13)

TIL mo
00000000
00000000
00111110
01111111
11111111
11111111
11111111
11111111
NAME 10_Eindfeest (4,13)

TIL mp
00000000
00000000
00000000
00000000
00000000
10000001
10001111
11011100
NAME 10_Eindfeest (5,13)

TIL mq
00000000
00000000
00000110
00001110
00001111
00011111
00001111
00001110
NAME 10_Eindfeest (6,13)

TIL mr
00000000
00000000
00000000
00000000
00000000
00001110
00001111
00001111
NAME 10_Eindfeest (7,13)

TIL ms
00001111
00000110
00000000
00000000
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (10,13)

TIL mt
11011110
01001111
00001111
00001111
00000111
00000111
00000011
00000011
NAME 10_Eindfeest (12,13)

TIL mu
00001100
00000000
00000000
10000000
10000000
11000000
11100000
11100000
NAME 10_Eindfeest (13,13)

TIL mv
00000000
00000000
00000000
00000000
00001000
01111110
11111111
11111111
NAME 10_Eindfeest (14,13)

TIL mw
11110010
11000010
00000010
00000010
00000010
00000010
00000010
00000010
NAME 10_Eindfeest (15,13)

TIL mx
01001111
01000000
01000000
01000000
01000000
01110000
01111001
01100111
NAME 10_Eindfeest (0,14)

TIL my
00011111
01111110
01111100
11110000
01000000
00000000
11100000
11111000
NAME 10_Eindfeest (1,14)

TIL mz
00000000
00001100
00001110
00001110
00001111
00001111
00000111
00000111
NAME 10_Eindfeest (2,14)

TIL n0
00000001
00000001
00000001
00000000
10000000
10000001
10000011
10000011
NAME 10_Eindfeest (3,14)

TIL n1
11000001
11000011
11000011
11000001
10000000
10000000
10000000
00000000
NAME 10_Eindfeest (5,14)

TIL n2
00000000
10000000
10000000
10000000
00000000
00000000
00000000
00000000
NAME 10_Eindfeest (6,14)

TIL n3
00011111
00001111
00001111
00001111
00000111
00000011
00000011
00000001
NAME 10_Eindfeest (7,14)

TIL n4
11000000
11000000
11100000
11100000
11100000
11100000
11000000
10000000
NAME 10_Eindfeest (8,14)

TIL n5
00000000
00000000
00000000
00000000
00000001
01000001
11100001
11100001
NAME 10_Eindfeest (10,14)

TIL n6
00111100
11111110
11111110
11111111
11111111
11111111
11111111
11111111
NAME 10_Eindfeest (11,14)

TIL n7
00000001
00000000
00000000
00000000
00000000
00000000
10000000
10000000
NAME 10_Eindfeest (12,14)

TIL n8
11110001
11110001
11110001
01110001
00111001
00111001
00011001
00000001
NAME 10_Eindfeest (13,14)

TIL n9
10000010
10000010
10000010
10000010
10000010
10000010
10000010
10000010
NAME 10_Eindfeest (15,14)

TIL na
01001111
01011111
01111111
01111111
01111111
01111111
01111111
00000000
NAME 10_Eindfeest (0,15)

TIL nb
11111100
11111110
11111111
11111111
11111111
11111111
11111111
00000000
NAME 10_Eindfeest (1,15)

TIL nc
00000111
00000011
00000000
00000000
10000000
11000000
11111111
00000000
NAME 10_Eindfeest (2,15)

TIL nd
10000111
00000111
00000111
00000111
00000111
00000111
11111111
00000000
NAME 10_Eindfeest (3,15)

TIL ne
11111110
11111110
11111111
11111111
11111111
11111110
11111111
00000000
NAME 10_Eindfeest (4,15)

TIL nf
00000000
00000000
00000000
00000000
00000001
00000001
11111111
00000000
NAME 10_Eindfeest (5,15)

TIL ng
00111100
01111110
11111111
11111111
11111111
11111111
11111111
00000000
NAME 10_Eindfeest (6,15)

TIL nh
00000000
00000000
00000000
00000000
10000000
10000001
11111111
00000000
NAME 10_Eindfeest (7,15)

TIL ni
00000000
00000000
00000000
00000000
01111000
11111110
11111111
00000000
NAME 10_Eindfeest (8,15)

TIL nj
00000001
00000001
00000000
00000000
00000000
00000001
11111111
00000000
NAME 10_Eindfeest (10,15)

TIL nk
11111111
11111111
11111111
11111110
11111110
11111100
11111111
00000000
NAME 10_Eindfeest (11,15)

TIL nl
10000000
00000000
00000000
00000000
00000000
00000100
11111111
00000000
NAME 10_Eindfeest (12,15)

TIL nm
11111111
11111111
01111110
00111100
00000000
00000000
11111111
00000000
NAME 10_Eindfeest (14,15)

TIL nn
00000010
00000010
00000010
00000110
00011110
01111110
11111110
00000000
NAME 10_Eindfeest (15,15)

TIL no
11111111
11111111
11111111
11111111
11111111
11011111
11111111
11111111
WAL true

TIL np
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL nq
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL ns
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
WAL true

TIL nt
00000000
00000000
00000000
01000000
00000100
00010000
01100000
10000010
WAL true

TIL nw
11111111
11111111
11111111
11111111
11111111
11110111
11111111
11111111
WAL false

TIL nx
11111111
11111111
11111111
11111110
11111111
11111111
11111111
11111111
NAME knokploeg
WAL false

TIL ny
01111111
01111111
01111111
01111111
01111111
01111111
01111111
01111111
WAL true

TIL nz
01111111
01111111
01111111
01111111
01111101
01111101
01111111
01111111
WAL true

TIL o0
11111110
11111110
11111110
11111110
11111110
11111110
11111100
11111110

TIL o1
00000000
11111111
00000000
00000000
00000000
00000011
00000111
00001111

TIL o2
00000000
11111111
00000000
00000000
00000000
11111110
11111111
11111111

TIL o3
00000000
11111111
00000000
00000000
00000000
00011111
00011111
00011111

TIL o4
00000000
11111111
00000000
00000000
00000000
11111100
11111100
11111101

TIL o5
00000000
11111111
00000000
00000000
00000000
00000000
00000000
11111111

TIL o6
00000000
11111111
00000000
00000000
00000000
00111111
00111111
10111111

TIL o7
00000000
11111111
00000000
00000000
00000000
11111111
11111111
11111111

TIL o8
00000000
11111111
00000000
00000000
00000000
00000011
10000011
11000111

TIL oa
00000000
11111111
00000000
00000000
00000000
11111000
11111111
11111111

TIL ob
00000000
11111111
00000000
00000000
00000000
00011111
11111111
11111111

TIL oc
00000000
11111111
00000000
00000000
00000000
11100000
11110000
11111000

TIL od
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000011

TIL oe
00001111
00011111
00111111
01111111
11111111
11111111
11111111
11111111

TIL of
11111111
11111111
11111111
11111111
11111111
11111111
11110111
11100011

TIL og
10011111
11011111
11011111
11111111
11111111
11011111
11011111
10011111

TIL oh
11111101
11111100
11111100
11111100
11111100
11111100
11111100
11111100

TIL k0
00000000
01111111
01000000
01000000
01000000
01000000
01000000
01000000

TIL oi
00000000
11111111
00000000
00000000
00000000
00000000
00000000
00000000

TIL oj
00000000
11111110
00000010
00000010
00000010
00000010
00000010
00000010

TIL ok
01000000
01000000
01000000
01000000
01000000
01000000
01000000
01000000

TIL ol
10011111
11011111
11111111
11111111
11111111
11111111
11011111
10011111

TIL om
11111111
11111111
11111111
11111111
11111111
11111111
11001111
11000111

TIL on
11111111
11111111
11111111
11110011
11110011
11000011
00000011
11100011

TIL oo
11111111
11111111
11111111
11111111
11111111
11111111
11111001
11111001

TIL op
11111100
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL or
00000010
00000010
00000010
00000010
00000010
00000010
00000010
00000010

TIL os
00000001
00000000
00000000
00000000
00000001
00000001
00000011
00000011

TIL ot
11111111
11111111
00111111
00011111
11001111
11100011
11110011
11111111

TIL ou
11100001
11111000
11111100
11111110
11111111
11111111
11111111
11111111

TIL ov
10011111
00011111
00011111
00011111
00011111
11011111
11011111
11011111

TIL ow
11111100
11111100
11111100
11111100
11111101
11111111
11111111
11111111

TIL ox
11001111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL oy
11111111
11111111
11111111
11111111
11111111
11110111
11100111
11000111

TIL oz
11100011
11100011
11100011
11100011
11100011
11100011
00000011
11110011

TIL p0
11111001
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL p1
11111111
11111111
11111111
11111111
11111110
11111100
11111100
11111110

TIL p2
00000111
00000111
00000011
00000000
00000000
00000000
00000000
00000000

TIL p3
11111111
11111111
11111111
11111111
11111111
00111111
00011111
00001111

TIL p4
11011111
10001111
10001111
00000111
00000011
00000001
00000001
00000000

TIL p5
11111111
11111111
11111111
11111110
11111110
11111100
11111000
11110000

TIL p6
11111111
11111111
11111110
10000000
10000000
10000000
10000000
10000000

TIL p7
10000111
10000111
00000111
00000111
00000011
00000011
00000011
00000011

TIL p8
11111011
11111011
11111111
11111111
11111111
11111111
11111111
11111111

TIL p9
11111111
11111111
11111111
11111101
11111100
11111100
11111110
11111100

TIL pa
11111111
11111111
11111111
11111111
11111111
01111111
00111100
00011000

TIL pb
00000000
10000000
11000000
11100000
11100000
00000000
00000000
00000000

TIL pc
01000000
01000000
01000000
01000000
01000000
01000001
01000011
01000011

TIL pd
00011111
00111111
00111111
01111111
11111111
11111111
11111111
11111111

TIL pe
11000000
11100000
11110000
11110000
11111000
11111100
11111110
11111100

TIL pf
00000000
00001111
00001111
00011111
00011111
00111111
00111111
01111111

TIL pg
01000000
11100000
11100000
11100000
11110000
11110000
11111000
11111000

TIL ph
00001111
00011111
00011111
00011111
00011111
00011111
00011111
00111111

TIL pi
00001000
10011111
10011111
11011111
11011111
11111111
11111111
11111111

TIL pj
11100000
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL pk
00000001
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL pl
11110000
11110000
11111000
11111000
11111000
11111000
11111000
11111000

TIL pm
00011110
00011111
00011111
00111111
00111111
00111111
00111111
00111111

TIL pn
00010000
00011111
00111111
10111111
11111111
11111111
11111111
11111111

TIL po
00000001
10000011
10000111
10001111
10111111
11111111
11111111
11111111

TIL pp
00000010
00000010
00000010
10000010
11000010
11000010
11100010
11110010

TIL pq
01000111
01001111
01000111
01000011
01000001
01000100
01000111
01001111

TIL pr
11111111
11111110
11111111
11111111
11111111
01111111
00111111
10011111

TIL ps
11111100
01111000
00110000
10000001
11000001
11110011
11110011
11111011

TIL pt
01111111
11111111
11111100
11111111
11111111
11111111
11111111
11111111

TIL pu
11111000
11111100
11111100
11111110
11111110
11111110
11111111
11111111

TIL pv
00111111
00111111
00111111
00111111
00111111
00111111
00111111
00111111

TIL pw
11111111
11000001
11000000
11000000
11000000
11000000
10000000
10000000

TIL px
11111111
11111111
11111110
11111110
11111111
11111111
11111111
11111111

TIL py
11111101
11111101
00001101
00000001
00000001
00000001
00000001
00000001

TIL pz
11111100
11111100
11111100
11111100
11111100
11111100
11111100
11111110

TIL q0
00111111
01111111
01111111
01111111
01111111
01111111
01111111
11111111

TIL q1
11111111
11111111
10001111
10001111
10001111
11111111
11111111
11111111

TIL q2
11110010
11111010
11111010
11110010
11110010
11110010
11110010
11110010

TIL q3
01001111
01011111
01001111
01000111
01000011
01000001
01000000
01000000

TIL q4
11001111
11111111
11111111
11111111
11111111
11111111
11111111
01111111

TIL q5
11111011
11110011
11110111
11110111
11110111
11101111
11101111
11000000

TIL q6
11111111
11111111
11110000
11100000
11100000
11100000
11100000
11100000

TIL q7
11111111
11111111
01111111
01111111
01111111
00111111
00111110
00100000

TIL q8
10111111
11111111
11111111
11111111
11111111
11111111
11111110
01111110

TIL q9
11111111
11111111
01111111
01111111
00111111
00111111
00011111
00000111

TIL qa
10000000
10000000
10000001
10000001
10000001
10000001
10000001
10000001

TIL qb
00000001
00000001
00000001
10000001
10000001
10000001
10000001
10000001

TIL qc
11111110
11111110
11111110
11111111
11111111
11111111
11111101
00000000

TIL qd
11111111
11111111
11111110
11111110
11111110
11111110
11111100
01111100

TIL qe
11111111
11111111
11111111
11111111
01111111
00111111
00111111
00000111

TIL qf
10111111
00011111
00001111
00001111
00000111
00000011
00000000
00000000

TIL qg
11111111
11111111
11111111
11111111
11111111
11111111
11110000
10000000

TIL qh
11110010
11100010
11100010
11100010
11100010
00000010
00000010
00000010

TIL qi
00000000
00000000
00000000
00111110
00011100
00001100
00001110
00000110

TIL qj
00000000
00000000
00000000
00111001
00010010
00100010
00100011
01000011

TIL qk
00000000
00000000
00000000
11100000
00010000
00010000
10000000
11100000

TIL ql
00000000
00000000
00000000
00001111
00000011
00000011
00000011
00000011

TIL qm
00000000
00000000
00000000
11111000
00001000
00001000
00000011
11100001

TIL qn
00000000
00000000
00000000
00000011
00000011
00000000
10011111
10010011

TIL qo
00000000
00000000
00000000
01110000
00110000
00110000
00110000
00110000

TIL qp
00000000
00000000
00000000
00111111
00001100
00001100
00001100
00001100

TIL qq
00000000
00000000
00000000
00000000
00000000
00000000
00111000
01001100

TIL qr
00000000
00000000
00000000
00000000
00000000
00000000
01110000
11011011

TIL qs
00000000
00000000
00000000
00000111
00000011
00000011
11000011
00110011

TIL qt
00000000
00000000
00000000
00000000
00000000
00000000
11100000
00110000

TIL qu
00000111
00000011
00000011
00000001
00000001
00000000
00000000
00000000

TIL qv
01000001
10000000
10000000
00000010
00000001
00000000
00000000
00000000

TIL qw
11110000
00111000
00011000
00010011
11100011
00000000
00000000
00000000

TIL qx
00000011
00000011
00000011
00000011
00000111
00000000
00000000
00000000

TIL qy
00100001
00000000
00000000
00001000
11111000
00000000
00000000
00000000

TIL qz
10010011
11100011
11100011
01000011
01000111
00000000
00000000
00000000

TIL r0
00110000
00110000
00110000
00110000
11111000
00000000
00000000
00000000

TIL r1
00001100
00001100
11001100
11001100
01111000
00000000
00000000
00000000

TIL r2
11001101
00111101
01001101
11001100
11111100
00000000
00000000
00000000

TIL r3
10011011
10000011
11000011
11000011
01111001
00000000
00000000
00000000

TIL r4
00110011
00110011
00110011
00110011
11100011
00000000
00000000
00000000

TIL r5
00110000
00110000
00110000
00110000
11100000
00000000
00000000
00000000

TIL r6
00000011
00000011
00000110
00000110
00000110
00000011
00000010
00000110

TIL r7
11111111
11111111
00111100
00111100
00100100
11000011
11111111
00000000

TIL r8
11000000
11000000
01100000
01100000
01100000
11000000
01000000
01100000

TIL r9
00000111
00000001
00000000
00001011
00011101
00110010
00111101
00111110

TIL ra
01011010
10000001
01111110
00011000
10000001
00111100
10111101
10011001

TIL rb
11100000
10000000
00000000
11010000
10111000
01001100
10111100
01111100
WAL true

TIL rc
00011101
00000101
00000001
00000000
00000001
00000000
00000011
00001111

TIL rd
10111101
10000001
10111101
00111100
11000011
00000000
11000011
11000011
WAL true

TIL re
10111000
10100000
10000000
00000000
10000000
00000000
11000000
11110000
WAL true

TIL rf
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL rg
11111111
00000000
00000000
00000000
00000000
00011100
00011100
00000000

TIL rh
11111111
00000000
00000000
00000000
00000000
00000000
00001000
00011000

TIL ri
11111111
00000000
00000000
00000000
00000000
00001111
00011111
00110011
WAL true

TIL rj
11111111
00000000
00000000
00000000
00000000
10000111
11001100
11001100
WAL true

TIL rk
11111111
00000000
00000000
00000000
00000000
11000011
01100111
01101100
WAL true

TIL rl
11111111
00000000
00000000
00000000
00000000
11100000
11110000
11110000
WAL true

TIL rm
11111111
00000000
00000000
00000000
00000000
00110000
01110000
11110000
WAL true

TIL rn
11110000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL ro
00000000
00000011
00000001
00000001
00000001
00000000
00000000
00000000

TIL rp
00000000
10011100
10011100
11011110
11011110
11100111
11100111
01000010

TIL rq
00000000
01011100
10011100
10011100
10011100
00011100
00011100
00011100

TIL rr
00111100
11111111
11100111
11100111
11100111
11100111
11100111
11100111

TIL rs
00111000
01111100
00111000
00111001
00111001
00111001
00111001
00111100

TIL rt
00110000
11001100
11001100
11111100
11000000
11000000
11000100
11111100

TIL ru
01111100
11111110
11101100
11100000
11100000
11100000
11100000
11100000

TIL rv
00000001
00000001
00000001
00000011
00000110
00001100
00011111
00111111

TIL rw
11001100
10011100
10011100
00011100
00001100
01001100
11001100
11000111

TIL rx
01100000
01110000
01110000
01110000
01100001
01100011
01100111
11001111

TIL ry
01110001
01100011
01100110
11000100
10000111
00010111
11110000
11110000

TIL rz
11110000
01110000
01110000
01110000
11111000
11111000
01110000
01110000

TIL s0
00000000
00000000
00000000
00000000
00000000
00000000
11111111
00000000

TIL s1
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL s2
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL s3
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL s4
11110000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL s5
11110000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL s6
11110000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL s7
11110000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL s8
11110000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL s9
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL sa
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL sb
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL sc
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

SPR 10
00000000
00000001
00000001
00000001
00000011
00000111
00001001
00001011
DLG k
POS a 5,8
BGC *

SPR 11
10000000
10000000
11000000
01000000
11000000
01000000
10100000
11110000
>
10000000
11000000
11000000
01000000
11000000
01000000
10100000
11110000
DLG k
POS a 7,8
BGC *

SPR 12
11000000
11000000
00010000
00000000
00000000
00111110
11111111
11001111
>
00000000
00000000
00000000
00000000
00111110
11111111
11001111
11010101
POS a 6,7
BGC *

SPR 13
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000000
>
00000000
00000000
00000000
00000000
00000000
00000000
10000000
10000000
POS a 7,7
BGC *

SPR 14
00000000
00000000
00000000
00001100
00010010
00010010
00001100
00000000
>
00000000
00000000
00000000
00000000
00001100
00001100
00000000
00000000
BGC *

SPR 15
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00111100
00100000
00100000
00100111
00100100
00100100
00100100
POS c 5,8
BGC *

SPR 16
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00100100
00100100
00100100
00100111
00100000
00100000
00111100
00000000
POS c 5,9
BGC *

SPR 17
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
11000111
00100100
00100100
00100111
POS c 6,8
BGC *

SPR 18
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00100100
00100100
00100100
11000111
00000000
00000000
00000000
00000000
POS c 6,9
BGC *

SPR 19
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
11000110
00001010
00001001
10001001
POS c 7,8
BGC *

SPR A
00011000
00011000
00011000
00111100
01111110
10111101
00100100
00100000
>
00011000
00011000
00011000
01111110
10111101
00111100
00100100
00000100
POS c 7,12
BGC *

SPR a
00000000
00000000
01010010
01110010
01110010
01111100
00111100
00100100
>
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
NAME cat
DLG 7
POS 4 9,4
BGC *

SPR b
00000000
00000000
00000000
01001001
01001001
00101010
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME blink
DLG 0
POS 1 8,7
BGC *

SPR c
00111100
00011000
00111100
10111100
11111111
00111100
00100100
00100100
>
00111100
00011000
10111100
11111111
00111100
00111100
00100100
00100100
NAME KEVIN
DLG 4
POS 4 10,9
BGC *

SPR d
00000000
00011100
00011100
00111110
00111101
00111100
00010100
00010100
NAME Barman
POS 4 4,5
BGC *

SPR e
00111100
01111110
01011010
01111111
01111111
11111110
11111110
01111110
>
00111100
01111110
01011010
01111110
11111111
11111111
01111110
01111110
NAME Filmliefhebber
DLG 8
POS 4 12,5
BGC *

SPR f
00111000
00111000
00111000
00011111
00010000
00011110
00000010
00000010
>
00011100
00011100
00011100
00011111
00010000
00011110
00000010
00000010
NAME Stoelzitter
DLG 5
POS 4 8,6
BGC *

SPR g
00111000
00111000
00111000
11111000
00001000
11111000
10000000
10000000
>
00011100
00011100
00011100
11111000
00001000
11111000
10000000
10000000
DLG 6
POS 4 10,6
BGC *

SPR h
01100000
01100000
00100000
11100000
00100000
00100000
00110000
00010000
>
00000000
11000000
11100000
11100000
00100000
00100000
00110000
00010000
NAME Knok 1
DLG b
POS 7 2,7
BGC *

SPR i
00000000
00000000
00000000
00011000
00011000
00011000
01111110
01011010
>
00000000
00000000
00000000
00000000
00011000
00011000
01111110
01011010
NAME Knok 2
DLG d
POS 7 9,6
BGC *

SPR j
00000000
00000000
00000000
00011000
00011000
11111111
00011000
00011000
NAME Knok3
POS 7 2,4
BGC *

SPR k
00011000
00100100
01000010
01000010
00000000
00000000
00000000
00000000
DLG c
POS 7 2,5
BGC *

SPR l
00011100
00011100
00011100
00001111
00001000
00001000
00001100
00001100
>
00011100
00011100
00011100
00001111
00001000
00010100
00100100
01000100
NAME Knok 5
DLG f
POS 7 6,5
BGC *

SPR m
01110000
01110000
01110000
11100000
00100000
01010000
01001000
01000100
>
01110000
01110000
01110000
11100000
00100000
00100000
01100000
01100000
NAME Knok 6
DLG e
POS 7 7,5
BGC *

SPR n
00000000
00001100
00001111
00001100
11111100
11111000
01111000
00110000
>
00000000
00000000
00001100
00001111
00001100
11111100
11111000
01111000
NAME Knok 7
DLG h
POS 7 5,10
BGC *

SPR o
00011000
00011000
00011000
11111111
00011000
01111110
01000010
01000010
>
00110000
00110000
00110000
11111111
00011000
01111110
01000010
01000010
DLG g
POS 7 13,7
BGC *

SPR p
00000000
00000000
00000000
00001100
00010010
00010010
00001100
00000000
>
00000000
00000000
00000000
00000000
00001100
00001100
00000000
00000000
POS 8 12,12
BGC *

SPR q
00000000
00000000
00000000
00110000
01001000
01001000
00110000
00000000
>
00000000
00000000
00000000
00000000
00110000
00110000
00000000
00000000
POS 9 3,12
BGC *

SPR r
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
DLG j
POS c 6,11
BGC *

SPR s
10010100
11000000
11110110
10101101
00010000
00001000
01001000
11111111
>
10000000
11100000
11110110
10101101
00010000
00001000
01001000
11111111
NAME Belle main
DLG k
POS 0 3,12
BGC *

SPR t
00000000
00000001
00000001
00000001
00000011
00000111
00001001
00001011
NAME Belle links
POS 0 2,12
BGC *

SPR u
10000000
10000000
11000000
01000000
11000000
01000000
10100000
11110000
>
10000000
11000000
11000000
01000000
11000000
01000000
10100000
11110000
NAME Belle rechts
POS 0 4,12
BGC *

SPR v
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000000
>
00000000
00000000
00000000
00000000
00000000
00000000
10000000
10000000
NAME Belle rechtsboven
POS 0 4,11
BGC *

SPR w
11000000
11000000
00010000
00000000
00000000
00111110
11111111
11001111
>
00000000
00000000
00000000
00000000
00111110
11111111
11001111
11010101
NAME Belle hoofd
POS 0 3,11
BGC *

SPR x
00011000
00011000
01111110
01011010
01011010
00011000
00100100
00100100
>
00011000
00011000
00011000
01111110
01011010
01011010
00100100
00100100
BGC *

SPR y
00000000
00000000
00000000
00001100
00010010
00010010
00001100
00000000
>
00000000
00000000
00000000
00000000
00001100
00001100
00000000
00000000
DLG l
POS 0 10,12
BGC *

SPR z
10010100
11000000
11110110
10101101
00010000
00001000
01001000
11111111
>
10000000
11100000
11110110
10101101
00010000
00001000
01001000
11111111
DLG k
POS a 6,8
BGC *

SPR 1a
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00001001
00001000
00001000
11001000
00000000
00000000
00000000
00000000
POS c 7,9
BGC *

SPR 1b
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
11000011
10100100
00100100
00100100
POS c 8,8
BGC *

SPR 1c
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00100100
00100100
00100100
00100011
00000000
00000000
00000000
00000000
POS c 8,9
BGC *

SPR 1d
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00111100
00000100
00000100
11000100
00100100
00100100
00100100
POS c 9,8
BGC *

SPR 1e
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00100100
00100100
00100100
11000100
00000100
00000100
00111100
00000000
POS c 9,9
BGC *

SPR 1f
00000000
00000000
00000000
00001100
00001100
00000000
00000000
00000000
DLG m
POS 8 0,12
BGC *

ITM 0
00000000
00000000
00000000
00111100
01100100
00100100
00011000
00000000
NAME tea

ITM 1
00000000
00111100
00100100
00111100
00010000
00011000
00010000
00011000
NAME key

DLG 0
"""
Hey {wvy}{rbw}Sanny{/rbw}{/wvy}, ik ben ontvoerd.{pg}Kom je me redden?

 - liefs, Belle
"""
NAME brief

DLG 1
Het is al avond...{pg}Je besluit naar {shk}Focus {/shk}te gaan...
NAME exit narration 1

DLG 2
You walk through the doorway
NAME exit narration 2

DLG 3
Je loopt de bioscoop binnen..
NAME exit narration 3

DLG 4
{clr 0}KEVIN{/clr}: Ik heb Belle niet gezien...{pg}{clr 0}KEVIN{/clr}: Kan je haar deze blu-ray van {wvy}Aliens{/wvy} geven?
NAME KEVIN

DLG 5
 {drws "Stoelzitter"}: Ik vond {wvy}Gladiator II{/wvy} echt kut.
NAME Stoelzitter 1

DLG 6
 {drws "g"}: Ik heb echt het gevoel dat wij een andere film hebben gekeken..
NAME Stoelzitter 2

DLG 7
 {drws "cat"}: Wow, eh.. meow?{pg}Nee, ik heb geen bellen gezien..
NAME Kat

DLG 8
 {drws "Filmliefhebber"}: Yo man, geïnteresseerd in het starten van een podcast over films?
NAME Filmliefhebber

DLG 9
 Je besluit bij de Knokploeg langs te gaan...
NAME Exit Dialoog 2

DLG a
Het wordt steeds donkerder...
NAME exit narration 4

DLG b
Ik haat subsidie aanvragen..
NAME Knok 1 dialog

DLG c
{clr 0}LUNA{/clr}: Oh moeder...
NAME sprite k dialog

DLG d
{clr 0}TIEMEN HAGEMAN{/clr}: Ik ben Tiemen Hageman.
NAME Knok 2 dialog

DLG e
Wij doen een literaire dans!
NAME Knok 6 dialog

DLG f
We kunnen niet stoppen!
NAME Knok 5 dialog

DLG g
{clr 0}LOUIS{/clr}: Ze laten mij altijd koken.. {shk}ALTIJD{/shk}!
NAME sprite o dialog

DLG h
Sinds dat gat in de grond is verschenen doen ze allemaal raar...
NAME Knok 7 dialog

DLG i
Je weet niet wat je te wachten staat, maar besluit toch het gat in te springen...
NAME exit narration 5

DLG j
Je kan niet meer terug...
NAME sprite r dialog

DLG k
Je vindt Belle gewikkeld in een hoop dekens...{pg}{clr 0}BELLE{/clr}: {wvy}Santino{/wvy}! Je hebt me gevonden...{pg}{clr 0}BELLE{/clr}: Wat voor briefje? Ik zit hier al dagen vast...{pg}{clr 0}BELLE{/clr}: Het zal toch niet?{pg}{exit "0" 13 12 "fade_w"}
NAME Belle main dialog

DLG l
Prrrt, einde van de demo. {wvy}BLIEP BLOEP.{/wvy}{pg}{end}
NAME sprite y dialog

DLG m
Je kan niet meer terug...
NAME sprite 1f dialog

VAR a
42

TUNE 3
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
KEY C,D,D#,F,G,G#,A# d,r,m,s,l
TMP SLW
SQR P8 P4
ARP INT8


</script>

<style>
html {
	margin: 0;
	padding: 0;
}

body {
	margin: 0;
	padding: 0;
	overflow: hidden;
	background: #000;
}

#game {
	background: black;
	width: 100vw;
	max-width: 100vh;
	margin: auto;
	display: block;
	touch-action: none; /* fixing touch-input errors in chrome */

	/* sharp pixel edges */
	/* https://caniuse.com/#search=image-render */
	-ms-interpolation-mode: nearest-neighbor; /* IE */
	image-rendering: -moz-crisp-edges; /* FF 6.0+ */
	image-rendering: pixelated; /* Chrome, Safari */
}

</style>

<!-- SCRIPTS -->
<script>
function startExportedGame() {
	var gameCanvas = document.getElementById("game");
	var gameData = document.getElementById("exportedGameData").text.slice(1);
	var defaultFontData = document.getElementById(defaultFontName).text.slice(1);
	loadGame(gameCanvas, gameData, defaultFontData);
	initSystem();
}
</script>

<!-- system -->
<script>
function InputSystem() {
	var self = this;

	this.Key = {
		LEFT: 37,
		RIGHT: 39,
		UP: 38,
		DOWN: 40,
		SPACE: 32,
		ENTER: 13,
		W: 87,
		A: 65,
		S: 83,
		D: 68,
		R: 82,
		SHIFT: 16,
		CTRL: 17,
		ALT: 18,
		CMD: 224
	};

	var pressed;
	var ignored;
	var touchState;

	var isRestartComboPressed = false;

	var SwipeDir = {
		None : -1,
		Up : 0,
		Down : 1,
		Left : 2,
		Right : 3,
	};

	function resetAll() {
		isRestartComboPressed = false;

		pressed = {};
		ignored = {};

		touchState = {
			isDown : false,
			startX : 0,
			startY : 0,
			curX : 0,
			curY : 0,
			swipeDistance : 30,
			swipeDirection : SwipeDir.None,
			tapReleased : false
		};
	}

	resetAll();

	function stopWindowScrolling(e) {
		if (e.keyCode == self.Key.LEFT || e.keyCode == self.Key.RIGHT || e.keyCode == self.Key.UP || e.keyCode == self.Key.DOWN || !isPlayerEmbeddedInEditor) {
			e.preventDefault();
		}
	}

	function isRestartCombo(e) {
		return (e.keyCode === self.Key.R && (e.getModifierState("Control")|| e.getModifierState("Meta")));
	}

	function eventIsModifier(event) {
		return (event.keyCode == self.Key.SHIFT || event.keyCode == self.Key.CTRL || event.keyCode == self.Key.ALT || event.keyCode == self.Key.CMD);
	}

	function isModifierKeyDown() {
		return (self.isKeyDown(self.Key.SHIFT) || self.isKeyDown(self.Key.CTRL) || self.isKeyDown(self.Key.ALT) || self.isKeyDown(self.Key.CMD));
	}

	this.ignoreHeldKeys = function() {
		for (var key in pressed) {
			if (pressed[key]) { // only ignore keys that are actually held
				ignored[key] = true;
				// bitsyLog("IGNORE -- " + key, "system");
			}
		}
	}

	this.onkeydown = function(event) {
		enableGlobalAudioContext();
		// bitsyLog("KEYDOWN -- " + event.keyCode, "system");

		stopWindowScrolling(event);

		isRestartComboPressed = isRestartCombo(event);

		// Special keys being held down can interfere with keyup events and lock movement
		// so just don't collect input when they're held
		{
			if (isModifierKeyDown()) {
				return;
			}

			if (eventIsModifier(event)) {
				resetAll();
			}
		}

		if (ignored[event.keyCode]) {
			return;
		}

		pressed[event.keyCode] = true;
		ignored[event.keyCode] = false;
	}

	this.onkeyup = function(event) {
		// bitsyLog("KEYUP -- " + event.keyCode, "system");
		pressed[event.keyCode] = false;
		ignored[event.keyCode] = false;

		isRestartComboPressed = false;
	}

	this.ontouchstart = function(event) {
		enableGlobalAudioContext();

		event.preventDefault();

		if( event.changedTouches.length > 0 ) {
			touchState.isDown = true;

			touchState.startX = touchState.curX = event.changedTouches[0].clientX;
			touchState.startY = touchState.curY = event.changedTouches[0].clientY;

			touchState.swipeDirection = SwipeDir.None;
		}
	}

	this.ontouchmove = function(event) {
		event.preventDefault();

		if( touchState.isDown && event.changedTouches.length > 0 ) {
			touchState.curX = event.changedTouches[0].clientX;
			touchState.curY = event.changedTouches[0].clientY;

			var prevDirection = touchState.swipeDirection;

			if( touchState.curX - touchState.startX <= -touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Left;
			}
			else if( touchState.curX - touchState.startX >= touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Right;
			}
			else if( touchState.curY - touchState.startY <= -touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Up;
			}
			else if( touchState.curY - touchState.startY >= touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Down;
			}

			if( touchState.swipeDirection != prevDirection ) {
				// reset center so changing directions is easier
				touchState.startX = touchState.curX;
				touchState.startY = touchState.curY;
			}
		}
	}

	this.ontouchend = function(event) {
		event.preventDefault();

		touchState.isDown = false;

		if( touchState.swipeDirection == SwipeDir.None ) {
			// tap!
			touchState.tapReleased = true;
		}

		touchState.swipeDirection = SwipeDir.None;
	}

	this.isKeyDown = function(keyCode) {
		return pressed[keyCode] != null && pressed[keyCode] == true && (ignored[keyCode] == null || ignored[keyCode] == false);
	}

	this.anyKeyDown = function() {
		var anyKey = false;

		for (var key in pressed) {
			if (pressed[key] && (ignored[key] == null || ignored[key] == false) &&
				!(key === self.Key.UP || key === self.Key.DOWN || key === self.Key.LEFT || key === self.Key.RIGHT) &&
				!(key === self.Key.W || key === self.Key.S || key === self.Key.A || key === self.Key.D)) {
				// detected that a key other than the d-pad keys are down!
				anyKey = true;
			}
		}

		return anyKey;
	}

	this.isRestartComboPressed = function() {
		return isRestartComboPressed;
	}

	this.swipeLeft = function() {
		return touchState.swipeDirection == SwipeDir.Left;
	}

	this.swipeRight = function() {
		return touchState.swipeDirection == SwipeDir.Right;
	}

	this.swipeUp = function() {
		return touchState.swipeDirection == SwipeDir.Up;
	}

	this.swipeDown = function() {
		return touchState.swipeDirection == SwipeDir.Down;
	}

	this.isTapReleased = function() {
		return touchState.tapReleased;
	}

	this.resetTapReleased = function() {
		touchState.tapReleased = false;
	}

	this.onblur = function() {
		// bitsyLog("~~~ BLUR ~~", "system");
		resetAll();
	}

	this.resetAll = resetAll;

	this.listen = function(canvas) {
		document.addEventListener('keydown', self.onkeydown);
		document.addEventListener('keyup', self.onkeyup);

		if (isPlayerEmbeddedInEditor) {
			canvas.addEventListener('touchstart', self.ontouchstart, {passive:false});
			canvas.addEventListener('touchmove', self.ontouchmove, {passive:false});
			canvas.addEventListener('touchend', self.ontouchend, {passive:false});
		}
		else {
			// creates a 'touchTrigger' element that covers the entire screen and can universally have touch event listeners added w/o issue.

			// we're checking for existing touchTriggers both at game start and end, so it's slightly redundant.
			var existingTouchTrigger = document.querySelector('#touchTrigger');

			if (existingTouchTrigger === null) {
				var touchTrigger = document.createElement("div");
				touchTrigger.setAttribute("id","touchTrigger");

				// afaik css in js is necessary here to force a fullscreen element
				touchTrigger.setAttribute(
					"style","position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; overflow: hidden;"
				);

				document.body.appendChild(touchTrigger);

				touchTrigger.addEventListener('touchstart', self.ontouchstart);
				touchTrigger.addEventListener('touchmove', self.ontouchmove);
				touchTrigger.addEventListener('touchend', self.ontouchend);
			}
		}

		window.onblur = self.onblur;
	}

	this.unlisten = function(canvas) {
		document.removeEventListener('keydown', self.onkeydown);
		document.removeEventListener('keyup', self.onkeyup);

		if (isPlayerEmbeddedInEditor) {
			canvas.removeEventListener('touchstart', self.ontouchstart);
			canvas.removeEventListener('touchmove', self.ontouchmove);
			canvas.removeEventListener('touchend', self.ontouchend);
		}
		else {
			//check for touchTrigger and removes it

			var existingTouchTrigger = document.querySelector('#touchTrigger');

			if (existingTouchTrigger !== null) {
				existingTouchTrigger.removeEventListener('touchstart', self.ontouchstart);
				existingTouchTrigger.removeEventListener('touchmove', self.ontouchmove);
				existingTouchTrigger.removeEventListener('touchend', self.ontouchend);

				existingTouchTrigger.parentElement.removeChild(existingTouchTrigger);
			}
		}

		window.onblur = null;
	}
}
</script>

<script>
// init global audio context
var audioContext = new AudioContext();

function enableGlobalAudioContext() {
	audioContext.resume();
}

function SoundSystem() {
	var self = this;

	// volume
	var maxGain = 0.15;

	// curves for different pulse wave duties (ratios between on and off)
	var dutyCycle_1_8 = new Float32Array(256);
	for (var i = 0; i < 256; i++) {
		dutyCycle_1_8[i] = ((i / 256) * 2) - 1.75;
	}

	var dutyCycle_1_4 = new Float32Array(256);
	for (var i = 0; i < 256; i++) {
		dutyCycle_1_4[i] = ((i / 256) * 2) - 1.5;
	}

	var dutyCycle_1_2 = new Float32Array(256);
	for (var i = 0; i < 256; i++) {
		dutyCycle_1_2[i] = ((i / 256) * 2) - 1.0;
	}

	var dutyCycles = [
		dutyCycle_1_8,
		dutyCycle_1_4,
		dutyCycle_1_2 // square wave
	];

	function createPulseWidthModulator() {
		// the base oscillator: start with a sawtooth wave that we'll shape into a pulse wave
		var oscillator = audioContext.createOscillator();
		oscillator.type = "sawtooth";

		// create a gain node to control the volume of the sound
		var volumeControl = audioContext.createGain();
		volumeControl.gain.value = 0;

		// create a wave shaper that turns the sawtooth wave into a pulse
		// by mapping any negative value to -1 and any positive value to 1
		var pulseCurve = new Float32Array(256);
		for (var i = 0; i < 128; i++) {
			pulseCurve[i] = -1;
		}
		for (var i = 128; i < 256; i++) {
			pulseCurve[i] = 1;
		}

		var pulseShaper = audioContext.createWaveShaper();
		pulseShaper.curve = pulseCurve;

		var dutyShaper = audioContext.createWaveShaper();
		dutyShaper.curve = dutyCycle_1_2;

		oscillator.connect(dutyShaper);
		dutyShaper.connect(pulseShaper);
		pulseShaper.connect(volumeControl);
		volumeControl.connect(audioContext.destination);
		oscillator.start();

		return {
			oscillator: oscillator,
			volumeControl: volumeControl,
			dutyShaper: dutyShaper
		};
	}

	var pulseChannels = [createPulseWidthModulator(), createPulseWidthModulator()];

	this.setPulse = function(channel, pulse) {
		var pulseChannel = pulseChannels[channel];
		pulseChannel.dutyShaper.curve = dutyCycles[pulse];
	}

	this.setFrequency = function(channel, frequencyHz) {
		var pulseChannel = pulseChannels[channel];
		// set frequency in hertz
		pulseChannel.oscillator.frequency.setValueAtTime(frequencyHz, audioContext.currentTime);
	}

	this.setVolume = function(channel, volumeNorm) {
		var pulseChannel = pulseChannels[channel];
		pulseChannel.volumeControl.gain.value = volumeNorm * maxGain;
	}

	this.mute = function() {
		for (var i = 0; i < pulseChannels.length; i++) {
			pulseChannels[i].volumeControl.gain.value = 0;
		}
	}
}

var sound = new SoundSystem();
</script>

<script>
function GraphicsSystem() {
	var self = this;

	var canvas;
	var ctx;

	var scale;
	var textScale;
	var palette = [];
	var images = [];
	var imageFillColors = [];

	function makeFillStyle(color, isTransparent) {
		var i = color * 3;
		if (isTransparent) {
			return "rgba(" + palette[i + 0] + "," + palette[i + 1] + "," + palette[i + 2] + ", 0)";
		}
		else {
			return "rgb(" + palette[i + 0] + "," + palette[i + 1] + "," + palette[i + 2] + ")";
		}
	}

	this._images = images;
	this._getPalette = function() {
		return palette;
	};

	// todo : do I really need to pass in size here?
	this.attachCanvas = function(c, size) {
		canvas = c;
		canvas.width = size * scale;
		canvas.height = size * scale;
		ctx = canvas.getContext("2d");
	};

	this.getCanvas = function() {
		return canvas;
	};

	this.getContext = function() {
		return ctx;
	};

	this.setScale = function(s) {
		scale = s;
	};

	this.setTextScale = function(s) {
		textScale = s;
	};

	this.getTextScale = function() {
		return textScale;
	};

	this.setPalette = function(p) {
		palette = p;
	};

	// todo : rename this since it doesn't always create a totally new canvas?
	this.createImage = function(id, width, height, pixels, useTextScale) {
		var imageScale = useTextScale === true ? textScale : scale;
		var widthScaled = width * imageScale;
		var heightScaled = height * imageScale;

		// try to use an existing image canvas if it is the right size,
		// instead of expensively creating a new one
		var imageCanvas = images[id];
		if (imageCanvas === undefined || imageCanvas.width != widthScaled || imageCanvas.height != heightScaled) {
			imageCanvas = document.createElement("canvas");
			imageCanvas.width = widthScaled;
			imageCanvas.height = heightScaled;
		}

		var imageCtx = imageCanvas.getContext("2d");

		// if we know the fill color for this image, we can speed things up
		// by filling the whole image with that color
		var fillColor;
		if (imageFillColors[id] != undefined) {
			fillColor = imageFillColors[id];
			var isTransparent = (fillColor === 0);
			if (isTransparent) {
				imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
			}
			else {
				imageCtx.fillStyle = makeFillStyle(fillColor, isTransparent);
				imageCtx.fillRect(0, 0, imageCanvas.width, imageCanvas.height);
			}
		}

		for (var i = 0; i < pixels.length; i++) {
			var x = i % width;
			var y = Math.floor(i / width);
			var color = pixels[i];
			if (color != fillColor) {
				var isTransparent = (color === 0);
				imageCtx.fillStyle = makeFillStyle(color, isTransparent);
				imageCtx.fillRect(x * imageScale, y * imageScale, imageScale, imageScale);
			}
		}

		images[id] = imageCanvas;
	};

	this.setImageFill = function(id, color) {
		imageFillColors[id] = color;
	};

	this.drawImage = function(id, x, y, destId) {
		if (!images[id]) {
			bitsyLog("image doesn't exist: " + id, "graphics");
			return;
		}

		var destCtx = ctx;
		if (destId != undefined) {
			// if there's a destination ID, that means we're drawing this image *onto* another image canvas
			var destCanvas = images[destId];
			destCtx = destCanvas.getContext("2d");
		}

		destCtx.drawImage(images[id], x * scale, y * scale, images[id].width, images[id].height);
	};

	this.hasImage = function(id) {
		return images[id] != undefined;
	};

	this.getImage = function(id) {
		return images[id];
	};

	this.deleteImage = function(id) {
		delete images[id];
		delete imageFillColors[id];
	};

	this.getCanvas = function() {
		return canvas;
	};

	this.clearCanvas = function(color) {
		bitsyLog("pal? " + palette.length + " / " + color, "graphics");
		ctx.fillStyle = makeFillStyle(color);
		ctx.fillRect(0, 0, canvas.width, canvas.height);
	};
}
</script>

<script>
/* LOGGING */
var DebugLogCategory = {
	// system
	input: false,
	sound: false,
	graphics: false,
	system: false,

	// engine
	bitsy: false,

	// editor
	editor: false,

	// tools
	room: false,
	tune: false,
	blip: false,
};

var isLoggingVerbose = false;

function bitsyLog(message, category) {
	if (!category) {
		category = "bitsy";
	}

	var summary = category + "::" + message;

	if (DebugLogCategory[category] === true) {
		if (isLoggingVerbose) {
			console.group(summary);

			console.dir(message);

			console.group("stack")
			console.trace();
			console.groupEnd();

			console.groupEnd();
		}
		else {
			console.log(summary);
		}
	}
}

/* GLOBALS */
var tilesize = 8;
var mapsize = 16;
var width = mapsize * tilesize;
var height = mapsize * tilesize;
var scale = 4;
var textScale = 2;

/* SYSTEM */
var updateInterval = null;
var prevTime = 0;
var deltaTime = 0;

function initSystem() {
	prevTime = Date.now();
	updateInterval = setInterval(updateSystem, 16);
}

function updateSystem() {
	var curTime = Date.now();
	deltaTime = curTime - prevTime;

	// update all active processes
	for (var i = 0; i < processes.length; i++) {
		bitsy = processes[i].system;
		if (bitsy._active) {
			bitsyLog(bitsy._name + " img count: " + bitsy._graphics._images.length, "system");
			var shouldContinue = bitsy._update(deltaTime);
			if (!shouldContinue) {
				// todo : do I really care about this _exit thing?
				if (bitsy._name != "bitsy") {
					bitsy._exit();
				}
			}
		}
	}

	bitsy = mainProcess.system;
	prevTime = curTime;
}

function loadGame(canvas, gameData, defaultFontData) {
	bitsyLog("load!", "system");
	// initialize bitsy system
	bitsy._attachCanvas(canvas);
	bitsy._write(bitsy._gameDataBlock, gameData);
	bitsy._write(bitsy._fontDataBlock, defaultFontData);
	bitsy._start();
}

function quitGame() {
	// hack to press the menu button to force game over state
	bitsy._injectPreLoop = function() { bitsy._poke(bitsy._buttonBlock, bitsy.BTN_MENU, 1); };

	// one last update to clean up (a little hacky to do this here?)
	bitsy._update(0);
	bitsy._exit();

	// clean up this gross hack
	bitsy._injectPreLoop = null;
}

/* GRAPHICS */
var canvas; // can I get rid of these?
var ctx;

function attachCanvas(c) {
	// hack : tes tnew system
	bitsy._attachCanvas(c);
	// extra hacky
	canvas = bitsy._getCanvas();
	ctx = bitsy._getContext();
}

/* PROCESSES */
var processes = [];

function addProcess(name) {
	var proc = {};
	proc.system = new BitsySystem(name);

	processes.push(proc);

	return proc;
}

/* == SYSTEM v0.2 === */
function BitsySystem(name) {
	var self = this;

	if (!name) {
		name = "bitsy";
	}

	// memory
	var memory = {
		blocks: [],
		changed: []
	};

	// input
	var input = new InputSystem();

	// sound
	var sound = new SoundSystem();
	var soundDurationIndex = 0;
	var soundFrequencyIndex = 1;
	var soundVolumeIndex = 2;
	var soundPulseIndex = 3;
	var maxVolume = 15;

	// graphics
	var graphics = new GraphicsSystem();
	graphics.setScale(scale);
	graphics.setTextScale(textScale);
	var initialPaletteSize = 64;
	var tilePoolStart = null;
	var tilePoolSize = 512;
	// hack!!! (access for debugging)
	this._graphics = graphics;

	function updateTextScale() {
		// make sure the text scale matches the text mode
		var textMode = self._peek(modeBlock, 1);
		var textModeScale = (textMode === self.TXT_LOREZ) ? scale : textScale;
		if (graphics.getTextScale() != textModeScale) {
			graphics.setTextScale(textModeScale);
			memory.changed[self.TEXTBOX] = true;
		}
	}

	function updateInput() {
		// update input flags
		self._poke(self._buttonBlock, self.BTN_UP,
			(input.isKeyDown(input.Key.UP) || input.isKeyDown(input.Key.W) || input.swipeUp()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_DOWN,
			(input.isKeyDown(input.Key.DOWN) || input.isKeyDown(input.Key.S) || input.swipeDown()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_LEFT,
			(input.isKeyDown(input.Key.LEFT) || input.isKeyDown(input.Key.A) || input.swipeLeft()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_RIGHT,
			(input.isKeyDown(input.Key.RIGHT) || input.isKeyDown(input.Key.D) || input.swipeRight()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_OK,
			(input.anyKeyDown() || input.isTapReleased()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_MENU,
			(input.isRestartComboPressed()) ? 1 : 0);

		input.resetTapReleased();
	}

	function updateSound(dt) {
		var changed0 = memory.changed[self.SOUND1];
		var changed1 = memory.changed[self.SOUND2];

		// update sound channel timers
		var timer0 = self._peek(self.SOUND1, soundDurationIndex);
		timer0 -= dt;
		if (timer0 <= 0) {
			timer0 = 0;
			if (self._peek(self.SOUND1, soundVolumeIndex) > 0) {
				self._poke(self.SOUND1, soundVolumeIndex, 0);
				changed0 = true;
			}
		}
		self._poke(self.SOUND1, soundDurationIndex, timer0);

		var timer1 = self._peek(self.SOUND2, soundDurationIndex);
		timer1 -= dt;
		if (timer1 <= 0) {
			timer1 = 0;
			if (self._peek(self.SOUND2, soundVolumeIndex) > 0) {
				self._poke(self.SOUND2, soundVolumeIndex, 0);
				changed1 = true;
			}
		}
		self._poke(self.SOUND2, soundDurationIndex, timer1);

		// send updated channel attributes to the sound system
		if (changed0) {
			sound.setPulse(0, self._peek(self.SOUND1, soundPulseIndex));

			var freq = self._peek(self.SOUND1, soundFrequencyIndex);
			var freqHz = freq / 100;
			sound.setFrequency(0, freqHz);

			var volume = self._peek(self.SOUND1, soundVolumeIndex);
			volume = Math.max(0, Math.min(volume, maxVolume));
			volumeNorm = (volume / maxVolume);
			sound.setVolume(0, volumeNorm);
		}

		if (changed1) {
			sound.setPulse(1, self._peek(self.SOUND2, soundPulseIndex));

			var freq = self._peek(self.SOUND2, soundFrequencyIndex);
			var freqHz = freq / 100;
			sound.setFrequency(1, freqHz);

			var volume = self._peek(self.SOUND2, soundVolumeIndex);
			volume = Math.max(0, Math.min(volume, maxVolume));
			volumeNorm = (volume / maxVolume);
			sound.setVolume(1, volumeNorm);
		}
	}

	function updateGraphics() {
		if (self._enableGraphics === false) {
			return;
		}

		bitsyLog("update graphics", "system");

		if (memory.changed[paletteBlock]) {
			graphics.setPalette(self._dump()[paletteBlock]);
		}

		if (tilePoolStart != null) {
			for (var i = 0; i < tilePoolSize; i++) {
				var tile = tilePoolStart + i;
				if (memory.blocks[tile] != undefined && memory.changed[tile]) {
					bitsyLog("tile changed? " + tile, "system");
					// update tile image
					graphics.createImage(tile, self.TILE_SIZE, self.TILE_SIZE, self._dump()[tile]);
				}
			}
		}

		var textboxChanged = memory.changed[self.TEXTBOX] || memory.changed[textboxAttributeBlock];
		if (textboxChanged) {
			// todo : should this be optimized in some way?
			// update textbox image
			var w = self._peek(textboxAttributeBlock, 3); // todo : need a variable to store this index?
			var h = self._peek(textboxAttributeBlock, 4);
			if (w > 0 && h > 0) {
				bitsyLog("textbox changed! " + memory.changed[self.TEXTBOX] + " " + memory.changed[textboxAttributeBlock] + " " + w + " " + h, "system");
				var useTextBoxScale = true; // todo : check mode here?
				graphics.createImage(self.TEXTBOX, w, h, self._dump()[self.TEXTBOX], useTextBoxScale);
			}
		}

		var mode = self._peek(modeBlock, 0);
		if (mode === self.GFX_VIDEO) {
			if (memory.changed[self.VIDEO]) {
				graphics.clearCanvas(0);
				// update screen image
				graphics.createImage(self.VIDEO, self.VIDEO_SIZE, self.VIDEO_SIZE, self._dump()[self.VIDEO]);
				// render screen onto canvas
				graphics.drawImage(self.VIDEO, 0, 0);
			}
		}
		else if (mode === self.GFX_MAP) {
			// redraw any changed layers
			var layers = self._getTileMapLayers();
			var anyMapLayerChanged = false;
			for (var i = 0; i < layers.length; i++) {
				var layerId = layers[i];
				if (memory.changed[layerId]) {
					// need to redraw this map layer
					anyMapLayerChanged = true;
					// clear layer canvas
					graphics.setImageFill(layerId, 0); // fill transparent
					graphics.createImage(layerId, self.VIDEO_SIZE, self.VIDEO_SIZE, []);
					// render tiles onto layer canvas
					var layerData = self._dump()[layerId];
					for (var ty = 0; ty < self.MAP_SIZE; ty++) {
						for (var tx = 0; tx < self.MAP_SIZE; tx++) {
							var tileIndex = (ty * self.MAP_SIZE) + tx;
							var tile = layerData[tileIndex];
							if (tile > 0) {
								graphics.drawImage(tile, tx * self.TILE_SIZE, ty * self.TILE_SIZE, layerId);
							}
						}
					}
				}
			}

			// redraw the main canvas
			if (textboxChanged || anyMapLayerChanged) {
				bitsyLog("map changed? " + memory.changed[self.MAP1] + " " + memory.changed[self.MAP2], "system");
				graphics.clearCanvas(0);

				for (var i = 0; i < layers.length; i++) {
					var layerId = layers[i];
					// draw the layer's image canvas onto the main canvas
					graphics.drawImage(layerId, 0, 0);
				}

				// draw textbox onto canvas
				var visible = self._peek(textboxAttributeBlock, 0)
				var x = self._peek(textboxAttributeBlock, 1);
				var y = self._peek(textboxAttributeBlock, 2);
				var w = self._peek(textboxAttributeBlock, 3);
				var h = self._peek(textboxAttributeBlock, 4);
				if (visible > 0 && w > 0 && h > 0) {
					graphics.drawImage(self.TEXTBOX, x, y);
				}
			}
		}
	}

	/* == PRIVATE / DEBUG == */
	this._name = name;

	this._active = false;

	this._attachCanvas = function(c) {
		graphics.attachCanvas(c, self.VIDEO_SIZE);
	};

	this._getCanvas = graphics.getCanvas;
	this._getContext = graphics.getContext;

	this._start = function() {
		input.listen(graphics.getCanvas());
		updateTextScale();
		self._active = true;
	};

	// hacky...
	this._startNoInput = function() {
		updateTextScale();
		self._active = true;
	};

	this._exit = function() {
		// disable graphics
		var canvas = graphics.getCanvas();
		if (canvas) {
			input.unlisten(canvas);	
		}

		// disable sound
		sound.mute();

		self._active = false;
	};

	// hacky....
	this._injectPreLoop = null;
	this._injectPostDraw = null;

	this._update = function(dt) {
		var shouldContinue = false;

		updateInput();

		// too hacky???
		if (self._injectPreLoop) {
			self._injectPreLoop();
		}

		// run main loop
		if (onLoopFunction) {
			shouldContinue = onLoopFunction(dt);
		}

		if (memory.changed[modeBlock]) {
			updateTextScale();
		}

		// update output systems
		updateSound(dt);
		updateGraphics();

		if (self._injectPostDraw) {
			self._injectPostDraw();
		}

		// reset memory block changed flags
		for (var i = 0; i < memory.changed.length; i++) {
			memory.changed[i] = false;
		}

		// todo : should the _exit() call go in here?

		return shouldContinue;
	};

	this._updateGraphics = updateGraphics;

	this._allocate = function(args) {
		// find next available block in range
		var next = (args && args.start) ? args.start : 0;
		var count = (args && args.max) ? args.max : -1;
		while (memory.blocks[next] != undefined && count != 0) {
			next++;
			count--;
		}

		if (count == 0) {
			// couldn't find any available block
			return null;
		}

		if (args && args.str) {
			memory.blocks[next] = args.str;
		}
		else {
			var size = args && args.size ? args.size : 0;
			memory.blocks[next] = [];
			for (var i = 0; i < size; i++) {
				memory.blocks[next].push(0);
			}
		}

		memory.changed[next] = false;

		return next;
	};

	this._free = function(block) {
		delete memory.blocks[block];
		delete memory.changed[block];
	};

	this._peek = function(block, index) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			return memoryBlock.charCodeAt(index);
		}
		else {
			return memoryBlock[index];
		}
	};

	this._poke = function(block, index, value) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			memory.blocks[block] = memoryBlock.substring(0, index) + String.fromCharCode(value) + memoryBlock.substring(index + 1);
		}
		else {
			var value = parseInt(value);
			if (!isNaN(value)) {
				memoryBlock[index] = value;
			}
		}
		memory.changed[block] = true;
	};

	this._read = function(block) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			return memoryBlock;
		}
		else {
			var str = "";
			for (var i = 0; i < memoryBlock.length; i++) {
				str += String.fromCharCode(memoryBlock[i]);
			}
			return str;
		}
	};

	this._write = function(block, str) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			memory.blocks[block] = str;
		}
		else {
			memory.blocks[block] = [];
			for (var i = 0; i < str.length; i++) {
				memory.blocks[block][i] = str.charCodeAt(i);
			}
		}
		memory.changed[block] = true;
	};

	this._dump = function() {
		return memory.blocks;
	};

	// convenience methods for hacking around with map layers
	var tileMapLayers = [];
	this._getTileMapLayers = function() {
		return tileMapLayers;
	};
	this._addTileMapLayer = function() {
		var layer = self._allocate({
			start: (tilePoolStart + tilePoolSize),
			size: (self.MAP_SIZE * self.MAP_SIZE)
		});

		tileMapLayers.push(layer);

		return layer;
	};

	/* == CONSTANTS == */
	// memory blocks (these will be initialized below)
	this.VIDEO;
	this.TEXTBOX;
	this.MAP1;
	this.MAP2;
	this.SOUND1;
	this.SOUND2;

	// graphics modes
	this.GFX_VIDEO = 0;
	this.GFX_MAP = 1;

	// text modes
	this.TXT_HIREZ = 0; // 2x resolution
	this.TXT_LOREZ = 1; // 1x resolution

	// size
	this.TILE_SIZE = tilesize;
	this.MAP_SIZE = mapsize;
	this.VIDEO_SIZE = width;
	// todo : should text scale have a constant?

	// button codes
	this.BTN_UP = 0;
	this.BTN_DOWN = 1;
	this.BTN_LEFT = 2;
	this.BTN_RIGHT = 3;
	this.BTN_OK = 4;
	this.BTN_MENU = 5;

	// pulse waves
	this.PULSE_1_8 = 0;
	this.PULSE_1_4 = 1;
	this.PULSE_1_2 = 2;

	/* == IO == */
	this.log = function(message) {
		bitsyLog(message, name);
	};

	this.button = function(code) {
		return self._peek(buttonBlock, code) > 0;
	};

	this.getGameData = function() {
		return self._read(gameDataBlock);
	};

	this.getFontData = function() {
		return self._read(fontDataBlock);
	};

	/* == GRAPHICS == */
	this.graphicsMode = function(mode) {
		// todo : store the mode flag indices somewhere?
		if (mode != undefined) {
			self._poke(modeBlock, 0, mode);
		}

		return self._peek(modeBlock, 0);
	};

	this.textMode = function(mode) {
		// todo : test whether the requested mode is supported!
		if (mode != undefined) {
			self._poke(modeBlock, 1, mode);
		}

		return self._peek(modeBlock, 1);
	};

	this.color = function(color, r, g, b) {
		self._poke(paletteBlock, (color * 3) + 0, r);
		self._poke(paletteBlock, (color * 3) + 1, g);
		self._poke(paletteBlock, (color * 3) + 2, b);

		// mark all graphics as changed
		memory.changed[self.VIDEO] = true;
		memory.changed[self.TEXTBOX] = true;
		memory.changed[self.MAP1] = true;
		memory.changed[self.MAP2] = true;

		if (tilePoolStart != null) {
			for (var i = 0; i < tilePoolSize; i++) {
				if (memory.blocks[tilePoolStart + i] != undefined) {
					memory.changed[tilePoolStart + i] = true;
				}
			}
		}
	};

	this.tile = function() {
		return self._allocate({
			start: tilePoolStart,
			max: tilePoolSize,
			size: (self.TILE_SIZE * self.TILE_SIZE)
		});
	};

	this.delete = function(tile) {
		if (graphics.hasImage(tile)) {
			graphics.deleteImage(tile);
		}

		self._free(tile);
	};

	this.fill = function(block, value) {
		var len = memory.blocks[block].length;
		for (var i = 0; i < len; i++) {
			self._poke(block, i, value);
		}

		var isImage = (block === self.VIDEO) ||
			(block === self.TEXTBOX) ||
			(block >= tilePoolStart && block < (tilePoolStart + tilePoolSize));

		// optimize rendering by notifying the graphics system what the fill color is for this image
		if (isImage) {
			graphics.setImageFill(block, value);
		}
	};

	this.set = function(block, index, value) {
		self._poke(block, index, value);
	};

	this.textbox = function(visible, x, y, w, h) {
		if (visible != undefined) {
			self._poke(textboxAttributeBlock, 0, (visible === true) ? 1 : 0);
		}
		
		if (x != undefined) {
			self._poke(textboxAttributeBlock, 1, x);
		}
		
		if (y != undefined) {
			self._poke(textboxAttributeBlock, 2, y);
		}

		var prevWidth = self._peek(textboxAttributeBlock, 3);
		var prevHeight = self._peek(textboxAttributeBlock, 4);

		if (w != undefined) {
			self._poke(textboxAttributeBlock, 3, w);
		}
		
		if (h != undefined) {
			self._poke(textboxAttributeBlock, 4, h);
		}

		if (w != undefined && h != undefined && (prevWidth != w || prevHeight != h)) {
			// re-allocate the textbox block (should I have a helper function for this?)
			memory.blocks[self.TEXTBOX] = [];
			for (var i = 0; i < (w * h); i++) {
				memory.blocks[self.TEXTBOX].push(0);
			}
			memory.changed[self.TEXTBOX] = true;
		}
	};

	/* == SOUND == */
	// duration is in milliseconds (ms)
	this.sound = function(channel, duration, frequency, volume, pulse) {
		self._poke(channel, soundDurationIndex, duration);
		self._poke(channel, soundFrequencyIndex, frequency);
		self._poke(channel, soundVolumeIndex, volume);
		self._poke(channel, soundPulseIndex, pulse);
	};

	// frequency is in decihertz (dHz)
	this.frequency = function(channel, frequency) {
		self._poke(channel, soundFrequencyIndex, frequency);
	};

	// volume: min = 0, max = 15
	this.volume = function(channel, volume) {
		self._poke(channel, soundVolumeIndex, volume);
	};

	/* == EVENTS == */
	this.loop = function(fn) {
		onLoopFunction = fn;
	};

	/* == INTERNAL == */
	// initialize memory blocks
	var gameDataBlock = this._allocate({ str: "" });
	var fontDataBlock = this._allocate({ str: "" });
	this.VIDEO = this._allocate({ size: self.VIDEO_SIZE * self.VIDEO_SIZE });
	this.TEXTBOX = this._allocate();
	this.MAP1 = this._allocate({ size: self.MAP_SIZE * self.MAP_SIZE });
	tileMapLayers.push(this.MAP1);
	this.MAP2 = this._allocate({ size: self.MAP_SIZE * self.MAP_SIZE });
	tileMapLayers.push(this.MAP2);
	var paletteBlock = this._allocate({ size: initialPaletteSize * 3 });
	var buttonBlock = this._allocate({ size: 8 });
	this.SOUND1 = this._allocate({ size: 4 });
	this.SOUND2 = this._allocate({ size: 4 });
	var modeBlock = this._allocate({ size: 8 });
	var textboxAttributeBlock = this._allocate({ size: 8 });

	tilePoolStart = (textboxAttributeBlock + 1);

	// access for debugging
	this._gameDataBlock = gameDataBlock;
	this._fontDataBlock = fontDataBlock;
	this._buttonBlock = buttonBlock;

	// events
	var onLoopFunction = null;
}

var mainProcess = addProcess();
var bitsy = mainProcess.system;
</script>

<!-- engine -->
<script>
/* BITSY VERSION */
// is this the right place for this to live?
var version = {
	major: 8, // major changes
	minor: 12, // smaller changes
	devBuildPhase: "RELEASE",
};
function getEngineVersion() {
	return version.major + "." + version.minor;
}

/* TEXT CONSTANTS */
var titleDialogId = "title";

// todo : where should this be stored?
var tileColorStartIndex = 16;

var TextDirection = {
	LeftToRight : "LTR",
	RightToLeft : "RTL"
};

var defaultFontName = "ascii_small";

/* TUNE CONSTANTS */
var barLength = 16; // sixteenth notes
var minTuneLength = 1;
var maxTuneLength = 16;

// chromatic notes
var Note = {
	NONE 		: -1,
	C 			: 0,	// C
	C_SHARP 	: 1,	// C sharp / D flat
	D 			: 2,	// D
	D_SHARP 	: 3,	// D sharp / E flat
	E 			: 4,	// E
	F 			: 5,	// F
	F_SHARP 	: 6,	// F sharp / G flat
	G 			: 7,	// G
	G_SHARP 	: 8,	// G sharp / A flat
	A 			: 9,	// A
	A_SHARP 	: 10,	// A sharp / B flat
	B 			: 11,	// B
	COUNT 		: 12
};

// solfa notes
var Solfa = {
	NONE 	: -1,
	D 		: 0,	// Do
	R 		: 1,	// Re
	M 		: 2,	// Mi
	F 		: 3,	// Fa
	S 		: 4,	// Sol
	L 		: 5,	// La
	T 		: 6,	// Ti
	COUNT 	: 7
};

var Octave = {
	NONE: -1,
	2: 0,
	3: 1,
	4: 2, // octave 4: middle C octave
	5: 3,
	COUNT: 4
};

var Tempo = {
	SLW: 0, // slow
	MED: 1, // medium
	FST: 2, // fast
	XFST: 3 // extra fast (aka turbo)
};

var SquareWave = {
	P8: 0, // pulse 1 / 8
	P4: 1, // pulse 1 / 4
	P2: 2, // pulse 1 / 2
	COUNT: 3
};

var ArpeggioPattern = {
	OFF: 0,
	UP: 1, // ascending triad chord
	DWN: 2, // descending triad chord
	INT5: 3, // 5 step interval
	INT8: 4 // 8 setp interval
};

function createWorldData() {
	return {
		room : {},
		tile : {},
		sprite : {},
		item : {},
		dialog : {},
		end : {}, // pre-7.0 ending data for backwards compatibility
		palette : { // start off with a default palette
			"default" : {
				name : "default",
				colors : [[0,0,0],[255,255,255],[255,255,255]]
			}
		},
		variable : {},
		tune : {},
		blip : {},
		versionNumberFromComment : -1, // -1 indicates no version information found
		fontName : defaultFontName,
		textDirection : TextDirection.LeftToRight,
		flags : createDefaultFlags(),
		names : {},
		// source data for all drawings (todo: better name?)
		drawings : {},
	};
}

// creates a drawing data structure with default property values for the type
function createDrawingData(type, id) {
	// the avatar's drawing id still uses the sprite prefix (for back compat)
	var drwId = (type === "AVA" ? "SPR" : type) + "_" + id;

	var drawingData = {
		type : type,
		id : id,
		name : null,
		drw : drwId,
		col : (type === "TIL") ? 1 : 2, // foreground color
		bgc : 0, // background color
		animation : {
			isAnimated : false,
			frameIndex : 0,
			frameCount : 1,
		},
	};

	// add type specific properties
	if (type === "TIL") {
		// default null value indicates it can vary from room to room (original version)
		drawingData.isWall = null;
	}

	if (type === "AVA" || type === "SPR") {
		// default sprite location is "offstage"
		drawingData.room = null;
		drawingData.x = -1;
		drawingData.y = -1;
		drawingData.inventory = {};
	}

	if (type === "AVA" || type === "SPR" || type === "ITM") {
		drawingData.dlg = null;
		drawingData.blip = null;
	}

	return drawingData;
}

function createTuneData(id) {
	var tuneData = {
		id : id,
		name : null,
		melody : [],
		harmony : [],
		key: null, // a null key indicates a chromatic scale (all notes enabled)
		tempo: Tempo.MED,
		instrumentA : SquareWave.P2,
		instrumentB : SquareWave.P2,
		arpeggioPattern : ArpeggioPattern.OFF,
	};
	return tuneData;
}

function createTuneBarData() {
	var bar = [];
	for (var i = 0; i < barLength; i++) {
		bar.push({ beats: 0, note: Note.C, octave: Octave[4] });
	}
	return bar;
}

function createTuneKeyData() {
	var key = {
		notes: [], // mapping of the solfa scale degrees to chromatic notes
		scale: []  // list of solfa notes that are enabled for this key
	};

	// initialize notes
	for (var i = 0; i < Solfa.COUNT; i++) {
		key.notes.push(Note.NONE);
	}

	return key;
}

function createBlipData(id) {
	var blipData = {
		id: id,
		name: null,
		pitchA: { beats: 0, note: Note.C, octave: Octave[4] },
		pitchB: { beats: 0, note: Note.C, octave: Octave[4] },
		pitchC: { beats: 0, note: Note.C, octave: Octave[4] },
		envelope: {
			attack: 0, // attack time in ms
			decay: 0, // decay time in ms
			sustain: 0, // sustain volume
			length: 0, // sustain time in ms
			release: 0 // release time in ms
		},
		beat : {
			time: 0, // time in ms between pitch changes
			delay: 0 // time in ms *before* first pitch change
		},
		instrument: SquareWave.P2,
		doRepeat: false
		// TODO : consider for future update
		// doSlide: false,
	};

	return blipData;
}

function createDefaultFlags() {
	return {
		// version
		VER_MAJ: -1, // major version number (-1 = no version information found)
		VER_MIN: -1, // minor version number (-1 = no version information found)
		// compatibility
		ROOM_FORMAT: 0, // 0 = non-comma separated (original), 1 = comma separated (default)
		DLG_COMPAT: 0, // 0 = default dialog behavior, 1 = pre-7.0 dialog behavior
		// config
		TXT_MODE: 0 // 0 = HIREZ (2x - default), 1 = LOREZ (1x)
	};
}

function createDialogData(id) {
	return {
		src : "",
		name : null,
		id : id,
	};
}

function parseWorld(file) {
	bitsy.log("create world data");

	var world = createWorldData();

	bitsy.log("init parse state");

	var parseState = {
		lines : file.split("\n"),
		index : 0,
		spriteStartLocations : {}
	};

	bitsy.log("start reading lines");

	while (parseState.index < parseState.lines.length) {
		var i = parseState.index;
		var lines = parseState.lines;
		var curLine = lines[i];

		// bitsy.log("LN " + i + " xx " + curLine);

		if (i == 0) {
			i = parseTitle(parseState, world);
		}
		else if (curLine.length <= 0 || curLine.charAt(0) === "#") {
			// collect version number from a comment (hacky but required for pre-8.0 compatibility)
			if (curLine.indexOf("# BITSY VERSION ") != -1) {
				world.versionNumberFromComment = parseFloat(curLine.replace("# BITSY VERSION ", ""));
			}

			//skip blank lines & comments
			i++;
		}
		else if (getType(curLine) === "PAL") {
			i = parsePalette(parseState, world);
		}
		else if (getType(curLine) === "ROOM" || getType(curLine) === "SET") { // SET for back compat
			i = parseRoom(parseState, world);
		}
		else if (getType(curLine) === "TIL") {
			i = parseTile(parseState, world);
		}
		else if (getType(curLine) === "SPR") {
			i = parseSprite(parseState, world);
		}
		else if (getType(curLine) === "ITM") {
			i = parseItem(parseState, world);
		}
		else if (getType(curLine) === "DLG") {
			i = parseDialog(parseState, world);
		}
		else if (getType(curLine) === "END") {
			// parse endings for back compat
			i = parseEnding(parseState, world);
		}
		else if (getType(curLine) === "VAR") {
			i = parseVariable(parseState, world);
		}
		else if (getType(curLine) === "DEFAULT_FONT") {
			i = parseFontName(parseState, world);
		}
		else if (getType(curLine) === "TEXT_DIRECTION") {
			i = parseTextDirection(parseState, world);
		}
		else if (getType(curLine) === "FONT") {
			i = parseFontData(parseState, world);
		}
		else if (getType(curLine) === "TUNE") {
			i = parseTune(parseState, world);
		}
		else if (getType(curLine) === "BLIP") {
			i = parseBlip(parseState, world);
		}
		else if (getType(curLine) === "!") {
			i = parseFlag(parseState, world);
		}
		else {
			i++;
		}

		parseState.index = i;
	}

	world.names = createNameMapsForWorld(world);

	placeSprites(parseState, world);

	if ((world.flags.VER_MAJ <= -1 || world.flags.VER_MIN <= -1) && world.versionNumberFromComment > -1) {
		var versionNumberStr = "" + world.versionNumberFromComment;
		versionNumberStr = versionNumberStr.split(".");
		world.flags.VER_MAJ = parseFloat(versionNumberStr[0]);
		world.flags.VER_MIN = parseFloat(versionNumberStr[1]);
	}

	// starting in version v7.0, there were two major changes to dialog behavior:
	// 1) sprite dialog was no longer implicitly linked by the sprite and dialog IDs matching
	//    (see this commit: 5e1adb29faad4e50603c689d2dac143074117b4e)
	// 2) ending dialogs no longer had their own world data type ("END")
	// for the v7.x versions I tried to automatically convert old dialog to the new format,
	// however, that process can be unreliable and lead to weird bugs.
	// with v8.0 and above I will no longer attempt to convert old files, and instead will use
	// a flag to indicate files that need to use the backwards compatible behavior -
	// this is more reliable & configurable (at the cost of making pre-7.0 games a bit harder to edit)
	if (world.flags.VER_MAJ < 7) {
		world.flags.DLG_COMPAT = 1;
	}

	return world;
}

function parseTitle(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var results;
	if (scriptUtils) {
		results = scriptUtils.ReadDialogScript(lines,i);
	}
	else {
		results = { script: lines[i], index: (i + 1) };
	}

	world.dialog[titleDialogId] = createDialogData(titleDialogId);
	world.dialog[titleDialogId].src = results.script;

	i = results.index;
	i++;

	return i;
}

function parsePalette(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	i++;
	var colors = [];
	var name = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		var args = lines[i].split(" ");
		if (args[0] === "NAME") {
			name = lines[i].split(/\s(.+)/)[1];
		}
		else {
			var col = [];
			lines[i].split(",").forEach(function(i) {
				col.push(parseInt(i));
			});
			colors.push(col);
		}
		i++;
	}
	world.palette[id] = {
		id : id,
		name : name,
		colors : colors
	};
	return i;
}

function createRoomData(id) {
	return {
		id: id,
		name: null,
		tilemap: [],
		walls: [],
		exits: [],
		endings: [],
		items: [],
		pal: null,
		ava: null,
		tune: "0"
	};
}

function createExitData(x, y, destRoom, destX, destY, transition, dlg) {
	return {
		x: x,
		y: y,
		dest: {
			room: destRoom,
			x: destX,
			y: destY
		},
		transition_effect: transition,
		dlg: dlg,
	};
}

function createEndingData(id, x, y) {
	return {
		id: id,
		x: x,
		y: y
	};
}

function parseRoom(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	var id = getId(lines[i]);

	var roomData = createRoomData(id);

	i++;

	// create tile map
	if (world.flags.ROOM_FORMAT === 0) {
		// old way: no commas, single char tile ids
		var end = i + bitsy.MAP_SIZE;
		var y = 0;
		for (; i < end; i++) {
			roomData.tilemap.push([]);
			for (x = 0; x < bitsy.MAP_SIZE; x++) {
				roomData.tilemap[y].push(lines[i].charAt(x));
			}
			y++;
		}
	}
	else if (world.flags.ROOM_FORMAT === 1) {
		// new way: comma separated, multiple char tile ids
		var end = i + bitsy.MAP_SIZE;
		var y = 0;
		for (; i < end; i++) {
			roomData.tilemap.push([]);
			var lineSep = lines[i].split(",");
			for (x = 0; x < bitsy.MAP_SIZE; x++) {
				roomData.tilemap[y].push(lineSep[x]);
			}
			y++;
		}
	}

	while (i < lines.length && lines[i].length > 0) { //look for empty line
		// bitsy.log(getType(lines[i]));
		if (getType(lines[i]) === "SPR") {
			/* NOTE SPRITE START LOCATIONS */
			var sprId = getId(lines[i]);
			if (sprId.indexOf(",") == -1 && lines[i].split(" ").length >= 3) { //second conditional checks for coords
				/* PLACE A SINGLE SPRITE */
				var sprCoord = lines[i].split(" ")[2].split(",");
				parseState.spriteStartLocations[sprId] = {
					room : id,
					x : parseInt(sprCoord[0]),
					y : parseInt(sprCoord[1])
				};
			}
			else if ( world.flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format
				/* PLACE MULTIPLE SPRITES*/ 
				//Does find and replace in the tilemap (may be hacky, but its convenient)
				var sprList = sprId.split(",");
				for (row in roomData.tilemap) {
					for (s in sprList) {
						var col = roomData.tilemap[row].indexOf( sprList[s] );
						//if the sprite is in this row, replace it with the "null tile" and set its starting position
						if (col != -1) {
							roomData.tilemap[row][col] = "0";
							parseState.spriteStartLocations[ sprList[s] ] = {
								room : id,
								x : parseInt(col),
								y : parseInt(row)
							};
						}
					}
				}
			}
		}
		else if (getType(lines[i]) === "ITM") {
			var itmId = getId(lines[i]);
			var itmCoord = lines[i].split(" ")[2].split(",");
			var itm = {
				id: itmId,
				x : parseInt(itmCoord[0]),
				y : parseInt(itmCoord[1])
			};
			roomData.items.push( itm );
		}
		else if (getType(lines[i]) === "WAL") {
			/* DEFINE COLLISIONS (WALLS) */
			roomData.walls = getId(lines[i]).split(",");
		}
		else if (getType(lines[i]) === "EXT") {
			/* ADD EXIT */
			var exitArgs = lines[i].split(" ");
			//arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]
			var exitCoords = exitArgs[1].split(",");
			var destName = exitArgs[2];
			var destCoords = exitArgs[3].split(",");
			var ext = createExitData(
				/* x 			*/ parseInt(exitCoords[0]),
				/* y 			*/ parseInt(exitCoords[1]),
				/* destRoom 	*/ destName,
				/* destX 		*/ parseInt(destCoords[0]),
				/* destY 		*/ parseInt(destCoords[1]),
				/* transition 	*/ null,
				/* dlg 			*/ null);

			// optional arguments
			var exitArgIndex = 4;
			while (exitArgIndex < exitArgs.length) {
				if (exitArgs[exitArgIndex] == "FX") {
					ext.transition_effect = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else if (exitArgs[exitArgIndex] == "DLG") {
					ext.dlg = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else {
					exitArgIndex += 1;
				}
			}

			roomData.exits.push(ext);
		}
		else if (getType(lines[i]) === "END") {
			/* ADD ENDING */
			var endId = getId(lines[i]);

			var endCoords = getCoord(lines[i], 2);
			var end = createEndingData(
				/* id */ endId,
				/* x */ parseInt(endCoords[0]),
				/* y */ parseInt(endCoords[1]));

			roomData.endings.push(end);
		}
		else if (getType(lines[i]) === "PAL") {
			/* CHOOSE PALETTE (that's not default) */
			roomData.pal = getId(lines[i]);
		}
		else if (getType(lines[i]) === "AVA") {
			// change avatar appearance per room
			roomData.ava = getId(lines[i]);
		}
		else if (getType(lines[i]) === "TUNE") {
			roomData.tune = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			roomData.name = getNameArg(lines[i]);
		}

		i++;
	}

	world.room[id] = roomData;

	return i;
}

function parseTile(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	var tileData = createDrawingData("TIL", id);

	i++;

	// read & store tile image source
	i = parseDrawingCore(lines, i, tileData.drw, world);

	// update animation info
	tileData.animation.frameCount = getDrawingFrameCount(world, tileData.drw);
	tileData.animation.isAnimated = tileData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			tileData.col = parseInt(getId(lines[i]));
		}
		else if (getType(lines[i]) === "BGC") {
			var bgcId = getId(lines[i]);
			if (bgcId === "*") {
				// transparent background
				tileData.bgc = (-1 * tileColorStartIndex);
			}
			else {
				tileData.bgc = parseInt(bgcId);
			}
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			tileData.name = getNameArg(lines[i]);
		}
		else if (getType(lines[i]) === "WAL") {
			var wallArg = getArg(lines[i], 1);
			if (wallArg === "true") {
				tileData.isWall = true;
			}
			else if (wallArg === "false") {
				tileData.isWall = false;
			}
		}

		i++;
	}

	// store tile data
	world.tile[id] = tileData;

	return i;
}

function parseSprite(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	var type = (id === "A") ? "AVA" : "SPR";
	var spriteData = createDrawingData(type, id);

	// bitsy.log(spriteData);

	i++;

	// read & store sprite image source
	i = parseDrawingCore(lines, i, spriteData.drw, world);

	// update animation info
	spriteData.animation.frameCount = getDrawingFrameCount(world, spriteData.drw);
	spriteData.animation.isAnimated = spriteData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			spriteData.col = parseInt(getId(lines[i]));
		}
		else if (getType(lines[i]) === "BGC") {
			/* BACKGROUND COLOR */
			var bgcId = getId(lines[i]);
			if (bgcId === "*") {
				// transparent background
				spriteData.bgc = (-1 * tileColorStartIndex);
			}
			else {
				spriteData.bgc = parseInt(bgcId);
			}
		}
		else if (getType(lines[i]) === "POS") {
			/* STARTING POSITION */
			var posArgs = lines[i].split(" ");
			var roomId = posArgs[1];
			var coordArgs = posArgs[2].split(",");
			parseState.spriteStartLocations[id] = {
				room : roomId,
				x : parseInt(coordArgs[0]),
				y : parseInt(coordArgs[1])
			};
		}
		else if(getType(lines[i]) === "DLG") {
			spriteData.dlg = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			spriteData.name = getNameArg(lines[i]);
		}
		else if (getType(lines[i]) === "ITM") {
			/* ITEM STARTING INVENTORY */
			var itemId = getId(lines[i]);
			var itemCount = parseFloat(getArg(lines[i], 2));
			spriteData.inventory[itemId] = itemCount;
		}
		else if (getType(lines[i]) == "BLIP") {
			var blipId = getId(lines[i]);
			spriteData.blip = blipId;
		}

		i++;
	}

	// store sprite data
	world.sprite[id] = spriteData;

	return i;
}

function parseItem(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	var itemData = createDrawingData("ITM", id);

	i++;

	// read & store item image source
	i = parseDrawingCore(lines, i, itemData.drw, world);

	// update animation info
	itemData.animation.frameCount = getDrawingFrameCount(world, itemData.drw);
	itemData.animation.isAnimated = itemData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			itemData.col = parseInt(getArg(lines[i], 1));
		}
		else if (getType(lines[i]) === "BGC") {
			/* BACKGROUND COLOR */
			var bgcId = getId(lines[i]);
			if (bgcId === "*") {
				// transparent background
				itemData.bgc = (-1 * tileColorStartIndex);
			}
			else {
				itemData.bgc = parseInt(bgcId);
			}
		}
		else if (getType(lines[i]) === "DLG") {
			itemData.dlg = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			itemData.name = getNameArg(lines[i]);
		}
		else if (getType(lines[i]) == "BLIP") {
			var blipId = getId(lines[i]);
			itemData.blip = blipId;
		}

		i++;
	}

	// store item data
	world.item[id] = itemData;

	return i;
}

function parseDrawingCore(lines, i, drwId, world) {
	var frameList = []; //init list of frames
	frameList.push( [] ); //init first frame
	var frameIndex = 0;
	var y = 0;
	while (y < bitsy.TILE_SIZE) {
		var line = lines[i + y];
		var row = [];

		for (x = 0; x < bitsy.TILE_SIZE; x++) {
			row.push(parseInt(line.charAt(x)));
		}

		frameList[frameIndex].push(row);
		y++;

		if (y === bitsy.TILE_SIZE) {
			i = i + y;
			if (lines[i] != undefined && lines[i].charAt(0) === ">") {
				// start next frame!
				frameList.push([]);
				frameIndex++;

				//start the count over again for the next frame
				i++;
				y = 0;
			}
		}
	}

	storeDrawingData(world, drwId, frameList);

	return i;
}

function parseDialog(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	// hacky but I need to store this so I can set the name below
	var id = getId(lines[i]);

	i = parseScript(lines, i, world.dialog);

	if (i < lines.length && lines[i].length > 0 && getType(lines[i]) === "NAME") {
		world.dialog[id].name = getNameArg(lines[i]);
		i++;
	}

	return i;
}

// keeping this around to parse old files where endings were separate from dialogs
function parseEnding(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	return parseScript(lines, i, world.end);
}

function parseScript(lines, i, data) {
	var id = getId(lines[i]);
	i++;

	var results;
	if (scriptUtils) {
		results = scriptUtils.ReadDialogScript(lines,i);
	}
	else {
		results = { script: lines[i], index: (i + 1)};
	}

	data[id] = createDialogData(id);
	data[id].src = results.script;

	i = results.index;

	return i;
}

function parseVariable(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	var id = getId(lines[i]);
	i++;
	var value = lines[i];
	i++;
	world.variable[id] = value;
	return i;
}

function parseFontName(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	world.fontName = getArg(lines[i], 1);
	i++;
	return i;
}

function parseTextDirection(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	world.textDirection = getArg(lines[i], 1);
	i++;
	return i;
}

function parseFontData(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	// NOTE : we're not doing the actual parsing here --
	// just grabbing the block of text that represents the font
	// and giving it to the font manager to use later

	var localFontName = getId(lines[i]);
	var localFontData = lines[i];
	i++;

	while (i < lines.length && lines[i] != "") {
		localFontData += "\n" + lines[i];
		i++;
	}

	var localFontFilename = localFontName + fontManager.GetExtension();
	fontManager.AddResource( localFontFilename, localFontData );

	return i;
}

function parseTune(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	i++;

	var tuneData = createTuneData(id);

	var barIndex = 0;
	while (barIndex < maxTuneLength) {
		// MELODY
		var melodyBar = createTuneBarData();
		var melodyNotes = lines[i].split(",");
		for (var j = 0; j < barLength; j++) {
			// default to a rest
			var pitch = { beats: 0, note: Note.C, octave: Octave[4], };

			if (j < melodyNotes.length) {
				var pitchSplit = melodyNotes[j].split("~");
				var pitchStr = pitchSplit[0];
				pitch = parsePitch(melodyNotes[j]);

				// look for effect added to the note
				if (pitchSplit.length > 1) {
					var blipId = pitchSplit[1];
					pitch.blip = blipId;
				}
			}

			melodyBar[j] = pitch;
		}
		tuneData.melody.push(melodyBar);
		i++;

		// HARMONY
		var harmonyBar = createTuneBarData();
		var harmonyNotes = lines[i].split(",");
		for (var j = 0; j < barLength; j++) {
			// default to a rest
			var pitch = { beats: 0, note: Note.C, octave: Octave[4], };

			if (j < harmonyNotes.length) {
				var pitchSplit = harmonyNotes[j].split("~");
				var pitchStr = pitchSplit[0];
				pitch = parsePitch(harmonyNotes[j]);

				// look for effect added to the note
				if (pitchSplit.length > 1) {
					var blipId = pitchSplit[1];
					pitch.blip = blipId;
				}
			}

			harmonyBar[j] = pitch;
		}
		tuneData.harmony.push(harmonyBar);
		i++;

		// check if there's another bar after this one
		if (lines[i] === ">") {
			// there is! increment the index
			barIndex++;
			i++;
		}
		else {
			// we've reached the end of the tune!
			barIndex = maxTuneLength;
		}
	}

	// parse other tune properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "KEY") {
			tuneData.key = createTuneKeyData();

			var keyNotes = getArg(lines[i], 1);
			if (keyNotes) {
				keyNotes = keyNotes.split(",");
				for (var j = 0; j < keyNotes.length && j < tuneData.key.notes.length; j++) {
					var pitch = parsePitch(keyNotes[j]);
					tuneData.key.notes[j] = pitch.note;
				}
			}

			var keyScale = getArg(lines[i], 2);
			if (keyScale) {
				keyScale = keyScale.split(",");
				for (var j = 0; j < keyScale.length; j++) {
					var pitch = parsePitch(keyScale[j]);
					if (pitch.note > Solfa.NONE && pitch.note < Solfa.COUNT) {
						tuneData.key.scale.push(pitch.note);
					}
				}
			}
		}
		else if (getType(lines[i]) === "TMP") {
			var tempoId = getId(lines[i]);
			if (Tempo[tempoId] != undefined) {
				tuneData.tempo = Tempo[tempoId];
			}
		}
		else if (getType(lines[i]) === "SQR") {
			// square wave instrument settings
			var squareWaveIdA = getArg(lines[i], 1);
			if (SquareWave[squareWaveIdA] != undefined) {
				tuneData.instrumentA = SquareWave[squareWaveIdA];
			}

			var squareWaveIdB = getArg(lines[i], 2);
			if (SquareWave[squareWaveIdB] != undefined) {
				tuneData.instrumentB = SquareWave[squareWaveIdB];
			}
		}
		else if (getType(lines[i]) === "ARP") {
			var arp = getId(lines[i]);
			if (ArpeggioPattern[arp] != undefined) {
				tuneData.arpeggioPattern = ArpeggioPattern[arp];
			}
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			tuneData.name = name;
			// todo : add to map?
		}

		i++;
	}

	world.tune[id] = tuneData;

	return i;
}

function parseBlip(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	i++;

	var blipData = createBlipData(id);

	// blip pitches
	var notes = lines[i].split(",");
	if (notes.length >= 1) {
		blipData.pitchA = parsePitch(notes[0]);
	}
	if (notes.length >= 2) {
		blipData.pitchB = parsePitch(notes[1]);
	}
	if (notes.length >= 3) {
		blipData.pitchC = parsePitch(notes[2]);
	}
	i++;

	// blip parameters
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "ENV") {
			// envelope
			blipData.envelope.attack = parseInt(getArg(lines[i], 1));
			blipData.envelope.decay = parseInt(getArg(lines[i], 2));
			blipData.envelope.sustain = parseInt(getArg(lines[i], 3));
			blipData.envelope.length = parseInt(getArg(lines[i], 4));
			blipData.envelope.release = parseInt(getArg(lines[i], 5));
		}
		else if (getType(lines[i]) === "BEAT") {
			// pitch beat length
			blipData.beat.time = parseInt(getArg(lines[i], 1));
			blipData.beat.delay = parseInt(getArg(lines[i], 2));
		}
		else if (getType(lines[i]) === "SQR") {
			// square wave
			var squareWaveId = getArg(lines[i], 1);
			if (SquareWave[squareWaveId] != undefined) {
				blipData.instrument = SquareWave[squareWaveId];
			}
		}
		// TODO : consider for future update
		// else if (getType(lines[i]) === "SLD") {
		// 	// slide mode
		// 	if (parseInt(getArg(lines[i], 1)) === 1) {
		// 		blipData.doSlide = true;
		// 	}
		// }
		else if (getType(lines[i]) === "RPT") {
			// repeat mode
			if (parseInt(getArg(lines[i], 1)) === 1) {
				blipData.doRepeat = true;
			}
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			blipData.name = name;
		}

		i++;
	}

	world.blip[id] = blipData;

	return i;
}

function parsePitch(pitchStr) {
	var pitch = { beats: 1, note: Note.C, octave: Octave[4], };
	var i;

	// beats
	var beatsToken = "";
	for (i = 0; i < pitchStr.length && ("0123456789".indexOf(pitchStr[i]) != -1); i++) {
		beatsToken += pitchStr[i];
	}
	if (beatsToken.length > 0) {
		pitch.beats = parseInt(beatsToken);
	}

	// note
	var noteType;
	var noteName = "";
	if (i < pitchStr.length) {
		if (pitchStr[i] === pitchStr[i].toUpperCase()) {
			// uppercase letters represent chromatic notes
			noteType = Note;
			noteName += pitchStr[i];
			i++;

			// check for sharp
			if (i < pitchStr.length && pitchStr[i] === "#") {
				noteName += "_SHARP";
				i++;
			}
		}
		else {
			// lowercase letters represent solfa notes
			noteType = Solfa;
			noteName += pitchStr[i].toUpperCase();
			i++;
		}
	}

	if (noteType != undefined && noteType[noteName] != undefined) {
		pitch.note = noteType[noteName];
	}

	// octave
	var octaveToken = "";
	if (i < pitchStr.length) {
		octaveToken += pitchStr[i];
	}

	if (Octave[octaveToken] != undefined) {
		pitch.octave = Octave[octaveToken];
	}

	return pitch;
}

function parseFlag(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	var id = getId(lines[i]);
	var valStr = lines[i].split(" ")[2];
	world.flags[id] = parseInt( valStr );
	i++;
	return i;
}

function getDrawingFrameCount(world, drwId) {
	return world.drawings[drwId].length;
}

function storeDrawingData(world, drwId, drawingData) {
	world.drawings[drwId] = drawingData;
}

function placeSprites(parseState, world) {
	for (id in parseState.spriteStartLocations) {
		world.sprite[id].room = parseState.spriteStartLocations[id].room;
		world.sprite[id].x = parseState.spriteStartLocations[id].x;
		world.sprite[id].y = parseState.spriteStartLocations[id].y;
	}
}

function createNameMapsForWorld(world) {
	var nameMaps = {};

	function createNameMap(objectStore) {
		var map = {};

		for (id in objectStore) {
			if (objectStore[id].name != undefined && objectStore[id].name != null) {
				map[objectStore[id].name] = id;
			}
		}

		return map;
	}

	nameMaps.room = createNameMap(world.room);
	nameMaps.tile = createNameMap(world.tile);
	nameMaps.sprite = createNameMap(world.sprite);
	nameMaps.item = createNameMap(world.item);
	nameMaps.dialog = createNameMap(world.dialog);
	nameMaps.palette = createNameMap(world.palette);
	nameMaps.tune = createNameMap(world.tune);
	nameMaps.blip = createNameMap(world.blip);

	return nameMaps;
}

function getType(line) {
	return getArg(line,0);
}

function getId(line) {
	return getArg(line,1);
}

function getCoord(line,arg) {
	return getArg(line,arg).split(",");
}

function getArg(line,arg) {
	return line.split(" ")[arg];
}

function getNameArg(line) {
	var name = line.split(/\s(.+)/)[1];
	return name;
}
</script>

<script>
/* PITCH HELPER FUNCTIONS */
function pitchToSteps(pitch) {
	return (pitch.octave * Note.COUNT) + pitch.note;
}

function stepsToPitch(steps) {
	var pitch = { beats: 1, note: Note.C, octave: Octave[2], };

	while (steps >= Note.COUNT) {
		pitch.octave = (pitch.octave + 1) % Octave.COUNT;
		steps -= Note.COUNT;
	}

	pitch.note += steps;

	// make sure pitch isn't outside a valid range
	if (pitch.note <= Note.NONE) {
		pitch.note = Note.C;
	}
	else if (pitch.note >= Note.COUNT) {
		pitch.note = Note.B;
	}

	if (pitch.octave <= Octave.NONE) {
		pitch.octave = Octave[2];
	}
	else if (pitch.octave >= Octave.COUNT) {
		pitch.octave = Octave[5];
	}

	return pitch;
}

function adjustPitch(pitch, stepDelta) {
	return stepsToPitch(pitchToSteps(pitch) + stepDelta);
}

function pitchDistance(pitchA, pitchB) {
	return pitchToSteps(pitchB) - pitchToSteps(pitchA);
}

function isMinPitch(pitch) {
	return pitchToSteps(pitch) <= pitchToSteps({ note: Note.C, octave: Octave[2] });
}

function isMaxPitch(pitch) {
	return pitchToSteps(pitch) >= pitchToSteps({ note: Note.B, octave: Octave[5] });
}

function SoundPlayer() {
	// frequencies (in hertz) for octave 0 (or is it octave 4?)
	var frequencies = [
		261.7, // middle C
		277.2,
		293.7,
		311.2,
		329.7,
		349.3,
		370.0,
		392.0,
		415.3,
		440.0,
		466.2,
		493.9,
	];

	// tempos are calculated as the duration of a 16th note, rounded to the nearest millisecond
	var tempos = {};
	tempos[Tempo.SLW] = 250; // 60bpm (adagio)
	tempos[Tempo.MED] = 188; // ~80bpm (andante) [exact would be 187.5 ms]
	tempos[Tempo.FST] = 125; // 120bpm (moderato)
	tempos[Tempo.XFST] = 94; // ~160bpm (allegro) [exact would be 93.75 ms]

	// arpeggio patterns expressed in scale degrees
	var arpeggioPattern = {};
	arpeggioPattern[ArpeggioPattern.UP] = [0, 2, 4, 7];
	arpeggioPattern[ArpeggioPattern.DWN] = [7, 4, 2, 0];
	arpeggioPattern[ArpeggioPattern.INT5] = [0, 4];
	arpeggioPattern[ArpeggioPattern.INT8] = [0, 7];

	this.getArpeggioSteps = function(tune) { return arpeggioPattern[tune.arpeggioPattern]; };

	function isPitchPlayable(pitch, key) {
		if (pitch.beats <= 0) {
			return false;
		}

		if (key === undefined || key === null) {
			return true;
		}

		// test if note is in the scale
		return (key.scale.indexOf(pitch.note) > -1)
			&& (key.notes[pitch.note] > Note.NONE)
			&& (key.notes[pitch.note] < Note.COUNT);
	}

	function pitchToChromatic(pitch, key) {
		if (pitch === undefined || pitch === null) {
			return null;
		}

		if (key === undefined || key === null) {
			return pitch;
		}

		// convert from solfa
		var octaveOffset = (pitch.note >= Solfa.COUNT) ? 1 : 0;

		return {
			beats: pitch.beats,
			octave: pitch.octave + octaveOffset,
			// todo : what about the scale limits?
			note: key.notes[(pitch.note % Solfa.COUNT)],
			blip: pitch.blip
		};
	}

	function makePitchFrequency(pitch) {
		// todo : this clamp shouldn't be required.. there's a bug in the pitch shifting somewhere
		var note = Math.max(0, pitch.note);
		var octave = (pitch.octave != undefined ? pitch.octave : Octave[4]);

		var octaveMin = Octave[2];
		var octaveMax = Octave[5];

		// make sure octave is in valid range
		octave = Math.max(octaveMin, Math.min(octave, octaveMax));
		var distFromMiddleC = octave - 2;

		var freq = frequencies[note] * Math.pow(2, distFromMiddleC);

		if (isNaN(freq)) {
			bitsy.log("invalid frequency " + pitch, "sound");
		}

		return freq;
	}

	var maxVolume = 15; // todo : should this be a system constant?
	var noteVolume = 5;

	var curTune = null;
	var isTunePaused = false;
	var barIndex = -1;
	var curArpeggio = [];

	var beat16 = 0;
	var beat16Timer = 0;
	var beat16Index = 0;

	// special settings
	var isLooping = false;
	var isMelodyMuted = false;
	var maxBeatCount = null;
	var muteTimer = 0; // allow temporary muting of all notes

	function arpeggiateBar(bar, key, pattern) {
		var arpeggio = [];

		if (key != undefined && key != null && isPitchPlayable(bar[0], key)) {
			for (var i = 0; i < arpeggioPattern[pattern].length; i++) {
				var pitch = { beats: 1, note: bar[0].note + arpeggioPattern[pattern][i], octave: bar[0].octave };
				arpeggio.push(pitchToChromatic(pitch, key));
			}
		}

		for (var i = 0; i < arpeggio.length; i++) {
			bitsy.log(i + ": " + serializeNote(arpeggio[i].note));
		}

		return arpeggio;
	};

	function playNote(pitch, instrument, options) {
		if (pitch.beats <= 0) {
			return;
		}

		var channel = bitsy.SOUND1;
		if (options != undefined && options.channel != undefined) {
			channel = options.channel;
		}

		var key = null;
		if (options != undefined && options.key != undefined) {
			key = options.key;
		}

		var beatLen = beat16;
		if (options != undefined && options.beatLen != undefined) {
			beatLen = options.beatLen;
		}

		if (isPitchPlayable(pitch, key)) {
			var freq = makePitchFrequency(pitchToChromatic(pitch, key));
			bitsy.sound(channel, (pitch.beats * beatLen), freq * 100, noteVolume, instrument);
		}
	}

	function sfxFrequencyAtTime(sfx, time) {
		var beatDelay = sfx.blip.beat.delay;
		var beatTime = sfx.blip.beat.time;
		var delta = Math.max(0, time - beatDelay) / beatTime;

		var pitchDelta = sfx.blip.doRepeat
			? (delta % sfx.frequencies.length)
			: Math.min(delta, sfx.frequencies.length - 1);

		sfx.pitchIndex = Math.floor(pitchDelta);
		var curFreq = sfx.frequencies[sfx.pitchIndex];

		// TODO : consider for future update
		// if (sfx.blip.doSlide) {
		// 	var nextPitchIndex = (sfx.pitchIndex + 1) % sfx.frequencies.length;
		// 	var nextFreq = sfx.frequencies[nextPitchIndex];
		// 	var d = pitchDelta - sfx.pitchIndex;
		// 	curFreq = curFreq + ((nextFreq - curFreq) * d);
		// }

		return curFreq;
	}

	function sfxVolumeAtTime(sfx, time) {
		var volume = 0;

		// use envelope settings to calculate volume
		var attack = sfx.blip.envelope.attack;
		var decay = sfx.blip.envelope.decay;
		var length = sfx.blip.envelope.length;
		var release = sfx.blip.envelope.release;
		if (time < attack) {
			// attack
			var t = time / attack;
			volume = Math.floor(sfxPeakVolume * t);
		}
		else if (time < attack + decay) {
			// decay
			var t = (time - attack) / decay;
			var d = sfx.blip.envelope.sustain - sfxPeakVolume;
			volume = Math.floor(sfxPeakVolume + (d * t));
		}
		else if (time < attack + decay + length) {
			// sustain
			volume = sfx.blip.envelope.sustain;
		}
		else if (time < attack + decay + length + release) {
			// release
			var t = (time - (attack + decay + length)) / release;
			volume = Math.floor(sfx.blip.envelope.sustain * (1 - t));
		}
		else {
			volume = 0;
		}

		return volume;
	}

	function updateSfx(dt) {
		// try limiting the max change per frame
		dt = Math.min(dt, 32);
		var isAnyBlipPlaying = false;

		if (activeSfx != null) {
			isAnyBlipPlaying = true;
			var sfx = activeSfx;

			sfx.timer += dt;
			if (sfx.timer >= sfx.duration) {
				sfx.timer = sfx.duration;
			}

			if (sfx.frequencies.length > 0) {
				// update pitch
				var prevPitchIndex = sfx.pitchIndex;
				var freq = sfxFrequencyAtTime(sfx, sfx.timer);
				if (prevPitchIndex != sfx.pitchIndex) {
					// pitch changed!
					bitsy.frequency(bitsy.SOUND1, freq * 100);
				}

				// update volume envelope
				bitsy.volume(bitsy.SOUND1, sfxVolumeAtTime(sfx, sfx.timer));
			}

			if (sfx.timer >= sfx.duration) {
				// turn off sound
				bitsy.volume(bitsy.SOUND1, 0);
				activeSfx = null;
			}
		}

		if (isMusicPausedForBlip && !isAnyBlipPlaying) {
			isMusicPausedForBlip = false;
		}
	}

	function updateTune(dt) {
		if (curTune === undefined || curTune === null) {
			return;
		}

		beat16Timer += dt;

		if (muteTimer > 0) {
			muteTimer -= dt;
		}

		if (beat16Timer >= beat16) {
			beat16Timer = 0;
			beat16Index++;

			if (beat16Index >= 16) {
				beat16Index = 0;

				if (!isLooping) {
					barIndex = (barIndex + 1) % curTune.melody.length;

					if (curTune.arpeggioPattern != ArpeggioPattern.OFF && curTune.key != null) {
						curArpeggio = arpeggiateBar(curTune.harmony[barIndex], curTune.key, curTune.arpeggioPattern);
					}
				}
			}

			if (muteTimer <= 0) {
				if (!isMelodyMuted) {
					// melody note
					var pitchA = curTune.melody[barIndex][beat16Index];
					if (pitchA.beats > 0) {
						// since they're played on the same channel, any melody note will cancel a blip
						activeSfx = null;
					}

					if (pitchA.blip != undefined && pitchA.beats > 0) {
						playBlip(blip[pitchA.blip], { interruptMusic: false, pitch: pitchA, key: curTune.key });
					}
					else {
						playNote(pitchA, curTune.instrumentA, { channel: bitsy.SOUND1, key: curTune.key });
					}
				}

				if (curTune.arpeggioPattern === ArpeggioPattern.OFF) {
					// harmony note
					var pitchB = curTune.harmony[barIndex][beat16Index];
					if (pitchB.blip != undefined && pitchB.beats > 0) {
						playBlip(blip[pitchB.blip], { interruptMusic: false, pitch: pitchB, key: curTune.key });
					}
					else {
						playNote(pitchB, curTune.instrumentB, { channel: bitsy.SOUND2, key: curTune.key });
					}
				}
				else {
					var arpPitch = curArpeggio[beat16Index % curArpeggio.length];
					if (arpPitch != undefined && arpPitch.beats > 0) {
						playNote(arpPitch, curTune.instrumentB, { channel: bitsy.SOUND2, beatLen: beat16 });
					}
				}
			}

			if (maxBeatCount != null && beat16Index >= (maxBeatCount - 1)) {
				// stop playback early
				curTune = null;
			}
		}
	}

	this.update = function(dt) {
		updateSfx(dt);
		if (!isTunePaused && !isMusicPausedForBlip) {
			updateTune(dt);
		}
	};

	this.playTune = function(tune, options) {
		curTune = tune;
		beat16Timer = 0;
		beat16Index = -1;
		barIndex = 0;

		isLooping = false;
		isMelodyMuted = false;
		maxBeatCount = null;

		// special options for the editor
		if (options != undefined) {
			if (options.barIndex != undefined) {
				barIndex = options.barIndex;
			}

			if (options.loop != undefined) {
				isLooping = options.loop;
			}

			if (options.melody != undefined) {
				isMelodyMuted = !options.melody;
			}

			if (options.beatCount != undefined) {
				maxBeatCount = options.beatCount;
			}
		}

		// update tempo
		beat16 = tempos[curTune.tempo];

		if (curTune.arpeggioPattern != ArpeggioPattern.OFF && curTune.key != null) {
			curArpeggio = arpeggiateBar(curTune.harmony[barIndex], curTune.key, curTune.arpeggioPattern);
		}
	};

	this.isTunePlaying = function() {
		return curTune != null;
	};

	this.getCurTuneId = function() {
		if (curTune) {
			return curTune.id;
		}

		return null;
	};

	this.stopTune = function() {
		curTune = null;
	};

	this.pauseTune = function() {
		isTunePaused = true;
	};

	this.resumeTune = function() {
		isTunePaused = false;
	};

	this.getBeat = function() {
		if (curTune == null) {
			return null;
		}

		return {
			bar : barIndex,
			beat : beat16Index,
		};
	};

	this.getBlipState = function() {
		return activeSfx;
	};

	this.playNote = function(pitch, instrument, channel, key) {
		beat16 = tempos[Tempo.SLW];
		muteTimer = beat16;
		playNote(pitch, instrument, { channel: channel, key: key });
	};

	this.setTempo = function(tempo) {
		beat16 = tempos[tempo];
	};

	this.setLooping = function(looping) {
		isLooping = looping;
	};

	/* SOUND EFFECTS */
	var sfxPeakVolume = 10; // todo : is this a good value?
	var activeSfx = null;
	var isMusicPausedForBlip = false;

	function createSfxState(blip, pitch, isPitchRandomized) {
		// bitsy.log("init sfx blip: " + blip.id);

		var sfxState = {
			blip : blip,
			pitchIndex : -1,
			frequencies : [],
			timer : 0,
			duration : 0,
		};

		// is it weird to track this both in the system *AND* the engine?
		sfxState.duration = (blip.envelope.attack + blip.envelope.decay + blip.envelope.length + blip.envelope.release);

		// adjust starting pitch
		var step = 0;
		if (pitch != null) {
			step = pitchDistance(blip.pitchA, pitch);
		}
		else if (isPitchRandomized > 0) {
			step = Math.floor(Math.random() * 6);
		}

		if (blip.pitchA.beats > 0) {
			sfxState.frequencies.push(makePitchFrequency(adjustPitch(blip.pitchA, step)));
		}
		if (blip.pitchB.beats > 0) {
			sfxState.frequencies.push(makePitchFrequency(adjustPitch(blip.pitchB, step)));
		}
		if (blip.pitchC.beats > 0) {
			sfxState.frequencies.push(makePitchFrequency(adjustPitch(blip.pitchC, step)));
		}

		return sfxState;
	}

	function playBlip(blip, options) {
		// default to pausing music while the blip plays (except when playing a blip as *part* of music)
		isMusicPausedForBlip = (options === undefined || options.interruptMusic === undefined) ? true : options.interruptMusic;

		// always play blips on channel 1
		var channel = bitsy.SOUND1;

		// other options
		var pitch = (options === undefined || options.pitch === undefined) ? null : options.pitch;
		var isPitchRandomized = (options === undefined || options.isPitchRandomized === undefined) ? false : options.isPitchRandomized;
		var key = (options != undefined && options.key != undefined) ? options.key : null;

		activeSfx = createSfxState(blip, pitchToChromatic(pitch, key), isPitchRandomized);
		bitsy.log("play blip: " + activeSfx.frequencies);

		bitsy.sound(
			channel,
			activeSfx.duration * 10, // HACK : mult by 10 is to avoid accidentally turning off early
			activeSfx.frequencies.length > 0 ? (activeSfx.frequencies[0] * 100) : 0,
			0, // volume
			activeSfx.blip.instrument);
	};

	this.playBlip = playBlip;

	this.isBlipPlaying = function() {
		return isMusicPausedForBlip; // todo : rename this variable?
	};

	// todo : should any of this stuff be moved into the tool code?
	this.sampleBlip = function(blip, sampleCount) {
		var sfx = createSfxState(blip, null, false);

		var minFreq = makePitchFrequency({ note: Note.C, octave: Octave[2] });
		var maxFreq = makePitchFrequency({ note: Note.B, octave: Octave[5] });

		// sample the frequency of the sound
		var frequencySamples = [];
		for (var i = 0; i < sampleCount; i++) {
			if (sfx.frequencies.length > 0) {
				var t = Math.floor((i / sampleCount) * sfx.duration);
				// get frequency at time
				var freq = sfxFrequencyAtTime(sfx, t);
				// normalize the sample
				freq = freq / (maxFreq - minFreq);

				frequencySamples.push(freq);
			}
			else {
				frequencySamples.push(0);
			}
		}

		// sample the volume envelope
		var amplitudeSamples = [];
		for (var i = 0; i < sampleCount; i++) {
			var t = Math.floor((i / sampleCount) * sfx.duration);
			amplitudeSamples.push(sfxVolumeAtTime(sfx, t) / maxVolume);
		}

		return {
			frequencies: frequencySamples,
			amplitudes: amplitudeSamples
		};
	};
}
</script>

<script>
/*
TODO:
- can I simplify this more now that I've removed the external resources stuff?
*/

function FontManager(packagedFontNames) {

var self = this;

var fontExtension = ".bitsyfont";
this.GetExtension = function() {
	return fontExtension;
}

// place to store font data
var fontResources = {};

// load fonts from the editor
if (packagedFontNames != undefined && packagedFontNames != null && packagedFontNames.length > 0
		&& Resources != undefined && Resources != null) {

	for (var i = 0; i < packagedFontNames.length; i++) {
		var filename = packagedFontNames[i];
		fontResources[filename] = Resources[filename];
	}
}

// manually add resource
this.AddResource = function(filename, fontdata) {
	fontResources[filename] = fontdata;
}

this.ContainsResource = function(filename) {
	return fontResources[filename] != null;
}

function GetData(fontName) {
	return fontResources[fontName + fontExtension];
}
this.GetData = GetData;

function Create(fontData) {
	return new Font(fontData);
}
this.Create = Create;

this.Get = function(fontName) {
	var fontData = self.GetData(fontName);
	return self.Create(fontData);
}

function Font(fontData) {
	bitsy.log("create font");

	var name = "unknown";
	var width = 6; // default size so if you have NO font or an invalid font it displays boxes
	var height = 8;
	var chardata = {};

	// create invalid char data at default size in case the font is missing
	var invalidCharData = {};
	updateInvalidCharData();

	this.getName = function() {
		return name;
	}

	this.getData = function() {
		return chardata;
	}

	this.getWidth = function() {
		return width;
	}

	this.getHeight = function() {
		return height;
	}

	this.hasChar = function(char) {
		var codepoint = char.charCodeAt(0);
		return chardata[codepoint] != null;
	}

	this.getChar = function(char) {

		var codepoint = char.charCodeAt(0);

		if (chardata[codepoint] != null) {
			return chardata[codepoint];
		}
		else {
			return invalidCharData;
		}
	}

	this.allCharCodes = function() {
		var codeList = [];
		for (var code in chardata) {
			codeList.push(code);
		}
		return codeList;
	}

	function createCharData() {
		return { 
			width: width,
			height: height,
			offset: {
				x: 0,
				y: 0
			},
			spacing: width,
			data: [],
		};
	}

	function updateInvalidCharData() {
		invalidCharData = createCharData();
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				if (x < width-1 && y < height-1) {
					invalidCharData.data.push(1);
				}
				else {
					invalidCharData.data.push(0);
				}
			}
		}
	}

	function parseFont(fontData) {
		if (fontData == null) {
			return;
		}

		bitsy.log("split font lines");
		// NOTE: this is where we run out of memory - split creates a lot of memory issues
		// var lines = fontData.split("\n");
		bitsy.log("after split lines");

		var isReadingChar = false;
		var isReadingCharProperties = false;
		var curCharLineCount = 0;
		var curCharCode = 0;

		var lineStart = 0;
		var lineEnd = fontData.indexOf("\n", lineStart) != -1
			? fontData.indexOf("\n", lineStart)
			: fontData.length;

		// for (var i = 0; i < lines.length; i++) {
		// 	var line = lines[i];
		while (lineStart < fontData.length) {
			var line = fontData.substring(lineStart, lineEnd);
			// bitsy.log("parse font xx " + line);

			if (line[0] === "#") {
				// skip comment lines
			}
			else if (!isReadingChar) {
				// READING NON CHARACTER DATA LINE
				var args = line.split(" ");
				if (args[0] == "FONT") {
					name = args[1];
				}
				else if (args[0] == "SIZE") {
					width = parseInt(args[1]);
					height = parseInt(args[2]);
				}
				else if (args[0] == "CHAR") {
					isReadingChar = true;
					isReadingCharProperties = true;

					curCharLineCount = 0;
					curCharCode = parseInt(args[1]);
					chardata[curCharCode] = createCharData();
				}
			}
			else {
				// CHAR PROPERTIES
				if (isReadingCharProperties) {
					var args = line.split(" ");
					if (args[0].indexOf("CHAR_") == 0) { // Sub-properties start with "CHAR_"
						if (args[0] == "CHAR_SIZE") {
							// Custom character size - overrides the default character size for the font
							chardata[curCharCode].width = parseInt(args[1]);
							chardata[curCharCode].height = parseInt(args[2]);
							chardata[curCharCode].spacing = parseInt(args[1]); // HACK : assumes CHAR_SIZE is always declared first
						}
						else if (args[0] == "CHAR_OFFSET") {
							// Character offset - shift the origin of the character on the X or Y axis
							chardata[curCharCode].offset.x = parseInt(args[1]);
							chardata[curCharCode].offset.y = parseInt(args[2]);
						}
						else if (args[0] == "CHAR_SPACING") {
							// Character spacing:
							// specify total horizontal space taken up by the character
							// lets chars take up more or less space on a line than its bitmap does
							chardata[curCharCode].spacing = parseInt(args[1]);
						}
					}
					else {
						isReadingCharProperties = false;
					}
				}

				// CHAR DATA
				if (!isReadingCharProperties) {
					// READING CHARACTER DATA LINE
					for (var j = 0; j < chardata[curCharCode].width; j++)
					{
						chardata[curCharCode].data.push( parseInt(line[j]) );
					}

					curCharLineCount++;
					if (curCharLineCount >= chardata[curCharCode].height) {
						isReadingChar = false;
					}
				}
			}

			lineStart = lineEnd + 1;
			lineEnd = fontData.indexOf("\n", lineStart) != -1
				? fontData.indexOf("\n", lineStart)
				: fontData.length;
		}

		// re-init invalid character box at the actual font size once it's loaded
		updateInvalidCharData();
	}

	bitsy.log("parse font");
	parseFont(fontData);

	bitsy.log("create font");
}

} // FontManager

</script>

<script>
var TransitionManager = function() {
	var transitionStart = null;
	var transitionEnd = null;

	var isTransitioning = false;
	var transitionTime = 0; // milliseconds
	var minStepTime = 125; // cap the frame rate
	var curStep = 0;

	this.BeginTransition = function(startRoom, startX, startY, endRoom, endX, endY, effectName) {
		bitsy.log("--- START ROOM TRANSITION ---");

		curEffect = effectName;

		var tmpRoom = player().room;
		var tmpX = player().x;
		var tmpY = player().y;

		if (transitionEffects[curEffect].showPlayerStart) {
			player().room = startRoom;
			player().x = startX;
			player().y = startY;
		}
		else {
			player().room = "_transition_none"; // kind of hacky!!
		}

		var startRoomPixels = createRoomPixelBuffer(room[startRoom]);
		var startPalette = getPal(room[startRoom].pal);
		var startImage = new PostProcessImage(startRoomPixels);
		transitionStart = new TransitionInfo(startImage, startPalette, startX, startY);

		if (transitionEffects[curEffect].showPlayerEnd) {
			player().room = endRoom;
			player().x = endX;
			player().y = endY;
		}
		else {
			player().room = "_transition_none";
		}

		var endRoomPixels = createRoomPixelBuffer(room[endRoom]);
		var endPalette = getPal(room[endRoom].pal);
		var endImage = new PostProcessImage(endRoomPixels);
		transitionEnd = new TransitionInfo(endImage, endPalette, endX, endY);

		isTransitioning = true;
		transitionTime = 0;
		curStep = 0;

		player().room = endRoom;
		player().x = endX;
		player().y = endY;

		bitsy.graphicsMode(bitsy.GFX_VIDEO);
	}

	this.UpdateTransition = function(dt) {
		if (!isTransitioning) {
			return;
		}

		transitionTime += dt;

		var maxStep = transitionEffects[curEffect].stepCount;

		if (transitionTime >= minStepTime) {
			curStep++;

			var step = curStep;
			bitsy.log("transition step " + step);

			if (transitionEffects[curEffect].paletteEffectFunc) {
				var colors = transitionEffects[curEffect].paletteEffectFunc(transitionStart, transitionEnd, (step / maxStep));
				updatePaletteWithTileColors(colors);
			}

			bitsy.fill(bitsy.VIDEO, tileColorStartIndex);

			for (var y = 0; y < bitsy.VIDEO_SIZE; y++) {
				for (var x = 0; x < bitsy.VIDEO_SIZE; x++) {
					var color = transitionEffects[curEffect].pixelEffectFunc(transitionStart, transitionEnd, x, y, (step / maxStep));
					bitsy.set(bitsy.VIDEO, (y * bitsy.VIDEO_SIZE) + x, color);
				}
			}

			transitionTime = 0;
		}

		if (curStep >= (maxStep - 1)) {
			isTransitioning = false;
			transitionTime = 0;
			transitionStart = null;
			transitionEnd = null;
			curStep = 0;

			if (transitionCompleteCallback != null) {
				transitionCompleteCallback();
			}
			transitionCompleteCallback = null;

			bitsy.graphicsMode(bitsy.GFX_MAP);
		}
	}

	this.IsTransitionActive = function() {
		return isTransitioning;
	}

	// todo : should this be part of the constructor?
	var transitionCompleteCallback = null;
	this.OnTransitionComplete = function(callback) {
		if (isTransitioning) { // TODO : safety check necessary?
			transitionCompleteCallback = callback;
		}
	}

	var transitionEffects = {};
	var curEffect = "none";
	this.RegisterTransitionEffect = function(name, effect) {
		transitionEffects[name] = effect;
	}

	this.RegisterTransitionEffect("none", {
		showPlayerStart : false,
		showPlayerEnd : false,
		paletteEffectFunc : function() {},
		pixelEffectFunc : function() {},
	});

	this.RegisterTransitionEffect("fade_w", { // TODO : have it linger on full white briefly?
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 6,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			return delta < 0.5 ? start.Image.GetPixel(pixelX, pixelY) : end.Image.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			var colors = [];

			if (delta < 0.5) {
				delta = delta / 0.5;

				for (var i = 0; i < start.Palette.length; i++) {
					colors.push(lerpColor(start.Palette[i], [255, 255, 255], delta));
				}
			}
			else {
				delta = ((delta - 0.5) / 0.5);

				for (var i = 0; i < end.Palette.length; i++) {
					colors.push(lerpColor([255, 255, 255], end.Palette[i], delta));
				}
			}

			return colors;
		},
	});

	this.RegisterTransitionEffect("fade_b", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 6,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			return delta < 0.5 ? start.Image.GetPixel(pixelX, pixelY) : end.Image.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			var colors = [];

			if (delta < 0.5) {
				delta = delta / 0.5;

				for (var i = 0; i < start.Palette.length; i++) {
					colors.push(lerpColor(start.Palette[i], [0, 0, 0], delta));
				}
			}
			else {
				delta = ((delta - 0.5) / 0.5);

				for (var i = 0; i < end.Palette.length; i++) {
					colors.push(lerpColor([0, 0, 0], end.Palette[i], delta));
				}
			}

			return colors;
		},
	});

	this.RegisterTransitionEffect("wave", {
		showPlayerStart : true,
		showPlayerEnd : true,
		stepCount : 12,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var waveDelta = delta < 0.5 ? delta / 0.5 : 1 - ((delta - 0.5) / 0.5);

			var offset = (pixelY + (waveDelta * waveDelta * 0.2 * start.Image.Height));
			var freq = 4;
			var size = 2 + (14 * waveDelta);
			pixelX += Math.floor(Math.sin(offset / freq) * size);

			if (pixelX < 0) {
				pixelX += start.Image.Width;
			}
			else if (pixelX >= start.Image.Width) {
				pixelX -= start.Image.Width;
			}

			var curImage = delta < 0.5 ? start.Image : end.Image;
			return curImage.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			return delta < 0.5 ? start.Palette : end.Palette;
		},
	});

	this.RegisterTransitionEffect("tunnel", {
		showPlayerStart : true,
		showPlayerEnd : true,
		stepCount : 12,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			if (delta <= 0.4) {
				var tunnelDelta = 1 - (delta / 0.4);

				var xDist = start.PlayerCenter.x - pixelX;
				var yDist = start.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > start.Image.Width * tunnelDelta) {
					return 0;
				}
				else {
					return start.Image.GetPixel(pixelX, pixelY);
				}
			}
			else if (delta <= 0.6) {
				return 0;
			}
			else {
				var tunnelDelta = (delta - 0.6) / 0.4;

				var xDist = end.PlayerCenter.x - pixelX;
				var yDist = end.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > end.Image.Width * tunnelDelta) {
					return 0;
				}
				else {
					return end.Image.GetPixel(pixelX, pixelY);
				}
			}
		},
		paletteEffectFunc : function(start, end, delta) {
			return delta < 0.5 ? start.Palette : end.Palette;
		},
	});

	function lerpPalettes(start, end, delta) {
		var colors = [];

		var maxLength = (start.Palette.length > end.Palette.length) ?
			start.Palette.length : end.Palette.length;

		for (var i = 0; i < maxLength; i++) {
			if (i < start.Palette.length && i < end.Palette.length) {
				colors.push(lerpColor(start.Palette[i], end.Palette[i], delta));
			}
			else if (i < start.Palette.length) {
				colors.push(lerpColor(
					start.Palette[i],
					end.Palette[end.Palette.length - 1],
					delta));
			}
			else if (i < end.Palette.length) {
				colors.push(lerpColor(
					start.Palette[start.Palette.length - 1],
					end.Palette[i],
					delta));
			}
		}

		return colors;
	}

	this.RegisterTransitionEffect("slide_u", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			if (slidePixelY >= 0) {
				return start.Image.GetPixel(pixelX, slidePixelY);
			}
			else {
				slidePixelY += start.Image.Height;
				return end.Image.GetPixel(pixelX, slidePixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_d", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			if (slidePixelY < start.Image.Height) {
				return start.Image.GetPixel(pixelX, slidePixelY);
			}
			else {
				slidePixelY -= start.Image.Height;
				return end.Image.GetPixel(pixelX, slidePixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_l", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			if (slidePixelX >= 0) {
				return start.Image.GetPixel(slidePixelX, pixelY);
			}
			else {
				slidePixelX += start.Image.Width;
				return end.Image.GetPixel(slidePixelX, pixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_r", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			if (slidePixelX < start.Image.Width) {
				return start.Image.GetPixel(slidePixelX, pixelY);
			}
			else {
				slidePixelX -= start.Image.Width;
				return end.Image.GetPixel(slidePixelX, pixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	// todo : move to Renderer()?
	function createRoomPixelBuffer(room) {
		var pixelBuffer = [];

		for (var i = 0; i < bitsy.VIDEO_SIZE * bitsy.VIDEO_SIZE; i++) {
			pixelBuffer.push(tileColorStartIndex);
		}

		var drawTileInPixelBuffer = function(sourceData, frameIndex, colorIndex, tx, ty, pixelBuffer) {
			var frameData = sourceData[frameIndex];

			for (var y = 0; y < bitsy.TILE_SIZE; y++) {
				for (var x = 0; x < bitsy.TILE_SIZE; x++) {
					var color = tileColorStartIndex + (frameData[y][x] === 1 ? colorIndex : 0);
					pixelBuffer[(((ty * bitsy.TILE_SIZE) + y) * bitsy.VIDEO_SIZE) + ((tx * bitsy.TILE_SIZE) + x)] = color;
				}
			}
		}

		//draw tiles
		for (i in room.tilemap) {
			for (j in room.tilemap[i]) {
				var id = room.tilemap[i][j];
				var x = parseInt(j);
				var y = parseInt(i);

				if (id != "0" && tile[id] != null) {
					drawTileInPixelBuffer(
						renderer.GetDrawingSource(tile[id].drw),
						tile[id].animation.frameIndex,
						tile[id].col,
						x,
						y,
						pixelBuffer);
				}
			}
		}

		//draw items
		for (var i = 0; i < room.items.length; i++) {
			var itm = room.items[i];
			drawTileInPixelBuffer(
				renderer.GetDrawingSource(item[itm.id].drw),
				item[itm.id].animation.frameIndex,
				item[itm.id].col,
				itm.x,
				itm.y,
				pixelBuffer);
		}

		//draw sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.room === room.id) {
				drawTileInPixelBuffer(
					renderer.GetDrawingSource(spr.drw),
					spr.animation.frameIndex,
					spr.col,
					spr.x,
					spr.y,
					pixelBuffer);
			}
		}

		return pixelBuffer;
	}

	function lerpColor(colorA, colorB, t) {
		return [
			colorA[0] + ((colorB[0] - colorA[0]) * t),
			colorA[1] + ((colorB[1] - colorA[1]) * t),
			colorA[2] + ((colorB[2] - colorA[2]) * t),
		];
	};
}; // TransitionManager()

// todo : is this wrapper still useful?
var PostProcessImage = function(imageData) {
	this.Width = bitsy.VIDEO_SIZE;
	this.Height = bitsy.VIDEO_SIZE;

	this.GetPixel = function(x, y) {
		return imageData[(y * bitsy.VIDEO_SIZE) + x];
	};

	this.GetData = function() {
		return imageData;
	};
};

var TransitionInfo = function(image, palette, playerX, playerY) {
	this.Image = image;

	this.Palette = palette;

	this.PlayerTilePos = {
		x: playerX,
		y: playerY
	};

	this.PlayerCenter = {
		x: Math.floor((playerX * bitsy.TILE_SIZE) + (bitsy.TILE_SIZE / 2)),
		y: Math.floor((playerY * bitsy.TILE_SIZE) + (bitsy.TILE_SIZE / 2))
	};
};
</script>

<script>
function Script() {

this.CreateInterpreter = function() {
	return new Interpreter();
};

this.CreateUtils = function() {
	return new Utils();
};

var Interpreter = function() {
	var env = new Environment();
	var parser = new Parser( env );

	this.SetDialogBuffer = function(buffer) { env.SetDialogBuffer( buffer ); };

	// TODO -- maybe this should return a string instead othe actual script??
	this.Compile = function(scriptName, scriptStr) {
		var script = parser.Parse(scriptStr, scriptName);
		env.SetScript(scriptName, script);
	}
	this.Run = function(scriptName, exitHandler, objectContext) { // Runs pre-compiled script
		var localEnv = new LocalEnvironment(env);

		if (objectContext) {
			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?
		}

		var script = env.GetScript(scriptName);

		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );
	}
	this.Interpret = function(scriptStr, exitHandler, objectContext) { // Compiles and runs code immediately
		// bitsy.log("INTERPRET");
		var localEnv = new LocalEnvironment(env);

		if (objectContext) {
			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?
		}

		var script = parser.Parse(scriptStr, "anonymous");
		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );
	}
	this.HasScript = function(name) { return env.HasScript(name); };

	this.ResetEnvironment = function() {
		env = new Environment();
		parser = new Parser( env );
	}

	this.Parse = function(scriptStr, rootId) { // parses a script but doesn't save it
		return parser.Parse(scriptStr, rootId);
	}

	this.Eval = function(scriptTree, exitHandler) { // runs a script stored externally
		var localEnv = new LocalEnvironment(env); // TODO : does this need an object context?
		scriptTree.Eval(
			localEnv,
			function(result) {
				OnScriptReturn(result, exitHandler);
			});
	}

	function OnScriptReturn(result, exitHandler) {
		if (exitHandler != null) {
			exitHandler(result);
		}
	}

	this.CreateExpression = function(expStr) {
		return parser.CreateExpression(expStr);
	}

	this.SetVariable = function(name,value,useHandler) {
		env.SetVariable(name,value,useHandler);
	}

	this.DeleteVariable = function(name,useHandler) {
		env.DeleteVariable(name,useHandler);
	}
	this.HasVariable = function(name) {
		return env.HasVariable(name);
	}

	this.SetOnVariableChangeHandler = function(onVariableChange) {
		env.SetOnVariableChangeHandler(onVariableChange);
	}
	this.GetVariableNames = function() {
		return env.GetVariableNames();
	}
	this.GetVariable = function(name) {
		return env.GetVariable(name);
	}

	function DebugVisualizeScriptTree(scriptTree) {
		var printVisitor = {
			Visit : function(node,depth) {
				bitsy.log("-".repeat(depth) + "- " + node.ToString());
			},
		};

		scriptTree.VisitAll( printVisitor );
	}

	this.DebugVisualizeScriptTree = DebugVisualizeScriptTree;

	this.DebugVisualizeScript = function(scriptName) {
		DebugVisualizeScriptTree(env.GetScript(scriptName));
	}
}


var Utils = function() {
	// for editor ui
	this.CreateDialogBlock = function(children,doIndentFirstLine) {
		if (doIndentFirstLine === undefined) {
			doIndentFirstLine = true;
		}

		var block = new DialogBlockNode(doIndentFirstLine);

		for (var i = 0; i < children.length; i++) {
			block.AddChild(children[i]);
		}
		return block;
	}

	this.CreateOptionBlock = function() {
		var block = new DialogBlockNode(false);
		block.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		return block;
	}

	this.CreateItemConditionPair = function() {
		var itemFunc = this.CreateFunctionBlock("item", ["0"]);
		var condition = new ExpNode("==", itemFunc, new LiteralNode(1));
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateVariableConditionPair = function() {
		var varNode = this.CreateVariableNode("a");
		var condition = new ExpNode("==", varNode, new LiteralNode(1));
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateDefaultConditionPair = function() {
		var condition = this.CreateElseNode();
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateEmptySayFunc = function() {
		return new FuncNode("say", [new LiteralNode("...")]);
	}

	this.CreateFunctionBlock = function(name, initParamValues) {
		var parameters = [];
		for (var i = 0; i < initParamValues.length; i++) {
			parameters.push(new LiteralNode(initParamValues[i]));
		}

		var node = new FuncNode(name, parameters);
		var block = new CodeBlockNode();
		block.AddChild(node);
		return block;
	}

	// TODO : rename ParseStringToLiteralNode?
	this.CreateLiteralNode = function(str) {
		if (str === "true") {
			return new LiteralNode(true);
		}
		else if (str === "false") {
			return new LiteralNode(false);
		}
		else if (!isNaN(parseFloat(str))) {
			return new LiteralNode(parseFloat(str));
		}
		else {
			return new LiteralNode(str);
		}
	}

	this.CreateVariableNode = function(variableName) {
		return new VarNode(variableName);
	}

	this.CreatePropertyNode = function(propertyName, literalValue) {
		var varNode = new VarNode(propertyName);
		var valNode = new LiteralNode(literalValue);
		var node = new FuncNode("property", [varNode, valNode]);
		var block = new CodeBlockNode();
		block.AddChild(node);
		return block;
	}

	this.CreateElseNode = function() {
		return new ElseNode();
	}

	this.CreateStringLiteralNode = function(str) {
		return new LiteralNode(str);
	}

	// TODO : need to split up code & dialog blocks :|
	this.CreateCodeBlock = function() {
		return new CodeBlockNode();
	}

	this.ChangeSequenceType = function(oldSequence, type) {
		if(type === "sequence") {
			return new SequenceNode(oldSequence.children);
		}
		else if(type === "cycle") {
			return new CycleNode(oldSequence.children);
		}
		else if(type === "shuffle") {
			return new ShuffleNode(oldSequence.children);
		}
		return oldSequence;
	}

	this.CreateSequenceBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var sequence = new SequenceNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateCycleBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var sequence = new CycleNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateShuffleBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var sequence = new ShuffleNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateIfBlock = function() {
		var leftNode = new CodeBlockNode();
		leftNode.AddChild( new FuncNode("item", [new LiteralNode("0")] ) );
		var rightNode = new LiteralNode( 1 );
		var condition1 = new ExpNode("==", leftNode, rightNode );

		var condition2 = new ElseNode();

		var result1 = new DialogBlockNode();
		result1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var result2 = new DialogBlockNode();
		result2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var ifNode = new IfNode( [ condition1, condition2 ], [ result1, result2 ] );
		var block = new CodeBlockNode();
		block.AddChild( ifNode );
		return block;
	}

	this.ReadDialogScript = function(lines, i) {
		var scriptStr = "";
		if (lines[i] === Sym.DialogOpen) {
			scriptStr += lines[i] + "\n";
			i++;
			while(lines[i] != Sym.DialogClose) {
				scriptStr += lines[i] + "\n";
				i++;
			}
			scriptStr += lines[i];
			i++;
		}
		else {
			scriptStr += lines[i];
			i++;
		}
		return { script:scriptStr, index:i };
	}

	// TODO this.ReadCodeScript (reads through code open and close symbols), and this.ReadScript

	this.EnsureDialogBlockFormat = function(dialogStr) {
		// TODO -- what if it's already enclosed in dialog symbols??
		if(dialogStr.indexOf('\n') > -1) {
			dialogStr = Sym.DialogOpen + "\n" + dialogStr + "\n" + Sym.DialogClose;
		}
		return dialogStr;
	}

	this.RemoveDialogBlockFormat = function(source) {
		var sourceLines = source.split("\n");
		var dialogStr = "";
		if(sourceLines[0] === Sym.DialogOpen) {
			// multi line
			var i = 1;
			while (i < sourceLines.length && sourceLines[i] != Sym.DialogClose) {
				dialogStr += sourceLines[i] + (sourceLines[i+1] != Sym.DialogClose ? '\n' : '');
				i++;
			}
		}
		else {
			// single line
			dialogStr = source;
		}
		return dialogStr;
	}

	this.SerializeDialogNodeList = function(nodeList) {
		var tempBlock = new DialogBlockNode(false);
		 // set children directly to avoid breaking the parenting chain for this temp operation
		tempBlock.children = nodeList;
		return tempBlock.Serialize();
	}

	this.GetOperatorList = function() {
		return [Sym.Set].concat(Sym.Operators);
	}

	this.IsInlineCode = function(node) {
		return isInlineCode(node);
	}
}


/* BUILT-IN FUNCTIONS */ // TODO: better way to encapsulate these?
function deprecatedFunc(environment,parameters,onReturn) {
	bitsy.log("BITSY SCRIPT WARNING: Tried to use deprecated function");
	onReturn(null);
}

function sayFunc(environment, parameters, onReturn) {
	if (parameters[0] != undefined && parameters[0] != null) {
		var textStr = "" + parameters[0];
		environment.GetDialogBuffer().AddText(textStr);
		environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
	}
	else {
		onReturn(null);
	}
}

function linebreakFunc(environment, parameters, onReturn) {
	// bitsy.log("LINEBREAK FUNC");
	environment.GetDialogBuffer().AddLinebreak();
	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
}

function pagebreakFunc(environment, parameters, onReturn) {
	environment.GetDialogBuffer().AddPagebreak(function() { onReturn(null); });
}

function drawFunc(environment, parameters, onReturn) {
	var drawingId = parameters[0];
	environment.GetDialogBuffer().AddDrawing(drawingId);
	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
}

function drawSpriteFunc(environment, parameters, onReturn) {
	var spriteId = parameters[0];

	// check if id parameter is actually a name
	if (names.sprite[spriteId] != undefined) {
		spriteId = names.sprite[spriteId];
	}

	var drawingId = sprite[spriteId].drw;
	drawFunc(environment, [drawingId], onReturn);
}

function drawTileFunc(environment, parameters, onReturn) {
	var tileId = parameters[0];

	// check if id parameter is actually a name
	if (names.tile[tileId] != undefined) {
		tileId = names.tile[tileId];
	}

	var drawingId = tile[tileId].drw;
	drawFunc(environment, [drawingId], onReturn);
}

function drawItemFunc(environment, parameters, onReturn) {
	var itemId = parameters[0];

	// check if id parameter is actually a name
	if (names.item[itemId] != undefined) {
		itemId = names.item[itemId];
	}

	var drawingId = item[itemId].drw;
	drawFunc(environment, [drawingId], onReturn);
}

function printFontFunc(environment, parameters, onReturn) {
	var allCharacters = "";
	var font = fontManager.Get(fontName);
	var codeList = font.allCharCodes();
	for (var i = 0; i < codeList.length; i++) {
		allCharacters += String.fromCharCode(codeList[i]) + " ";
	}
	sayFunc(environment, [allCharacters], onReturn);
}

function itemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];

	if (names.item[itemId] != undefined) {
		// id is actually a name
		itemId = names.item[itemId];
	}

	var curItemCount = player().inventory[itemId] ? player().inventory[itemId] : 0;

	if (parameters.length > 1) {
		// TODO : is it a good idea to force inventory to be >= 0?
		player().inventory[itemId] = Math.max(0, parseInt(parameters[1]));
		curItemCount = player().inventory[itemId];

		if (onInventoryChanged != null) {
			onInventoryChanged(itemId);
		}
	}

	onReturn(curItemCount);
}

function toggleTextEffect(environment, name) {
	if (environment.GetDialogBuffer().hasTextEffect(name)) {
		environment.GetDialogBuffer().popTextEffect(name);
	}
	else {
		environment.GetDialogBuffer().pushTextEffect(name, []);
	}
}

function color1Func(environment, parameters, onReturn) {
	toggleTextEffect(environment, "clr1");
	onReturn(null);
}

function color2Func(environment, parameters, onReturn) {
	toggleTextEffect(environment, "clr2");
	onReturn(null);
}

function color3Func(environment, parameters, onReturn) {
	toggleTextEffect(environment, "clr3");
	onReturn(null);
}

function colorFunc(environment, parameters, onReturn) {
	environment.GetDialogBuffer().pushTextEffect("clr", parameters);
	onReturn(null);
}

function colorPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("clr")) {
		environment.GetDialogBuffer().popTextEffect("clr");
	}
	onReturn(null);
}

function rainbowFunc(environment, parameters, onReturn) {
	toggleTextEffect(environment, "rbw");
	onReturn(null);
}

function rainbowPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("rbw")) {
		environment.GetDialogBuffer().popTextEffect("rbw");
	}
	onReturn(null);
}

function wavyFunc(environment, parameters, onReturn) {
	toggleTextEffect(environment, "wvy");
	onReturn(null);
}

function wavyPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("wvy")) {
		environment.GetDialogBuffer().popTextEffect("wvy");
	}
	onReturn(null);
}

function shakyFunc(environment, parameters, onReturn) {
	toggleTextEffect(environment, "shk");
	onReturn(null);
}

function shakyPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("shk")) {
		environment.GetDialogBuffer().popTextEffect("shk");
	}
	onReturn(null);
}

function propertyFunc(environment, parameters, onReturn) {
	var outValue = null;

	if (parameters.length > 0 && parameters[0]) {
		var propertyName = parameters[0];

		if (environment.HasProperty(propertyName)) {
			// TODO : in a future update I can handle the case of initializing a new property
			// after which we can move this block outside the HasProperty check
			if (parameters.length > 1) {
				var inValue = parameters[1];
				environment.SetProperty(propertyName, inValue);
			}

			outValue = environment.GetProperty(propertyName);
		}
	}

	bitsy.log("PROPERTY! " + propertyName + " " + outValue);

	onReturn(outValue);
}

function endFunc(environment,parameters,onReturn) {
	isEnding = true;
	isNarrating = true;
	dialogRenderer.SetCentered(true);
	dialogRenderer.DrawTextbox();
	onReturn(null);
}

function exitFunc(environment, parameters, onReturn) {
	var destRoom;
	var destX;
	var destY;

	if (parameters.length >= 1) {
		destRoom = parameters[0];

		// is it a name?
		if (names.room[destRoom] != undefined) {
			destRoom = names.room[destRoom];
		}
	}

	if (parameters.length >= 3) {
		destX = parseInt(parameters[1]);
		destY = parseInt(parameters[2]);
	}

	if (parameters.length >= 4) {
		var transitionEffect = parameters[3];

		transition.BeginTransition(
			player().room,
			player().x,
			player().y,
			destRoom,
			destX,
			destY,
			transitionEffect);
		transition.UpdateTransition(0);
	}

	var movePlayerAndResumeScript = function() {
		if (destRoom != undefined && destX != undefined && destY != undefined) {
			// update world state
			player().room = destRoom;
			player().x = destX;
			player().y = destY;
			state.room = destRoom;

			// update game state
			initRoom(state.room);
		}

		if (dialogRenderer) {
			dialogRenderer.updateTextboxPosition();
		}

		// resume dialog script
		onReturn(state.room);
	};

	// TODO : this doesn't play nice with pagebreak because it thinks the dialog is finished!
	if (transition.IsTransitionActive()) {
		transition.OnTransitionComplete(movePlayerAndResumeScript);
	}
	else {
		movePlayerAndResumeScript();
	}
}

function tuneFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var tuneId = parameters[0];

		// check if id parameter is actually a name
		if (names.tune[tuneId] != undefined) {
			tuneId = names.tune[tuneId];
		}

		if (soundPlayer) {
			if (tuneId === "0") {
				soundPlayer.stopTune();
			}
			else if (state.tune != tuneId) {
				soundPlayer.playTune(tune[tuneId]);
			}
		}

		state.tune = tuneId;
	}

	onReturn(state.tune);
}

function blipFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var blipId = parameters[0];

		// check if id parameter is actually a name
		if (names.blip[blipId] != undefined) {
			blipId = names.blip[blipId];
		}

		soundPlayer.playBlip(blip[blipId]);
	}

	// if a dialog skip is happening, stop it and force a redraw of the textbox
	if (dialogBuffer) {
		if (dialogBuffer.tryInterruptSkip()) {
			dialogRenderer.Draw(dialogBuffer, 0, true /* disableOnPrint */);
		}
	}

	onReturn(null);
}

/*
// TODO : use later?
function yakFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var blipId = parameters[0];

		// check if id parameter is actually a name
		if (names.blip[blipId] != undefined) {
			blipId = names.blip[blipId];
		}

		environment.GetDialogBuffer().pushTextEffect("yak", [blipId]);
	}

	onReturn(null);
}

function yakPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("yak")) {
		environment.GetDialogBuffer().popTextEffect("yak");
	}

	onReturn(null);
}
*/

function paletteFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var palId = parameters[0];

		// check if id parameter is actually a name
		if (names.palette[palId] != undefined) {
			palId = names.palette[palId];
		}

		updatePalette(palId);
	}

	onReturn(state.pal);
}

function avatarFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var sprId = parameters[0];

		// check if id parameter is actually a name
		if (names.sprite[sprId] != undefined) {
			sprId = names.sprite[sprId];
		}

		// override the avatar's current appearance
		state.ava = sprId;

		// redraw the avatar with its new appearance
		drawRoom(room[state.room], { redrawAvatar: true });
	}

	onReturn(state.ava);
}

/* BUILT-IN OPERATORS */
function setExp(environment,left,right,onReturn) {
	// bitsy.log("SET " + left.name);

	if(left.type != "variable") {
		// not a variable! return null and hope for the best D:
		onReturn( null );
		return;
	}

	right.Eval(environment,function(rVal) {
		environment.SetVariable( left.name, rVal );
		// bitsy.log("VAL " + environment.GetVariable( left.name ) );
		left.Eval(environment,function(lVal) {
			onReturn( lVal );
		});
	});
}
function equalExp(environment,left,right,onReturn) {
	// bitsy.log("EVAL EQUAL");
	// bitsy.log(left);
	// bitsy.log(right);
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal === rVal );
		});
	});
}
function greaterExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal > rVal );
		});
	});
}
function lessExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal < rVal );
		});
	});
}
function greaterEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal >= rVal );
		});
	});
}
function lessEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal <= rVal );
		});
	});
}
function multExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal * rVal );
		});
	});
}
function divExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal / rVal );
		});
	});
}
function addExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal + rVal );
		});
	});
}
function subExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal - rVal );
		});
	});
}

/* ENVIRONMENT */
var Environment = function() {
	var dialogBuffer = null;
	this.SetDialogBuffer = function(buffer) { dialogBuffer = buffer; };
	this.GetDialogBuffer = function() { return dialogBuffer; };

	var functionMap = {};

	// dialog
	functionMap["say"] = sayFunc;
	functionMap["br"] = linebreakFunc;
	functionMap["pg"] = pagebreakFunc;

	// text effects
	functionMap["wvy"] = wavyFunc;
	functionMap["/wvy"] = wavyPopFunc;
	functionMap["shk"] = shakyFunc;
	functionMap["/shk"] = shakyPopFunc;
	functionMap["rbw"] = rainbowFunc;
	functionMap["/rbw"] = rainbowPopFunc;
	functionMap["clr"] = colorFunc;
	functionMap["/clr"] = colorPopFunc;
	// drawing text effects
	functionMap["drwt"] = drawTileFunc;
	functionMap["drws"] = drawSpriteFunc;
	functionMap["drwi"] = drawItemFunc;

	// room
	functionMap["end"] = endFunc;
	functionMap["exit"] = exitFunc;
	functionMap["pal"] = paletteFunc;
	functionMap["ava"] = avatarFunc;

	// inventory & variables
	functionMap["item"] = itemFunc;
	functionMap["property"] = propertyFunc;

	// sound
	functionMap["tune"] = tuneFunc;
	functionMap["blip"] = blipFunc;

	// legacy
	functionMap["clr1"] = color1Func;
	functionMap["clr2"] = color2Func;
	functionMap["clr3"] = color3Func;
	functionMap["print"] = sayFunc;
	functionMap["printTile"] = drawTileFunc;
	functionMap["printSprite"] = drawSpriteFunc;
	functionMap["printItem"] = drawItemFunc;

	// DEBUG
	functionMap["_debugOnlyPrintFont"] = printFontFunc;

	// EXPERIMENTAL
	// functionMap["yak"] = yakFunc;
	// functionMap["/yak"] = yakPopFunc;

	this.HasFunction = function(name) { return functionMap[name] != undefined; };
	this.EvalFunction = function(name,parameters,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		functionMap[name](env, parameters, onReturn);
	}

	var variableMap = {};

	this.HasVariable = function(name) { return variableMap[name] != undefined; };
	this.GetVariable = function(name) { return variableMap[name]; };
	this.SetVariable = function(name,value,useHandler) {
		// bitsy.log("SET VARIABLE " + name + " = " + value);
		if(useHandler === undefined) useHandler = true;
		variableMap[name] = value;
		if(onVariableChangeHandler != null && useHandler){
			onVariableChangeHandler(name);
		}
	};
	this.DeleteVariable = function(name,useHandler) {
		if(useHandler === undefined) useHandler = true;
		if(variableMap[name] != undefined) {
			variableMap.delete(name);
			if(onVariableChangeHandler != null && useHandler) {
				onVariableChangeHandler(name);
			}
		}
	};

	var operatorMap = {};
	operatorMap["="] = setExp;
	operatorMap["=="] = equalExp;
	operatorMap[">"] = greaterExp;
	operatorMap["<"] = lessExp;
	operatorMap[">="] = greaterEqExp;
	operatorMap["<="] = lessEqExp;
	operatorMap["*"] = multExp;
	operatorMap["/"] = divExp;
	operatorMap["+"] = addExp;
	operatorMap["-"] = subExp;

	this.HasOperator = function(sym) { return operatorMap[sym] != undefined; };
	this.EvalOperator = function(sym,left,right,onReturn) {
		operatorMap[ sym ]( this, left, right, onReturn );
	}

	var scriptMap = {};
	this.HasScript = function(name) { return scriptMap[name] != undefined; };
	this.GetScript = function(name) { return scriptMap[name]; };
	this.SetScript = function(name,script) { scriptMap[name] = script; };

	var onVariableChangeHandler = null;
	this.SetOnVariableChangeHandler = function(onVariableChange) {
		onVariableChangeHandler = onVariableChange;
	}
	this.GetVariableNames = function() {
		var variableNames = [];

		for (var key in variableMap) {
			variableNames.push(key);
		}

		return variableNames;
	}
}

// Local environment for a single run of a script: knows local context
var LocalEnvironment = function(parentEnvironment) {
	// this.SetDialogBuffer // not allowed in local environment?
	this.GetDialogBuffer = function() { return parentEnvironment.GetDialogBuffer(); };

	this.HasFunction = function(name) { return parentEnvironment.HasFunction(name); };
	this.EvalFunction = function(name,parameters,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		parentEnvironment.EvalFunction(name,parameters,onReturn,env);
	}

	this.HasVariable = function(name) { return parentEnvironment.HasVariable(name); };
	this.GetVariable = function(name) { return parentEnvironment.GetVariable(name); };
	this.SetVariable = function(name,value,useHandler) { parentEnvironment.SetVariable(name,value,useHandler); };
	// this.DeleteVariable // not needed in local environment?

	this.HasOperator = function(sym) { return parentEnvironment.HasOperator(sym); };
	this.EvalOperator = function(sym,left,right,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		parentEnvironment.EvalOperator(sym,left,right,onReturn,env);
	};

	// TODO : I don't *think* any of this is required by the local environment
	// this.HasScript
	// this.GetScript
	// this.SetScript

	// TODO : pretty sure these debug methods aren't required by the local environment either
	// this.SetOnVariableChangeHandler
	// this.GetVariableNames

	/* Here's where specific local context data goes:
	 * this includes access to the object running the script
	 * and any properties it may have (so far only "locked")
	 */

	// The local environment knows what object called it -- currently only used to access properties
	var curObject = null;
	this.HasObject = function() { return curObject != undefined && curObject != null; }
	this.SetObject = function(object) { curObject = object; }
	this.GetObject = function() { return curObject; }

	// accessors for properties of the object that's running the script
	this.HasProperty = function(name) {
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			return true;
		}
		else {
			return false;
		}
	};
	this.GetProperty = function(name) {
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			return curObject.property[name]; // TODO : should these be getters and setters instead?
		}
		else {
			return null;
		}
	};
	this.SetProperty = function(name, value) {
		// NOTE : for now, we need to gaurd against creating new properties
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			curObject.property[name] = value;
		}
	};
}

function leadingWhitespace(depth) {
	var str = "";
	for(var i = 0; i < depth; i++) {
		str += "  "; // two spaces per indent
	}
	// bitsy.log("WHITESPACE " + depth + " ::" + str + "::");
	return str;
}

/* NODES */
var TreeRelationship = function() {
	this.parent = null;
	this.children = [];

	this.AddChild = function(node) {
		this.children.push(node);
		node.parent = this;
	};

	this.AddChildren = function(nodeList) {
		for (var i = 0; i < nodeList.length; i++) {
			this.AddChild(nodeList[i]);
		}
	};

	this.SetChildren = function(nodeList) {
		this.children = [];
		this.AddChildren(nodeList);
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);
		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.rootId = null; // for debugging
	this.GetId = function() {
		// bitsy.log(this);
		if (this.rootId != null) {
			return this.rootId;
		}
		else if (this.parent != null) {
			var parentId = this.parent.GetId();
			if (parentId != null) {
				return parentId + "_" + this.parent.children.indexOf(this);
			}
		}
		else {
			return null;
		}
	}
}

function DialogBlockNode(doIndentFirstLine) {
	TreeRelationship.call(this);

	this.type = "dialog_block";

	this.Eval = function(environment, onReturn) {
		// bitsy.log("EVAL BLOCK " + this.children.length);

		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children, done) {
			if (i < children.length) {
				// bitsy.log(">> CHILD " + i);
				children[i].Eval(environment, function(val) {
					// bitsy.log("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren(this.children, function() {
			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
				events.Raise("script_node_exit", { id: self.GetId() });
			}

			onReturn(lastVal);
		});
	}

	if (doIndentFirstLine === undefined) {
		doIndentFirstLine = true; // This is just for serialization
	}

	this.Serialize = function(depth) {
		if (depth === undefined) {
			depth = 0;
		}

		var str = "";
		var lastNode = null;

		for (var i = 0; i < this.children.length; i++) {

			var curNode = this.children[i];

			var shouldIndentFirstLine = (i == 0 && doIndentFirstLine);
			var shouldIndentAfterLinebreak = (lastNode && lastNode.type === "function" && lastNode.name === "br");

			if (shouldIndentFirstLine || shouldIndentAfterLinebreak) {
				str += leadingWhitespace(depth);
			}

			str += curNode.Serialize(depth);

			lastNode = curNode;
		}

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function CodeBlockNode() {
	TreeRelationship.call(this);

	this.type = "code_block";

	this.Eval = function(environment, onReturn) {
		// bitsy.log("EVAL BLOCK " + this.children.length);

		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children, done) {
			if (i < children.length) {
				// bitsy.log(">> CHILD " + i);
				children[i].Eval(environment, function(val) {
					// bitsy.log("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren(this.children, function() {
			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
				events.Raise("script_node_exit", { id: self.GetId() });
			}

			onReturn(lastVal);
		});
	}

	this.Serialize = function(depth) {
		if(depth === undefined) {
			depth = 0;
		}

		// bitsy.log("SERIALIZE BLOCK!!!");
		// bitsy.log(depth);
		// bitsy.log(doIndentFirstLine);

		var str = "{"; // todo: increase scope of Sym?

		// TODO : do code blocks ever have more than one child anymore????
		for (var i = 0; i < this.children.length; i++) {
			var curNode = this.children[i];
			str += curNode.Serialize(depth);
		}

		str += "}";

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function isInlineCode(node) {
	return isTextEffectBlock(node) || isUndefinedBlock(node) || isMultilineListBlock(node);
}

function isUndefinedBlock(node) {
	return node.type === "code_block" && node.children.length > 0 && node.children[0].type === "undefined";
}

var textEffectBlockNames = ["clr1", "clr2", "clr3", "wvy", "shk", "rbw", "printSprite", "printItem", "printTile", "print", "say", "br"];
function isTextEffectBlock(node) {
	if (node.type === "code_block") {
		if (node.children.length > 0 && node.children[0].type === "function") {
			var func = node.children[0];
			return textEffectBlockNames.indexOf(func.name) != -1;
		}
	}
	return false;
}

var listBlockTypes = ["sequence", "cycle", "shuffle", "if"];
function isMultilineListBlock(node) {
	if (node.type === "code_block") {
		if (node.children.length > 0) {
			var child = node.children[0];
			return listBlockTypes.indexOf(child.type) != -1;
		}
	}
	return false;
}

// for round-tripping undefined code through the parser (useful for hacks!)
function UndefinedNode(sourceStr) {
	TreeRelationship.call(this);

	this.type = "undefined";
	this.source = sourceStr;

	this.Eval = function(environment,onReturn) {
		toggleTextEffect(environment, "_debug_highlight");
		sayFunc(environment, ["{" + sourceStr + "}"], function() {
			onReturn(null);
		});
		toggleTextEffect(environment, "_debug_highlight");
	}

	this.Serialize = function(depth) {
		return this.source;
	}

	this.ToString = function() {
		return "undefined" + " " + this.GetId();
	}
}

function FuncNode(name, args) {
	TreeRelationship.call(this);

	this.type = "function";
	this.name = name;
	this.args = args;

	this.Eval = function(environment,onReturn) {
		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var self = this; // hack to deal with scope (TODO : move up higher?)

		var argumentValues = [];
		var i = 0;

		function evalArgs(args, done) {
			// TODO : really hacky way to make we get the first
			// symbol's NAME instead of its variable value
			// if we are trying to do something with a property
			if (self.name === "property" && i === 0 && i < args.length) {
				if (args[i].type === "variable") {
					argumentValues.push(args[i].name);
					i++;
				}
				else {
					// first argument for a property MUST be a variable symbol
					// -- so skip everything if it's not!
					i = args.length;
				}
			}

			if (i < args.length) {
				// Evaluate each argument
				args[i].Eval(
					environment,
					function(val) {
						argumentValues.push(val);
						i++;
						evalArgs(args, done);
					});
			}
			else {
				done();
			}
		};

		evalArgs(
			this.args,
			function() {
				if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
					events.Raise("script_node_exit", { id: self.GetId() });
				}

				environment.EvalFunction(self.name, argumentValues, onReturn);
			});
	}

	this.Serialize = function(depth) {
		var isDialogBlock = this.parent.type === "dialog_block";
		if (isDialogBlock && this.name === "say") {
			// TODO this could cause problems with "real" print functions
			return this.args[0].value; // first argument should be the text of the {print} func
		}
		else if (isDialogBlock && this.name === "br") {
			return "\n";
		}
		else {
			var str = "";
			str += this.name;
			for(var i = 0; i < this.args.length; i++) {
				str += " ";
				str += this.args[i].Serialize(depth);
			}
			return str;
		}
	}

	this.ToString = function() {
		return this.type + " " + this.name + " " + this.GetId();
	};
}

function LiteralNode(value) {
	TreeRelationship.call(this);

	this.type = "literal";
	this.value = value;

	this.Eval = function(environment,onReturn) {
		onReturn(this.value);
	};

	this.Serialize = function(depth) {
		var str = "";

		if (this.value === null) {
			return str;
		}

		if (typeof this.value === "string") {
			str += '"';
		}

		str += this.value;

		if (typeof this.value === "string") {
			str += '"';
		}

		return str;
	};

	this.ToString = function() {
		return this.type + " " + this.value + " " + this.GetId();
	};
}

function VarNode(name) {
	TreeRelationship.call(this);

	this.type = "variable";
	this.name = name;

	this.Eval = function(environment,onReturn) {
		// bitsy.log("EVAL " + this.name + " " + environment.HasVariable(this.name) + " " + environment.GetVariable(this.name));
		if( environment.HasVariable(this.name) )
			onReturn( environment.GetVariable( this.name ) );
		else
			onReturn(null); // not a valid variable -- return null and hope that's ok
	} // TODO: might want to store nodes in the variableMap instead of values???

	this.Serialize = function(depth) {
		var str = "" + this.name;
		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.name + " " + this.GetId();
	};
}

function ExpNode(operator, left, right) {
	TreeRelationship.call(this);

	this.type = "operator";
	this.operator = operator;
	this.left = left;
	this.right = right;

	this.Eval = function(environment,onReturn) {
		// bitsy.log("EVAL " + this.operator);
		var self = this; // hack to deal with scope
		environment.EvalOperator( this.operator, this.left, this.right, 
			function(val){
				// bitsy.log("EVAL EXP " + self.operator + " " + val);
				onReturn(val);
			} );
		// NOTE : sadly this pushes a lot of complexity down onto the actual operator methods
	};

	this.Serialize = function(depth) {
		var isNegativeNumber = this.operator === "-" && this.left.type === "literal" && this.left.value === null;

		if (!isNegativeNumber) {
			var str = "";

			if (this.left != undefined && this.left != null) {
				str += this.left.Serialize(depth) + " ";
			}

			str += this.operator;

			if (this.right != undefined && this.right != null) {
				str += " " + this.right.Serialize(depth);
			}

			return str;
		}
		else {
			return this.operator + this.right.Serialize(depth); // hacky but seems to work
		}
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		if(this.left != null)
			this.left.VisitAll( visitor, depth + 1 );
		if(this.right != null)
			this.right.VisitAll( visitor, depth + 1 );
	};

	this.ToString = function() {
		return this.type + " " + this.operator + " " + this.GetId();
	};
}

function SequenceBase() {
	TreeRelationship.call(this);

	this.Serialize = function(depth) {
		var str = "";
		str += this.type + "\n";
		for (var i = 0; i < this.children.length; i++) {
			str += leadingWhitespace(depth + 1) + Sym.List + " ";
			str += this.children[i].Serialize(depth + 2);
			str += "\n";
		}
		str += leadingWhitespace(depth);
		return str;
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);
		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function SequenceNode(options) {
	SequenceBase.call(this);

	this.type = "sequence";
	this.AddChildren(options);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		// bitsy.log("SEQUENCE " + index);
		this.children[index].Eval(environment, onReturn);

		var next = index + 1;
		if (next < this.children.length) {
			index = next;
		}
	}
}

function CycleNode(options) {
	SequenceBase.call(this);

	this.type = "cycle";
	this.AddChildren(options);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		// bitsy.log("CYCLE " + index);
		this.children[index].Eval(environment, onReturn);

		var next = index + 1;
		if (next < this.children.length) {
			index = next;
		}
		else {
			index = 0;
		}
	}
}

function ShuffleNode(options) {
	SequenceBase.call(this);

	this.type = "shuffle";
	this.AddChildren(options);

	var optionsShuffled = [];
	function shuffle(options) {
		optionsShuffled = [];
		var optionsUnshuffled = options.slice();
		while (optionsUnshuffled.length > 0) {
			var i = Math.floor(Math.random() * optionsUnshuffled.length);
			optionsShuffled.push(optionsUnshuffled.splice(i,1)[0]);
		}
	}
	shuffle(this.children);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		optionsShuffled[index].Eval(environment, onReturn);
		
		index++;
		if (index >= this.children.length) {
			shuffle(this.children);
			index = 0;
		}
	}
}

// TODO : rename? ConditionalNode?
function IfNode(conditions, results, isSingleLine) {
	TreeRelationship.call(this);

	this.type = "if";

	for (var i = 0; i < conditions.length; i++) {
		this.AddChild(new ConditionPairNode(conditions[i], results[i]));
	}

	var self = this;
	this.Eval = function(environment, onReturn) {
		// bitsy.log("EVAL IF");
		var i = 0;
		function TestCondition() {
			self.children[i].Eval(environment, function(result) {
				if (result.conditionValue == true) {
					onReturn(result.resultValue);
				}
				else if (i+1 < self.children.length) {
					i++;
					TestCondition();
				}
				else {
					onReturn(null);
				}
			});
		};
		TestCondition();
	};

	if (isSingleLine === undefined) {
		isSingleLine = false; // This is just for serialization
	}

	this.Serialize = function(depth) {
		var str = "";
		if(isSingleLine) {
			// HACKY - should I even keep this mode???
			str += this.children[0].children[0].Serialize() + " ? " + this.children[0].children[1].Serialize();
			if (this.children.length > 1 && this.children[1].children[0].type === Sym.Else) {
				str += " " + Sym.ElseExp + " " + this.children[1].children[1].Serialize();
			}
		}
		else {
			str += "\n";
			for (var i = 0; i < this.children.length; i++) {
				str += this.children[i].Serialize(depth);
			}
			str += leadingWhitespace(depth);
		}
		return str;
	};

	this.IsSingleLine = function() {
		return isSingleLine;
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);

		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll(visitor, depth + 1);
		}
	};

	this.ToString = function() {
		return this.type + " " + this.mode + " " + this.GetId();
	};
}

function ConditionPairNode(condition, result) {
	TreeRelationship.call(this);

	this.type = "condition_pair";

	this.AddChild(condition);
	this.AddChild(result);

	var self = this;

	this.Eval = function(environment, onReturn) {
		self.children[0].Eval(environment, function(conditionSuccess) {
			if (conditionSuccess) {
				self.children[1].Eval(environment, function(resultValue) {
					onReturn({ conditionValue:true, resultValue:resultValue });
				});
			}
			else {
				onReturn({ conditionValue:false });
			}
		});
	};

	this.Serialize = function(depth) {
		var str = "";
		str += leadingWhitespace(depth + 1);
		str += Sym.List + " " + this.children[0].Serialize(depth) + " " + Sym.ConditionEnd + Sym.Linebreak;
		str += this.children[1].Serialize(depth + 2) + Sym.Linebreak;
		return str;
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);

		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll(visitor, depth + 1);
		}
	};

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function ElseNode() {
	TreeRelationship.call(this);

	this.type = Sym.Else;

	this.Eval = function(environment, onReturn) {
		onReturn(true);
	};

	this.Serialize = function() {
		return Sym.Else;
	};

	this.ToString = function() {
		return this.type + " " + this.mode + " " + this.GetId();
	};
}

var Sym = {
	DialogOpen : '"""',
	DialogClose : '"""',
	CodeOpen : "{",
	CodeClose : "}",
	Linebreak : "\n", // just call it "break" ?
	Separator : ":",
	List : "-",
	String : '"',
	ConditionEnd : "?",
	Else : "else",
	ElseExp : ":", // special shorthand for expressions (deprecate?)
	Set : "=",
	Operators : ["==", ">=", "<=", ">", "<", "-", "+", "/", "*"], // operators need to be in reverse order of precedence
};

var Parser = function(env) {
	var environment = env;

	this.Parse = function(scriptStr, rootId) {
		var rootNode = new DialogBlockNode();
		rootNode.rootId = rootId;
		var state = new ParserState(rootNode, scriptStr);

		if (state.MatchAhead(Sym.DialogOpen)) {
			// multi-line dialog block
			var dialogStr = state.ConsumeBlock(Sym.DialogOpen + Sym.Linebreak, Sym.Linebreak + Sym.DialogClose);
			rootNode = new DialogBlockNode();
			rootNode.rootId = rootId; // hacky!!
			state = new ParserState(rootNode, dialogStr);
			state = ParseDialog(state);
		}
		else {
			// single-line dialog block
			state = ParseDialog(state);
		}

		return state.rootNode;
	};

	var ParserState = function( rootNode, str ) {
		this.rootNode = rootNode;
		this.curNode = this.rootNode;

		var sourceStr = str;
		var i = 0;
		this.Index = function() { return i; };
		this.Count = function() { return sourceStr.length; };
		this.Done = function() { return i >= sourceStr.length; };
		this.Char = function() { return sourceStr[i]; };
		this.Step = function(n) { if(n===undefined) n=1; i += n; };
		this.MatchAhead = function(str) {
			// bitsy.log(str);
			str = "" + str; // hack to turn single chars into strings
			// bitsy.log(str);
			// bitsy.log(str.length);
			for (var j = 0; j < str.length; j++) {
				if (i + j >= sourceStr.length) {
					return false;
				}
				else if (str[j] != sourceStr[i+j]) {
					return false;
				}
			}
			return true;
		}
		this.Peak = function(end) {
			var str = "";
			var j = i;
			// bitsy.log(j);
			while (j < sourceStr.length && end.indexOf(sourceStr[j]) == -1) {
				str += sourceStr[j];
				j++;
			}
			// bitsy.log("PEAK ::" + str + "::");
			return str;
		}
		this.ConsumeBlock = function(open, close, includeSymbols) {
			if (includeSymbols === undefined || includeSymbols === null) {
				includeSymbols = false;
			}

			var startIndex = i;

			var matchCount = 0;
			if (this.MatchAhead(open)) {
				matchCount++;
				this.Step(open.length);
			}

			while (matchCount > 0 && !this.Done()) {
				if (this.MatchAhead(close)) {
					matchCount--;
					this.Step( close.length );
				}
				else if (this.MatchAhead(open)) {
					matchCount++;
					this.Step(open.length);
				}
				else {
					this.Step();
				}
			}

			if (includeSymbols) {
				return sourceStr.slice(startIndex, i);
			}
			else {
				return sourceStr.slice(startIndex + open.length, i - close.length);
			}
		}

		this.Print = function() { bitsy.log(sourceStr); };
		this.Source = function() { return sourceStr; };
	};

	/*
		ParseDialog():
		This function adds {print} nodes and linebreak {br} nodes to display text,
		interleaved with bracketed code nodes for functions and flow control,
		such as text effects {shk} {wvy} or sequences like {cycle} and {shuffle}.
		The parsing of those code blocks is handled by ParseCode.

		Note on parsing newline characters:
		- there should be an implicit linebreak {br} after each dialog line
		- a "dialog line" is defined as any line that either:
			- 1) contains dialog text (any text outside of a code block)
			- 2) is entirely empty (no text, no code)
			- *or* 3) contains a list block (sequence, cycle, shuffle, or conditional)
		- lines *only* containing {code} blocks are not dialog lines

		NOTE TO SELF: all the state I'm storing in here feels like
		evidence that the parsing system kind of broke down at this point :(
		Maybe it would feel better if I move into the "state" object
	*/
	function ParseDialog(state) {
		var curLineNodeList = [];
		var curText = "";
		var curLineIsEmpty = true;
		var curLineContainsDialogText = false;
		var prevLineIsDialogLine = false;

		var curLineIsDialogLine = function() {
			return curLineContainsDialogText || curLineIsEmpty;
		}

		var resetLineStateForNewLine = function() {
			prevLineIsDialogLine = curLineIsDialogLine();
			curLineContainsDialogText = false;
			curLineIsEmpty = true;
			curText = "";
			curLineNodeList = [];
		}

		var tryAddTextNodeToList = function() {
			if (curText.length > 0) {
				var sayNode = new FuncNode("say", [new LiteralNode(curText)]);
				curLineNodeList.push(sayNode);

				curText = "";
				curLineIsEmpty = false;
				curLineContainsDialogText = true;
			}
		}

		var addCodeNodeToList = function() {
			var codeSource = state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);
			var codeState = new ParserState(new CodeBlockNode(), codeSource);
			codeState = ParseCode(codeState);
			var codeBlockNode = codeState.rootNode;
			curLineNodeList.push(codeBlockNode);

			curLineIsEmpty = false;

			// lists count as dialog text, because they can contain it
			if (isMultilineListBlock(codeBlockNode)) {
				curLineContainsDialogText = true;
			}
		}

		var tryAddLinebreakNodeToList = function() {
			if (prevLineIsDialogLine) {
				var linebreakNode = new FuncNode("br", []);
				curLineNodeList.unshift(linebreakNode);
			}
		}

		var addLineNodesToParent = function() {
			for (var i = 0; i < curLineNodeList.length; i++) {
				state.curNode.AddChild(curLineNodeList[i]);
			}
		}

		while (!state.Done()) {
			if (state.MatchAhead(Sym.CodeOpen)) { // process code block
				// add any buffered text to a print node, and parse the code
				tryAddTextNodeToList();
				addCodeNodeToList();
			}
			else if (state.MatchAhead(Sym.Linebreak)) { // process new line
				// add any buffered text to a print node, 
				// and add a linebreak if we are between two dialog lines
				tryAddTextNodeToList();
				tryAddLinebreakNodeToList();

				// since we've reached the end of a line
				// add stored nodes for this line to the parent node we are building,
				// and reset state for the next line
				addLineNodesToParent();
				resetLineStateForNewLine();

				state.Step();
			}
			else {
				// continue adding text to the current text buffer
				curText += state.Char();
				state.Step();
			}
		}

		// to make sure we don't leave anything behind:
		// add buffered text to a print node and add all nodes
		// to the current parent node
		tryAddTextNodeToList();
		tryAddLinebreakNodeToList();
		addLineNodesToParent();

		return state;
	}

	function ParseDialogBlock(state) {
		var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );

		var dialogState = new ParserState(new DialogBlockNode(), dialogStr);
		dialogState = ParseDialog( dialogState );

		state.curNode.AddChild( dialogState.rootNode );

		return state;
	}

	/*
		ParseConditional():
		A conditional contains a list of conditions that can be
		evaluated to true or false, followed by more dialog
		that will be evaluated if the condition is true. The first
		true condition is the one that gets evaluated.
	*/
	function ParseConditional(state) {
		var conditionStrings = [];
		var resultStrings = [];
		var curIndex = -1;
		var requiredLeadingWhitespace = -1;

		// TODO : very similar to sequence parsing - can we share anything?
		function parseConditionalItemLine(state) {
			var lineText = "";
			var whitespaceCount = 0;
			var isNewCondition = false;
			var encounteredNonWhitespace = false;
			var encounteredConditionEnd = false;

			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {
				// count whitespace until we hit the first non-whitespace character
				if (!encounteredNonWhitespace) {
					if (state.Char() === " " || state.Char() === "\t") {
						whitespaceCount++;
					}
					else {
						encounteredNonWhitespace = true;

						if (state.Char() === Sym.List) {
							isNewCondition = true;
							whitespaceCount += 2; // count the list seperator AND the following extra space
						}
					}
				}

				// if this is the condition, we need to track whether we've
				// reached the end of the condition
				if (isNewCondition && !encounteredConditionEnd) {
					if (state.Char() === Sym.ConditionEnd) {
						encounteredConditionEnd = true;
					}
				}

				// add characters one at a time, unless it's a code block
				// since code blocks can contain additional sequences inside
				// them that will mess up our list item detection
				if (state.Char() === Sym.CodeOpen) {
					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);
				}
				else {
					if (!encounteredConditionEnd) { // skip all characters including & after the condition end
						lineText += state.Char();
					}
					state.Step();
				}
			}

			if (state.Char() === Sym.Linebreak) {
				state.Step();
			}

			return { text:lineText, whitespace:whitespaceCount, isNewCondition:isNewCondition };
		}

		// TODO : this is copied from sequence parsing; share?
		function trimLeadingWhitespace(text, trimLength) {
			var textSplit = text.split(Sym.linebreak);
			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });
			return textSplit.join(Sym.linebreak);
		}

		while (!state.Done()) {
			var lineResults = parseConditionalItemLine(state);

			if (lineResults.isNewCondition) {
				requiredLeadingWhitespace = lineResults.whitespace;
				curIndex++;
				conditionStrings[curIndex] = "";
				resultStrings[curIndex] = "";
			}

			// to avoid extra newlines in nested conditionals, only count lines
			// that at least match the whitespace count of the initial line
			// NOTE: see the comment in sequence parsing for more details
			if (lineResults.whitespace >= requiredLeadingWhitespace) {
				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);

				if (lineResults.isNewCondition) {
					conditionStrings[curIndex] += trimmedText;
				}
				else {
					resultStrings[curIndex] += trimmedText + Sym.Linebreak;
				}
			}
		}

		// hack: cut off the trailing newlines from all the result strings
		resultStrings = resultStrings.map(function(result) { return result.slice(0,-1); });

		var conditions = [];
		for (var i = 0; i < conditionStrings.length; i++) {
			var str = conditionStrings[i].trim();
			if (str === Sym.Else) {
				conditions.push(new ElseNode());
			}
			else {
				var exp = CreateExpression(str);
				conditions.push(exp);
			}
		}

		var results = [];
		for (var i = 0; i < resultStrings.length; i++) {
			var str = resultStrings[i];
			var dialogBlockState = new ParserState(new DialogBlockNode(), str);
			dialogBlockState = ParseDialog(dialogBlockState);
			var dialogBlock = dialogBlockState.rootNode;
			results.push(dialogBlock);
		}

		state.curNode.AddChild(new IfNode(conditions, results));

		return state;
	}

	function IsSequence(str) {
		// bitsy.log("IsSequence? " + str);
		return str === "sequence" || str === "cycle" || str === "shuffle";
	}

	/*
		ParseSequence():
		Sequence nodes contain a list of dialog block nodes. The order those
		nodes are evaluated is determined by the type of sequence:
		- sequence: each child node evaluated once in order
		- cycle: repeats from the beginning after all nodes evaluate
		- shuffle: evaluate in a random order

		Each item in a sequence is sepearated by a "-" character.
		The seperator must come at the beginning of the line,
		but may be preceded by whitespace (in any amount).

		About whitespace: Whitespace at the start of a line
		is ignored if it less than or equal to the count of
		whitespace that preceded the list separator ("-") at
		the start of that item. (The count also includes the
		seperator and the extra space after the seperator.)
	 */
	function ParseSequence(state, sequenceType) {
		var itemStrings = [];
		var curItemIndex = -1; // -1 indicates not reading an item yet
		var requiredLeadingWhitespace = -1;

		function parseSequenceItemLine(state) {
			var lineText = "";
			var whitespaceCount = 0;
			var isNewListItem = false;
			var encounteredNonWhitespace = false;

			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {
				// count whitespace until we hit the first non-whitespace character
				if (!encounteredNonWhitespace) {
					if (state.Char() === " " || state.Char() === "\t") {
						whitespaceCount++;
					}
					else {
						encounteredNonWhitespace = true;

						if (state.Char() === Sym.List) {
							isNewListItem = true;
							whitespaceCount += 2; // count the list seperator AND the following extra space
						}
					}
				}

				// add characters one at a time, unless it's a code block
				// since code blocks can contain additional sequences inside
				// them that will mess up our list item detection
				if (state.Char() === Sym.CodeOpen) {
					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);
				}
				else {
					lineText += state.Char();
					state.Step();
				}
			}

			if (state.Char() === Sym.Linebreak) {
				state.Step();
			}

			return { text:lineText, whitespace:whitespaceCount, isNewListItem:isNewListItem };
		}

		function trimLeadingWhitespace(text, trimLength) {
			// the split and join is necessary because a single "line"
			// can contain sequences that may contain newlines of their own
			// (we treat them all as one "line" for sequence parsing purposes)
			var textSplit = text.split(Sym.linebreak);
			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });
			return textSplit.join(Sym.linebreak);
		}

		while (!state.Done()) {
			var lineResults = parseSequenceItemLine(state);

			if (lineResults.isNewListItem) {
				requiredLeadingWhitespace = lineResults.whitespace;
				curItemIndex++;
				itemStrings[curItemIndex] = "";
			}

			// to avoid double counting closing lines (empty ones ending in a curly brace)
			// we only allow lines that have at least as much whitespace as the start of the list item
			// TODO : I think right now this leads to a bug if the list item's indentation is less than
			// its parent code block... hopefully that won't be a big deal for now
			// (NOTE: I think the bug could be fixed by only applying this to the FINAL line of an item, but
			// that would require more consideration and testing)
			if (lineResults.whitespace >= requiredLeadingWhitespace) {
				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);
				itemStrings[curItemIndex] += trimmedText + Sym.Linebreak;
			}
		}

		// a bit hacky: cut off the trailing newlines from all the items
		itemStrings = itemStrings.map(function(item) { return item.slice(0,-1); });

		var options = [];
		for (var i = 0; i < itemStrings.length; i++) {
			var str = itemStrings[i];
			var dialogBlockState = new ParserState(new DialogBlockNode(false /* doIndentFirstLine */), str);
			dialogBlockState = ParseDialog(dialogBlockState);
			var dialogBlock = dialogBlockState.rootNode;
			options.push(dialogBlock);
		}

		if (sequenceType === "sequence") {
			state.curNode.AddChild(new SequenceNode(options));
		}
		else if (sequenceType === "cycle") {
			state.curNode.AddChild(new CycleNode(options));
		}
		else if (sequenceType === "shuffle") {
			state.curNode.AddChild(new ShuffleNode(options));
		}

		return state;
	}

	function ParseFunction(state, funcName) {
		bitsy.log("~~~ PARSE FUNCTION " + funcName);

		var args = [];

		var curSymbol = "";
		function OnSymbolEnd() {
			curSymbol = curSymbol.trim();
			// bitsy.log("PARAMTER " + curSymbol);
			args.push( StringToValue(curSymbol) );
			// bitsy.log(args);
			curSymbol = "";
		}

		while( !( state.Char() === "\n" || state.Done() ) ) {
			if( state.MatchAhead(Sym.CodeOpen) ) {
				var codeBlockState = new ParserState(new CodeBlockNode(), state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose));
				codeBlockState = ParseCode( codeBlockState );
				var codeBlock = codeBlockState.rootNode;
				args.push( codeBlock );
				curSymbol = "";
			}
			else if( state.MatchAhead(Sym.String) ) {
				/* STRING LITERAL */
				var str = state.ConsumeBlock(Sym.String, Sym.String);
				// bitsy.log("STRING " + str);
				args.push( new LiteralNode(str) );
				curSymbol = "";
			}
			else if(state.Char() === " " && curSymbol.length > 0) {
				OnSymbolEnd();
			}
			else {
				curSymbol += state.Char();
			}
			state.Step();
		}

		if(curSymbol.length > 0) {
			OnSymbolEnd();
		}

		state.curNode.AddChild( new FuncNode( funcName, args ) );

		return state;
	}

	function IsValidVariableName(str) {
		var reg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		var isValid = reg.test(str);
		// bitsy.log("VALID variable??? " + isValid);
		return isValid;
	}

	function StringToValue(valStr) {
		if(valStr[0] === Sym.CodeOpen) {
			// CODE BLOCK!!!
			var codeStr = (new ParserState( null, valStr )).ConsumeBlock(Sym.CodeOpen, Sym.CodeClose); //hacky
			var codeBlockState = new ParserState(new CodeBlockNode(), codeStr);
			codeBlockState = ParseCode( codeBlockState );
			return codeBlockState.rootNode;
		}
		else if(valStr[0] === Sym.String) {
			// STRING!!
			// bitsy.log("STRING");
			var str = "";
			var i = 1;
			while (i < valStr.length && valStr[i] != Sym.String) {
				str += valStr[i];
				i++;
			}
			// bitsy.log(str);
			return new LiteralNode( str );
		}
		else if(valStr === "true") {
			// BOOL
			return new LiteralNode( true );
		}
		else if(valStr === "false") {
			// BOOL
			return new LiteralNode( false );
		}
		else if( !isNaN(parseFloat(valStr)) ) {
			// NUMBER!!
			// bitsy.log("NUMBER!!! " + valStr);
			return new LiteralNode( parseFloat(valStr) );
		}
		else if(IsValidVariableName(valStr)) {
			// VARIABLE!!
			// bitsy.log("VARIABLE");
			return new VarNode(valStr); // TODO : check for valid potential variables
		}
		else {
			// uh oh
			return new LiteralNode(null);
		}
	}

	function CreateExpression(expStr) {
		expStr = expStr.trim();

		function IsInsideString(index) {
			var inString = false;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.String)
					inString = !inString;

				if(index === i)
					return inString;
			}
			return false;
		}

		function IsInsideCode(index) {
			var count = 0;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.CodeOpen)
					count++;
				else if(expStr[i] === Sym.CodeClose)
					count--;

				if(index === i)
					return count > 0;
			}
			return false;
		}

		var operator = null;

		// set is special because other operator can look like it, and it has to go first in the order of operations
		var setIndex = expStr.indexOf(Sym.Set);
		if( setIndex > -1 && !IsInsideString(setIndex) && !IsInsideCode(setIndex) ) { // it might be a set operator
			if( expStr[setIndex+1] != "=" && expStr[setIndex-1] != ">" && expStr[setIndex-1] != "<" ) {
				// ok it actually IS a set operator and not ==, >=, or <=
				operator = Sym.Set;
				var variableName = expStr.substring(0,setIndex).trim(); // TODO : valid variable name testing
				var left = IsValidVariableName(variableName) ? new VarNode( variableName ) : new LiteralNode(null);
				var right = CreateExpression( expStr.substring(setIndex+Sym.Set.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		// special if "expression" for single-line if statements
		var ifIndex = expStr.indexOf(Sym.ConditionEnd);
		if( ifIndex > -1 && !IsInsideString(ifIndex) && !IsInsideCode(ifIndex) ) {
			operator = Sym.ConditionEnd;
			var conditionStr = expStr.substring(0,ifIndex).trim();
			var conditions = [ CreateExpression(conditionStr) ];

			var resultStr = expStr.substring(ifIndex+Sym.ConditionEnd.length);
			var results = [];
			function AddResult(str) {
				var dialogBlockState = new ParserState(new DialogBlockNode(), str);
				dialogBlockState = ParseDialog( dialogBlockState );
				var dialogBlock = dialogBlockState.rootNode;
				results.push( dialogBlock );
			}

			var elseIndex = resultStr.indexOf(Sym.ElseExp); // does this need to test for strings?
			if(elseIndex > -1) {
				conditions.push( new ElseNode() );

				var elseStr = resultStr.substring(elseIndex+Sym.ElseExp.length);
				var resultStr = resultStr.substring(0,elseIndex);

				AddResult( resultStr.trim() );
				AddResult( elseStr.trim() );
			}
			else {
				AddResult( resultStr.trim() );
			}

			return new IfNode( conditions, results, true /*isSingleLine*/ );
		}

		for( var i = 0; (operator == null) && (i < Sym.Operators.length); i++ ) {
			var opSym = Sym.Operators[i];
			var opIndex = expStr.indexOf( opSym );
			if( opIndex > -1 && !IsInsideString(opIndex) && !IsInsideCode(opIndex) ) {
				operator = opSym;
				var left = CreateExpression( expStr.substring(0,opIndex) );
				var right = CreateExpression( expStr.substring(opIndex+opSym.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		if( operator == null ) {
			return StringToValue(expStr);
		}
	}
	this.CreateExpression = CreateExpression;

	function IsWhitespace(str) {
		return ( str === " " || str === "\t" || str === "\n" );
	}

	function IsExpression(str) {
		var tempState = new ParserState(null, str); // hacky
		var textOutsideCodeBlocks = "";

		while (!tempState.Done()) {
			if (tempState.MatchAhead(Sym.CodeOpen)) {
				tempState.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);
			}
			else {
				textOutsideCodeBlocks += tempState.Char();
				tempState.Step();
			}
		}

		var containsAnyExpressionOperators = (textOutsideCodeBlocks.indexOf(Sym.ConditionEnd) != -1) ||
				(textOutsideCodeBlocks.indexOf(Sym.Set) != -1) ||
				(Sym.Operators.some(function(opSym) { return textOutsideCodeBlocks.indexOf(opSym) != -1; }));

		return containsAnyExpressionOperators;
	}

	function IsLiteral(str) {
		var isBool = str === "true" || str === "false";
		var isNum = !isNaN(parseFloat(str));
		var isStr = str[0] === '"' && str[str.length-1] === '"';
		var isVar = IsValidVariableName(str);
		var isEmpty = str.length === 0;
		return isBool || isNum || isStr || isVar || isEmpty;
	}

	function ParseExpression(state) {
		var line = state.Source(); // state.Peak( [Sym.Linebreak] ); // TODO : remove the linebreak thing
		// bitsy.log("EXPRESSION " + line);
		var exp = CreateExpression(line);
		// bitsy.log(exp);
		state.curNode.AddChild(exp);
		state.Step(line.length);
		return state;
	}

	function IsConditionalBlock(state) {
		var peakToFirstListSymbol = state.Peak([Sym.List]);

		var foundListSymbol = peakToFirstListSymbol < state.Source().length;

		var areAllCharsBeforeListWhitespace = true;
		for (var i = 0; i < peakToFirstListSymbol.length; i++) {
			if (!IsWhitespace(peakToFirstListSymbol[i])) {
				areAllCharsBeforeListWhitespace = false;
			}
		}

		var peakToFirstConditionSymbol = state.Peak([Sym.ConditionEnd]);
		peakToFirstConditionSymbol = peakToFirstConditionSymbol.slice(peakToFirstListSymbol.length);
		var hasNoLinebreakBetweenListAndConditionEnd = peakToFirstConditionSymbol.indexOf(Sym.Linebreak) == -1;

		return foundListSymbol && 
			areAllCharsBeforeListWhitespace && 
			hasNoLinebreakBetweenListAndConditionEnd;
	}

	function ParseCode(state) {
		if (IsConditionalBlock(state)) {
			state = ParseConditional(state);
		}
		else if (environment.HasFunction(state.Peak([" "]))) { // TODO --- what about newlines???
			var funcName = state.Peak([" "]);
			state.Step(funcName.length);
			state = ParseFunction(state, funcName);
		}
		else if (IsSequence(state.Peak([" ", Sym.Linebreak]))) {
			var sequenceType = state.Peak([" ", Sym.Linebreak]);
			state.Step(sequenceType.length);
			state = ParseSequence(state, sequenceType);
		}
		else if (IsLiteral(state.Source()) || IsExpression(state.Source())) {
			state = ParseExpression(state);
		}
		else {
			var undefinedSrc = state.Peak([]);
			var undefinedNode = new UndefinedNode(undefinedSrc);
			state.curNode.AddChild(undefinedNode);
		}

		// just go to the end now
		while (!state.Done()) {
			state.Step();
		}

		return state;
	}

	function ParseCodeBlock(state) {
		var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );
		var codeState = new ParserState(new CodeBlockNode(), codeStr);
		codeState = ParseCode( codeState );
		state.curNode.AddChild( codeState.rootNode );
		return state;
	}

}

} // Script()
</script>

<script>
function Dialog() {

this.CreateRenderer = function() {
	return new DialogRenderer();
};

this.CreateBuffer = function() {
	return new DialogBuffer();
};

var DialogRenderer = function() {
	// TODO : refactor this eventually? remove everything from struct.. avoid the defaults?
	var textboxInfo = {
		width : 104,
		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow
		top : 12,
		left : 12,
		bottom : 12, //for drawing it from the bottom
		padding_vert : 2,
		padding_horz : 4,
		arrow_height : 5,
	};

	var font = null;
	this.SetFont = function(f) {
		font = f;
		textboxInfo.height = (textboxInfo.padding_vert * 3) + (relativeFontHeight() * 2) + textboxInfo.arrow_height;

		// todo : clean up all the scale stuff
		var textboxScaleW = textboxInfo.width * getTextScale();
		var textboxScaleH = textboxInfo.height * getTextScale();
		bitsy.textbox(false, 0, 0, textboxScaleW, textboxScaleH);
	}

	this.GetPixelsPerRow = function() {
		return (textboxInfo.width - (textboxInfo.padding_horz * 2)) * getTextScale();
	}

	// todo : cache this value? it shouldn't really change in the middle of a game
	function getTextScale() {
		return bitsy.textMode() === bitsy.TXT_LOREZ ? 1 : 2;
	}

	function relativeFontWidth() {
		return Math.ceil(font.getWidth() / getTextScale());
	}

	function relativeFontHeight() {
		return Math.ceil(font.getHeight() / getTextScale());
	}

	this.ClearTextbox = function() {
		bitsy.fill(bitsy.TEXTBOX, textBackgroundIndex);
	};

	var isCentered = false;
	this.SetCentered = function(centered) {
		isCentered = centered;
	};

	// todo : I can stop doing this every frame right?
	this.DrawTextbox = function() {
		if (isCentered) {
			// todo : will the height calculations always work?
			bitsy.textbox(true, textboxInfo.left, ((bitsy.VIDEO_SIZE / 2) - (textboxInfo.height / 2)));
		}
		else if (player().y < (bitsy.MAP_SIZE / 2)) {
			// bottom
			bitsy.textbox(true, textboxInfo.left, (bitsy.VIDEO_SIZE - textboxInfo.bottom - textboxInfo.height));
		}
		else {
			// top
			bitsy.textbox(true, textboxInfo.left, textboxInfo.top);
		}
	};

	var arrowdata = [
		1,1,1,1,1,
		0,1,1,1,0,
		0,0,1,0,0
	];

	this.DrawNextArrow = function() {
		// bitsy.log("draw arrow!");
		var text_scale = getTextScale();
		var textboxScaleW = textboxInfo.width * text_scale;
		var textboxScaleH = textboxInfo.height * text_scale;

		var top = (textboxInfo.height - 5) * text_scale;
		var left = (textboxInfo.width - (5 + 4)) * text_scale;
		if (textDirection === TextDirection.RightToLeft) { // RTL hack
			left = 4 * text_scale;
		}

		for (var y = 0; y < 3; y++) {
			for (var x = 0; x < 5; x++) {
				var i = (y * 5) + x;
				if (arrowdata[i] == 1) {
					//scaling nonsense
					for (var sy = 0; sy < text_scale; sy++) {
						for (var sx = 0; sx < text_scale; sx++) {
							var px = left + (x * text_scale) + sx;
							var py = top + (y * text_scale) + sy;
							bitsy.set(bitsy.TEXTBOX, (py * textboxScaleW) + px, textArrowIndex);
						}
					}
				}
			}
		}
	};

	function drawCharData(charData, textScale, top, left, width, height, color) {
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				var i = (y * width) + x;
				if (charData[i] == 1) {
					bitsy.set(bitsy.TEXTBOX, ((top + y) * (textboxInfo.width * textScale)) + (left + x), color);
				}
			}
		}
	}

	this.DrawChar = function(char, row, col, leftPos) {
		// characters with effects need to be redrawn every frame
		if (char.effectList.length > 0) {
			char.redraw = true;
		}

		// skip characters that are already drawn and don't need to be updated
		if (!char.redraw) {
			return;
		}
		char.redraw = false;

		var text_scale = getTextScale();
		var charData = char.bitmap;
		var top;
		var left;

		if (char.effectList.length > 0) {
			// clear the pixels from the previous frame
			top = (4 * text_scale) + (row * 2 * text_scale) + (row * font.getHeight()) + Math.floor(char.offset.y);
			left = (4 * text_scale) + leftPos + Math.floor(char.offset.x);
			drawCharData(charData, text_scale, top, left, char.width, char.height, textBackgroundIndex);
		}

		// compute render offset *every* frame
		char.offset = {
			x: char.base_offset.x,
			y: char.base_offset.y
		};
		char.SetPosition(row, col);
		char.ApplyEffects(effectTime);

		top = (4 * text_scale) + (row * 2 * text_scale) + (row * font.getHeight()) + Math.floor(char.offset.y);
		left = (4 * text_scale) + leftPos + Math.floor(char.offset.x);

		drawCharData(charData, text_scale, top, left, char.width, char.height, char.color);

		// TODO : consider for a future update?
		/*
		if (soundPlayer && char.blip && char.hasPlayedBlip != true) {
			soundPlayer.playBlip(blip[char.blip], { isPitchRandomized: true });
			char.hasPlayedBlip = true;
		}
		*/

		// call printHandler for character
		if (!disableOnPrintHandlers) {
			char.OnPrint();
		}
	};

	var effectTime = 0; // TODO this variable should live somewhere better

	var shouldUpdateTextboxSettings = true;
	var shouldClearTextbox = true;
	var shouldDrawArrow = true;

	var disableOnPrintHandlers = false;

	this.Draw = function(buffer, dt, disableOnPrint) {
		disableOnPrintHandlers = (disableOnPrint === true);

		// bitsy.log("draw dialog");
		if (buffer.DidFlipPageThisFrame()) {
			shouldClearTextbox = true;
			shouldDrawArrow = true;
		}

		effectTime += dt;

		if (shouldUpdateTextboxSettings) {
			bitsy.log("draw textbox");
			this.DrawTextbox(); // todo : rename to something more accurate
			shouldUpdateTextboxSettings = false;
		}

		if (shouldClearTextbox) {
			// bitsy.log("clear textbox");
			this.ClearTextbox();
			shouldClearTextbox = false;
		}

		// bitsy.log("draw chars");
		buffer.ForEachActiveChar(this.DrawChar);

		if (buffer.CanContinue() && shouldDrawArrow) {
			// bitsy.log("draw next arrow");
			this.DrawNextArrow();
			shouldDrawArrow = false;
		}

		if (buffer.DidPageFinishThisFrame() && onPageFinish != null) {
			bitsy.log("page finished");
			onPageFinish();
		}

		// bitsy.log("draw dialog end");
	};

	/* this is a hook for GIF rendering */
	var onPageFinish = null;
	this.SetPageFinishHandler = function(handler) {
		onPageFinish = handler;
	};

	this.Reset = function() {
		effectTime = 0;
		// TODO - anything else?

		shouldUpdateTextboxSettings = true;
		shouldClearTextbox = true;
		shouldDrawArrow = true;
	}

	this.updateTextboxPosition = function() {
		shouldUpdateTextboxSettings = true;
	};

	// this.CharsPerRow = function() {
	// 	return textboxInfo.charsPerRow;
	// }
}

var DialogBuffer = function() {
	var buffer = [[[]]]; // holds dialog in an array buffer
	var pageIndex = 0;
	var rowIndex = 0;
	var charIndex = 0;
	var nextCharTimer = 0;
	var nextCharMaxTime = 50; // in milliseconds
	var isDialogReadyToContinue = false;
	var activeTextEffects = [];
	var activeTextEffectParameters = [];
	var font = null;
	var arabicHandler = new ArabicHandler();
	var onDialogEndCallbacks = [];

	this.SetFont = function(f) {
		font = f;
	};

	this.SetPixelsPerRow = function(n) {
		pixelsPerRow = n;
	};

	this.CurPage = function() { return buffer[ pageIndex ]; };
	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };
	this.CurChar = function() { return this.CurRow()[ charIndex ]; };
	this.CurPageCount = function() { return buffer.length; };
	this.CurRowCount = function() { return this.CurPage().length; };
	this.CurCharCount = function() { return this.CurRow().length; };

	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page
		var rowCount = rowIndex + 1;
		for (var i = 0; i < rowCount; i++) {
			var row = this.CurPage()[i];
			var charCount = (i == rowIndex) ? charIndex+1 : row.length;
			// bitsy.log(charCount);

			var leftPos = 0;
			if (textDirection === TextDirection.RightToLeft) {
				leftPos = 24 * 8; // hack -- I think this is correct?
			}

			for(var j = 0; j < charCount; j++) {
				var char = row[j];
				if(char) {
					if (textDirection === TextDirection.RightToLeft) {
						leftPos -= char.spacing;
					}
					// bitsy.log(j + " " + leftPos);

					// handler( char, i /*rowIndex*/, j /*colIndex*/ );
					handler(char, i /*rowIndex*/, j /*colIndex*/, leftPos)

					if (textDirection === TextDirection.LeftToRight) {
						leftPos += char.spacing;
					}
				}
			}
		}
	}

	this.Reset = function() {
		buffer = [[[]]];
		pageIndex = 0;
		rowIndex = 0;
		charIndex = 0;
		isDialogReadyToContinue = false;

		afterManualPagebreak = false;

		activeTextEffects = [];

		onDialogEndCallbacks = [];

		isActive = false;
	};

	this.DoNextChar = function() {
		nextCharTimer = 0; //reset timer

		//time to update characters
		if (charIndex + 1 < this.CurCharCount()) {
			//add char to current row
			charIndex++;
		}
		else if (rowIndex + 1 < this.CurRowCount()) {
			//start next row
			rowIndex++;
			charIndex = 0;
		}
		else {
			//the page is full!
			isDialogReadyToContinue = true;
			didPageFinishThisFrame = true;
		}

		if (this.CurChar() != null) {
			if (this.CurChar().isPageBreak) {
				// special case for page break marker character!
				isDialogReadyToContinue = true;
				didPageFinishThisFrame = true;
			}
			
			this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text
		}
	};

	this.Update = function(dt) {
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// this.Draw(dt); // TODO move into a renderer object
		if (isDialogReadyToContinue) {
			return; //waiting for dialog to be advanced by player
		}

		nextCharTimer += dt; //tick timer

		if (nextCharTimer > nextCharMaxTime) {
			this.DoNextChar();
		}
	};

	var isSkipping = false;

	this.Skip = function() {
		bitsy.log("SKIPPP");
		isSkipping = true;

		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;

		// add new characters until you get to the end of the current line of dialog
		while (rowIndex < this.CurRowCount() && isSkipping) {
			this.DoNextChar();

			if (isDialogReadyToContinue) {
				//make sure to push the rowIndex past the end to break out of the loop
				rowIndex++;
				charIndex = 0;
			}
		}

		if (isSkipping) {
			rowIndex = this.CurRowCount() - 1;
			charIndex = this.CurCharCount() - 1;
		}

		isSkipping = false;
	};

	this.tryInterruptSkip = function() {
		if (isSkipping) {
			isSkipping = false;
			return true;
		}

		return false;
	};

	this.FlipPage = function() {
		didFlipPageThisFrame = true;
		isDialogReadyToContinue = false;
		pageIndex++;
		rowIndex = 0;
		charIndex = 0;
	}

	this.EndDialog = function() {
		isActive = false; // no more text to show... this should be a sign to stop rendering dialog

		for (var i = 0; i < onDialogEndCallbacks.length; i++) {
			onDialogEndCallbacks[i]();
		}
	}

	var afterManualPagebreak = false; // is it bad to track this state like this?

	this.Continue = function() {
		bitsy.log("CONTINUE");

		// if we used a page break character to continue we need
		// to run whatever is in the script afterwards! // TODO : make this comment better
		if (this.CurChar().isPageBreak) {
			// hacky: always treat a page break as the end of dialog
			// if there's more dialog later we re-activate the dialog buffer
			this.EndDialog();
			afterManualPagebreak = true;
			this.CurChar().OnContinue();
			return false;
		}
		if (pageIndex + 1 < this.CurPageCount()) {
			bitsy.log("FLIP PAGE!");
			//start next page
			this.FlipPage();
			return true; /* hasMoreDialog */
		}
		else {
			bitsy.log("END DIALOG!");
			bitsy.textbox(false);
			//end dialog mode
			this.EndDialog();
			return false; /* hasMoreDialog */
		}
	};

	var isActive = false;
	this.IsActive = function() { return isActive; };

	this.OnDialogEnd = function(callback) {
		if (!isActive) {
			callback();
		}
		else {
			onDialogEndCallbacks.push(callback);
		}
	}

	this.CanContinue = function() { return isDialogReadyToContinue; };

	function DialogChar() {
		this.redraw = true;

		this.effectList = [];
		this.effectParameterList = [];

		this.color = textColorIndex; // white
		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)

		this.col = 0;
		this.row = 0;

		this.SetPosition = function(row,col) {
			// bitsy.log("SET POS");
			// bitsy.log(this);
			this.row = row;
			this.col = col;
		};

		this.ApplyEffects = function(time) {
			// bitsy.log("APPLY EFFECTS! " + time);
			for (var i = 0; i < this.effectList.length; i++) {
				var effectName = this.effectList[i];
				// bitsy.log("FX " + effectName);
				TextEffects[effectName].doEffect(this, time, this.effectParameterList[i]);
			}
		};

		var printHandler = null; // optional function to be called once on printing character
		this.SetPrintHandler = function(handler) {
			printHandler = handler;
		};
		this.OnPrint = function() {
			if (printHandler != null) {
				// bitsy.log("PRINT HANDLER ---- DIALOG BUFFER");
				printHandler();
				printHandler = null; // only call handler once (hacky)
			}
		};

		this.bitmap = [];
		this.width = 0;
		this.height = 0;
		this.base_offset = { // hacky name
 			x: 0,
			y: 0
		};
		this.spacing = 0;
	}

	function DialogFontChar(font, char, effectList, effectParameterList) {
		DialogChar.call(this);

		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)
		this.effectParameterList = effectParameterList.slice();

		var charData = font.getChar(char);
		this.char = char;
		this.bitmap = charData.data;
		this.width = charData.width;
		this.height = charData.height;
		this.base_offset.x = charData.offset.x;
		this.base_offset.y = charData.offset.y;
		this.spacing = charData.spacing;
		this.blip = null;
		this.hasPlayedBlip = false;
	}

	function DialogDrawingChar(drawingId, effectList, effectParameterList) {
		DialogChar.call(this);

		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)
		this.effectParameterList = effectParameterList.slice();

		// get the first frame of the drawing and flatten it
		var drawingData = renderer.GetDrawingSource(drawingId)[0];
		var drawingDataFlat = [];
		for (var i = 0; i < drawingData.length; i++) {
			drawingDataFlat = drawingDataFlat.concat(drawingData[i]);
		}

		this.bitmap = drawingDataFlat;
		this.width = 8;
		this.height = 8;
		this.spacing = 8;
	}

	function DialogScriptControlChar() {
		DialogChar.call(this);

		this.width = 0;
		this.height = 0;
		this.spacing = 0;
	}

	// is a control character really the best way to handle page breaks?
	function DialogPageBreakChar() {
		DialogChar.call(this);

		this.width = 0;
		this.height = 0;
		this.spacing = 0;

		this.isPageBreak = true;

		var continueHandler = null;

		this.SetContinueHandler = function(handler) {
			continueHandler = handler;
		};

		this.OnContinue = function() {
			if (continueHandler) {
				continueHandler();
			}
		};
	}

	function AddWordToCharArray(charArray, word, effectList, effectParameterList) {
		// bitsy.log("add char array");
		for (var i = 0; i < word.length; i++) {
			charArray.push(new DialogFontChar(font, word[i], effectList, effectParameterList));
		}
		// bitsy.log("add char array end");
		return charArray;
	}

	function GetCharArrayWidth(charArray) {
		var width = 0;
		for(var i = 0; i < charArray.length; i++) {
			width += charArray[i].spacing;
		}
		return width;
	}

	function GetStringWidth(str) {
		var width = 0;
		for (var i = 0; i < str.length; i++) {
			var charData = font.getChar(str[i]);
			width += charData.spacing;
		}
		return width;
	}

	var pixelsPerRow = 192; // hard-coded fun times!!!

	this.AddScriptReturn = function(onReturnHandler) {
		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var controlChar = new DialogScriptControlChar();
		controlChar.SetPrintHandler(onReturnHandler);

		curRowArr.push(controlChar);

		isActive = true;
	}

	this.AddDrawing = function(drawingId) {
		// bitsy.log("DRAWING ID " + drawingId);

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects, activeTextEffectParameters);

		var rowLength = GetCharArrayWidth(curRowArr);

		// TODO : clean up copy-pasted code here :/
		if (afterManualPagebreak) {
			this.FlipPage(); // hacky

			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);

			afterManualPagebreak = false;
		}
		else if (rowLength + drawingChar.spacing  <= pixelsPerRow || rowLength <= 0) {
			//stay on same row
			curRowArr.push(drawingChar);
		}
		else if (curRowIndex == 0) {
			//start next row
			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer[curPageIndex].push([]);
			curRowIndex++;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);
		}
		else {
			//start next page
			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);
		}

		isActive = true; // this feels like a bad way to do this???
	}

	// TODO : convert this into something that takes DialogChar arrays
	this.AddText = function(textStr) {
		bitsy.log("ADD TEXT >>" + textStr + "<<");

		//process dialog so it's easier to display
		var words = textStr.split(" ");

		// var curPageIndex = this.CurPageCount() - 1;
		// var curRowIndex = this.CurRowCount() - 1;
		// var curRowArr = this.CurRow();

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		for (var i = 0; i < words.length; i++) {
			var word = words[i];
			if (arabicHandler.ContainsArabicCharacters(word)) {
				word = arabicHandler.ShapeArabicCharacters(word);
			}

			var wordWithPrecedingSpace = ((i == 0) ? "" : " ") + word;
			var wordLength = GetStringWidth(wordWithPrecedingSpace);

			var rowLength = GetCharArrayWidth(curRowArr);

			if (afterManualPagebreak) {
				this.FlipPage();

				// hacky copied bit for page breaks
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer.push([]);
				curPageIndex++;
				buffer[curPageIndex].push([]);
				curRowIndex = 0;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);

				afterManualPagebreak = false;
			}
			else if (rowLength + wordLength <= pixelsPerRow || rowLength <= 0) {
				//stay on same row
				curRowArr = AddWordToCharArray(curRowArr, wordWithPrecedingSpace, activeTextEffects, activeTextEffectParameters);
			}
			else if (curRowIndex == 0) {
				//start next row
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer[curPageIndex].push([]);
				curRowIndex++;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);
			}
			else {
				//start next page
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer.push([]);
				curPageIndex++;
				buffer[curPageIndex].push([]);
				curRowIndex = 0;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);
			}
		}

		//destroy any empty stuff
		var lastPage = buffer[buffer.length-1];
		var lastRow = lastPage[lastPage.length-1];
		if (lastRow.length == 0) {
			lastPage.splice(lastPage.length-1, 1);
		}
		if (lastPage.length == 0) {
			buffer.splice(buffer.length-1, 1);
		}

		//finish up 
		lastPage = buffer[buffer.length-1];
		lastRow = lastPage[lastPage.length-1];
		if (lastRow.length > 0) {
			var lastChar = lastRow[lastRow.length-1];
		}

		// bitsy.log(buffer);

		bitsy.log("add text finished");

		isActive = true;
	};

	this.AddLinebreak = function() {
		var lastPage = buffer[buffer.length-1];
		if (lastPage.length <= 1) {
			// bitsy.log("LINEBREAK - NEW ROW ");
			// add new row
			lastPage.push([]);
		}
		else {
			// add new page
			buffer.push([[]]);
		}
		// bitsy.log(buffer);

		isActive = true;
	}

	this.AddPagebreak = function(onReturnHandler) {
		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		// need to actually create a whole new page if following another pagebreak character
		if (afterManualPagebreak) {
			this.FlipPage(); // hacky

			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];

			afterManualPagebreak = false;
		}

		var pagebreakChar = new DialogPageBreakChar();
		pagebreakChar.SetContinueHandler(onReturnHandler);

		curRowArr.push(pagebreakChar);

		isActive = true;
	}

	this.hasTextEffect = function(name) {
		return activeTextEffects.indexOf(name) != -1;
	};

	this.pushTextEffect = function(name, parameters) {
		activeTextEffects.push(name);
		activeTextEffectParameters.push(parameters);
	};

	this.popTextEffect = function(name) {
		var i = activeTextEffects.lastIndexOf(name);
		activeTextEffects.splice(i, 1);
		activeTextEffectParameters.splice(i, 1);
	};

	/* this is a hook for GIF rendering */
	var didPageFinishThisFrame = false;
	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };

	var didFlipPageThisFrame = false;
	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };

	// this.SetCharsPerRow = function(num){ charsPerRow = num; }; // hacky
};

/* ARABIC */
var ArabicHandler = function() {

	var arabicCharStart = 0x0621;
	var arabicCharEnd = 0x064E;

	var CharacterForm = {
		Isolated : 0,
		Final : 1,
		Initial : 2,
		Middle : 3
	};

	// map glyphs to their character forms
	var glyphForms = {
		/*		 Isolated, Final, Initial, Middle Forms	*/
		0x0621: [0xFE80,0xFE80,0xFE80,0xFE80], /*  HAMZA  */ 
		0x0622: [0xFE81,0xFE82,0xFE81,0xFE82], /*  ALEF WITH MADDA ABOVE  */ 
		0x0623: [0xFE83,0xFE84,0xFE83,0xFE84], /*  ALEF WITH HAMZA ABOVE  */ 
		0x0624: [0xFE85,0xFE86,0xFE85,0xFE86], /*  WAW WITH HAMZA ABOVE  */ 
		0x0625: [0xFE87,0xFE88,0xFE87,0xFE88], /*  ALEF WITH HAMZA BELOW  */ 
		0x0626: [0xFE89,0xFE8A,0xFE8B,0xFE8C], /*  YEH WITH HAMZA ABOVE  */ 
		0x0627: [0xFE8D,0xFE8E,0xFE8D,0xFE8E], /*  ALEF  */ 
		0x0628: [0xFE8F,0xFE90,0xFE91,0xFE92], /*  BEH  */ 
		0x0629: [0xFE93,0xFE94,0xFE93,0xFE94], /*  TEH MARBUTA  */ 
		0x062A: [0xFE95,0xFE96,0xFE97,0xFE98], /*  TEH  */ 
		0x062B: [0xFE99,0xFE9A,0xFE9B,0xFE9C], /*  THEH  */ 
		0x062C: [0xFE9D,0xFE9E,0xFE9F,0xFEA0], /*  JEEM  */ 
		0x062D: [0xFEA1,0xFEA2,0xFEA3,0xFEA4], /*  HAH  */ 
		0x062E: [0xFEA5,0xFEA6,0xFEA7,0xFEA8], /*  KHAH  */ 
		0x062F: [0xFEA9,0xFEAA,0xFEA9,0xFEAA], /*  DAL  */ 
		0x0630: [0xFEAB,0xFEAC,0xFEAB,0xFEAC], /*  THAL */ 
		0x0631: [0xFEAD,0xFEAE,0xFEAD,0xFEAE], /*  RAA  */ 
		0x0632: [0xFEAF,0xFEB0,0xFEAF,0xFEB0], /*  ZAIN  */ 
		0x0633: [0xFEB1,0xFEB2,0xFEB3,0xFEB4], /*  SEEN  */ 
		0x0634: [0xFEB5,0xFEB6,0xFEB7,0xFEB8], /*  SHEEN  */ 
		0x0635: [0xFEB9,0xFEBA,0xFEBB,0xFEBC], /*  SAD  */ 
		0x0636: [0xFEBD,0xFEBE,0xFEBF,0xFEC0], /*  DAD  */ 
		0x0637: [0xFEC1,0xFEC2,0xFEC3,0xFEC4], /*  TAH  */ 
		0x0638: [0xFEC5,0xFEC6,0xFEC7,0xFEC8], /*  ZAH  */ 
		0x0639: [0xFEC9,0xFECA,0xFECB,0xFECC], /*  AIN  */ 
		0x063A: [0xFECD,0xFECE,0xFECF,0xFED0], /*  GHAIN  */ 
		0x063B: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063C: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063D: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063E: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063F: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x0640: [0x0640,0x0640,0x0640,0x0640], /*  TATWEEL  */ 
		0x0641: [0xFED1,0xFED2,0xFED3,0xFED4], /*  FAA  */ 
		0x0642: [0xFED5,0xFED6,0xFED7,0xFED8], /*  QAF  */ 
		0x0643: [0xFED9,0xFEDA,0xFEDB,0xFEDC], /*  KAF  */ 
		0x0644: [0xFEDD,0xFEDE,0xFEDF,0xFEE0], /*  LAM  */ 
		0x0645: [0xFEE1,0xFEE2,0xFEE3,0xFEE4], /*  MEEM  */ 
		0x0646: [0xFEE5,0xFEE6,0xFEE7,0xFEE8], /*  NOON  */ 
		0x0647: [0xFEE9,0xFEEA,0xFEEB,0xFEEC], /*  HEH  */ 
		0x0648: [0xFEED,0xFEEE,0xFEED,0xFEEE], /*  WAW  */ 
		0x0649: [0xFEEF,0xFEF0,0xFBE8,0xFBE9], /*  ALEF MAKSURA  */ 
		0x064A: [0xFEF1,0xFEF2,0xFEF3,0xFEF4], /*  YEH  */ 
		0x064B: [0xFEF5,0xFEF6,0xFEF5,0xFEF6], /*  LAM ALEF MADD*/
		0x064C: [0xFEF7,0xFEF8,0xFEF7,0xFEF8], /*  LAM ALEF HAMZA ABOVE*/
		0x064D: [0xFEF9,0xFEFa,0xFEF9,0xFEFa], /*  LAM ALEF HAMZA BELOW*/
		0x064E: [0xFEFb,0xFEFc,0xFEFb,0xFEFc], /*  LAM ALEF */
	};

	var disconnectedCharacters = [0x0621,0x0622,0x0623,0x0624,0x0625,0x0627,0x062f,0x0630,0x0631,0x0632,0x0648,0x0649,0x064b,0x064c,0x064d,0x064e];

	function IsArabicCharacter(char) {
		var code = char.charCodeAt(0);
		return (code >= arabicCharStart && code <= arabicCharEnd);
	}

	function ContainsArabicCharacters(word) {
		for (var i = 0; i < word.length; i++) {
			if (IsArabicCharacter(word[i])) {
				return true;
			}
		}
		return false;
	}

	function IsDisconnectedCharacter(char) {
		var code = char.charCodeAt(0);
		return disconnectedCharacters.indexOf(code) != -1;
	}

	function ShapeArabicCharacters(word) {
		var shapedWord = "";

		for (var i = 0; i < word.length; i++) {
			if (!IsArabicCharacter(word[i])) {
				shapedWord += word[i];
				continue;
			}

			var connectedToPreviousChar = i-1 >= 0 && IsArabicCharacter(word[i-1]) && !IsDisconnectedCharacter(word[i-1]);

			var connectedToNextChar = i+1 < word.length && IsArabicCharacter(word[i+1]) && !IsDisconnectedCharacter(word[i]);

			var form;
			if (!connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Isolated;
			}
			else if (connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Final;
			}
			else if (!connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Initial;
			}
			else if (connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Middle;
			}

			var code = word[i].charCodeAt(0);

			// handle lam alef special case
			if (code == 0x0644 && connectedToNextChar) {
				var nextCode = word[i+1].charCodeAt(0);
				var specialCode = null;
				if (nextCode == 0x0622) {
					// alef madd
					specialCode = glyphForms[0x064b][form];
				}
				else if (nextCode == 0x0623) {
					// hamza above
					specialCode = glyphForms[0x064c][form];
				}
				else if (nextCode == 0x0625) {
					// hamza below
					specialCode = glyphForms[0x064d][form];
				}
				else if (nextCode == 0x0627) {
					// alef
					specialCode = glyphForms[0x064e][form];
				}

				if (specialCode != null) {
					shapedWord += String.fromCharCode(specialCode);
					i++; // skip a step
					continue;
				}
			}

			// hacky?
			if (form === CharacterForm.Isolated) {
				shapedWord += word[i];
				continue;
			}

			var shapedCode = glyphForms[code][form];
			shapedWord += String.fromCharCode(shapedCode);
		}

		return shapedWord;
	}

	this.ContainsArabicCharacters = ContainsArabicCharacters;
	this.ShapeArabicCharacters = ShapeArabicCharacters;
}

/* TEXT EFFECTS */
var TextEffects = {};

function RainbowEffect() {
	function positiveModulo(number, divisor) {
		return ((number % divisor) + divisor) % divisor;
	}

	this.doEffect = function(char, time, parameters) {
		char.color = rainbowColorStartIndex + Math.floor(positiveModulo((time / 100) - char.col * 0.5, rainbowColorCount));
	};
}

TextEffects["rbw"] = new RainbowEffect();

function ColorEffect(index) {
	this.doEffect = function(char, time, parameters) {
		if (parameters && parameters.length > 0) {
			char.color = tileColorStartIndex + parameters[0];
		}
		else {
			char.color = tileColorStartIndex + index;
		}
	};
}

TextEffects["clr"] = new ColorEffect();
TextEffects["clr1"] = new ColorEffect(0);
TextEffects["clr2"] = new ColorEffect(1);
TextEffects["clr3"] = new ColorEffect(2);

function WavyEffect() {
	this.doEffect = function(char, time, parameters) {
		char.offset.y += Math.sin((time / 250) - (char.col / 2)) * 2;
	};
}

TextEffects["wvy"] = new WavyEffect();

function ShakyEffect() {
	function disturb(func, time, offset, mult1, mult2) {
		return func((time * mult1) - (offset * mult2));
	}

	this.doEffect = function(char, time, parameters) {
		char.offset.y += 1.5
						* disturb(Math.sin, time, char.col, 0.1, 0.5)
						* disturb(Math.cos, time, char.col, 0.3, 0.2)
						* disturb(Math.sin, time, char.row, 2.0, 1.0);
		char.offset.x += 1.5
						* disturb(Math.cos, time, char.row, 0.1, 1.0)
						* disturb(Math.sin, time, char.col, 3.0, 0.7)
						* disturb(Math.cos, time, char.col, 0.2, 0.3);
	};
}

TextEffects["shk"] = new ShakyEffect();

/*
// TODO : maybe use this in a future update?
function YakEffect() {
	this.doEffect = function(char, time, parameters) {
		if (char.char != " ") {
			char.blip = parameters[0];
		}
	};
}

TextEffects["yak"] = new YakEffect();
*/

var DebugHighlightEffect = function() {
	this.doEffect = function(char, time, parameters) {
		char.color = tileColorStartIndex;
	};
}

TextEffects["_debug_highlight"] = new DebugHighlightEffect();

} // Dialog()
</script>

<script>
function TileRenderer(debugName) {
bitsy.log("!!!!! NEW TILE RENDERER: " + debugName);

var drawingCache = {
	source: {},
	render: {},
};

// var debugRenderCount = 0;

function createRenderCacheId(drawingId, colorIndex) {
	return drawingId + "_" + colorIndex;
}

function renderDrawing(drawing) {
	// debugRenderCount++;
	// bitsy.log("RENDER COUNT " + debugRenderCount);

	var col = drawing.col;
	var bgc = drawing.bgc;
	var drwId = drawing.drw;
	var drawingFrames = drawingCache.source[drwId];

	// initialize render cache entry
	var cacheId = createRenderCacheId(drwId, col);
	if (drawingCache.render[cacheId] === undefined) {
		// initialize array of frames for drawing
		drawingCache.render[cacheId] = [];
	}

	for (var i = 0; i < drawingFrames.length; i++) {
		var frameData = drawingFrames[i];
		var frameTileId = renderTileFromDrawingData(frameData, col, bgc);
		drawingCache.render[cacheId].push(frameTileId);
	}
}

function renderTileFromDrawingData(drawingData, col, bgc) {
	var tileId = bitsy.tile();

	var backgroundColor = tileColorStartIndex + bgc;
	var foregroundColor = tileColorStartIndex + col;

	bitsy.fill(tileId, backgroundColor);

	for (var y = 0; y < bitsy.TILE_SIZE; y++) {
		for (var x = 0; x < bitsy.TILE_SIZE; x++) {
			var px = drawingData[y][x];
			if (px === 1) {
				bitsy.set(tileId, (y * bitsy.TILE_SIZE) + x, foregroundColor);
			}
		}
	}

	return tileId;
}

// TODO : move into core
function undefinedOrNull(x) {
	return x === undefined || x === null;
}

function isDrawingRendered(drawing) {
	var cacheId = createRenderCacheId(drawing.drw, drawing.col);
	return drawingCache.render[cacheId] != undefined;
}

function getRenderedDrawingFrames(drawing) {
	var cacheId = createRenderCacheId(drawing.drw, drawing.col);
	return drawingCache.render[cacheId];
}

function getDrawingFrameTileId(drawing, frameOverride) {
	var frameIndex = 0;

	if (drawing != null && drawing.animation.isAnimated) {
		if (frameOverride != undefined && frameOverride != null) {
			frameIndex = frameOverride;
		}
		else {
			frameIndex = drawing.animation.frameIndex;
		}
	}

	return getRenderedDrawingFrames(drawing)[frameIndex];
}

function getOrRenderDrawingFrame(drawing, frameOverride) {
	// bitsy.log("frame render: " + drawing.type + " " + drawing.id + " f:" + frameOverride);

	if (!isDrawingRendered(drawing)) {
		bitsy.log("frame render: doesn't exist " + drawing.id);
		renderDrawing(drawing);
	}

	return getDrawingFrameTileId(drawing, frameOverride);
}

function deleteRenders(drawingId) {
	for (var cacheId in drawingCache.render) {
		if (cacheId.indexOf(drawingId) === 0) {
			var tiles = drawingCache.render[cacheId];
			for (var i = 0; i < tiles.length; i++) {
				bitsy.delete(tiles[i]);
			}
			delete drawingCache.render[cacheId];
		}
	}
}

/* PUBLIC INTERFACE */
this.GetDrawingFrame = getOrRenderDrawingFrame;

// todo : leave individual get and set stuff for now - should I remove later?
// todo : better name for function?
this.SetDrawings = function(drawingSource) {
	drawingCache.source = drawingSource;
	// need to reset entire render cache when all the drawings are changed
	drawingCache.render = {};
};

this.SetDrawingSource = function(drawingId, drawingData) {
	deleteRenders(drawingId);
	drawingCache.source[drawingId] = drawingData;
};

this.GetDrawingSource = function(drawingId) {
	return drawingCache.source[drawingId];
};

this.GetFrameCount = function(drawingId) {
	return drawingCache.source[drawingId].length;
};

// todo : forceReset option is hacky?
this.ClearCache = function(forceReset) {
	if (forceReset === undefined || forceReset === true) {
		// delete all tiles from system memory before clearing the cache
		for (var cacheId in drawingCache.render) {
			var tiles = drawingCache.render[cacheId];
			for (var i = 0; i < tiles.length; i++) {
				bitsy.delete(tiles[i]);
			}
		}
	}

	drawingCache.render = {};
};

this.deleteDrawing = deleteRenders;

} // Renderer()
</script>

<script>
/* WORLD DATA */
var room = {};
var tile = {};
var sprite = {};
var item = {};
var dialog = {};
var end = {}; // for backwards compatibility
var palette = { // start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
var variable = {}; // these are starting variable values -- they don't update (or I don't think they will)
var tune = {};
var blip = {};
var playerId = "A";
var fontName = defaultFontName;
var textDirection = TextDirection.LeftToRight;

/* NAME-TO-ID MAPS */
var names = {
	room : {},
	tile : {},
	sprite : {},
	item : {},
	dialog : {},
	palette : {},
	tune : {},
	blip : {},
};

// todo : this is basically a copy of the one in world.js - can I remove it?
function updateNamesFromCurData() {

	function createNameMap(objectStore) {
		var map = {};

		for (id in objectStore) {
			if (objectStore[id].name != undefined && objectStore[id].name != null) {
				map[objectStore[id].name] = id;
			}
		}

		return map;
	}

	names.room = createNameMap(room);
	names.tile = createNameMap(tile);
	names.sprite = createNameMap(sprite);
	names.item = createNameMap(item);
	names.dialog = createNameMap(dialog);
	names.palette = createNameMap(palette);
	names.tune = createNameMap(tune);
	names.blip = createNameMap(blip);
}

/* GAME STATE */
var state = {}
function resetGameState() {
	state.room = "0";
	state.ava = playerId; // avatar appearance override
	state.pal = "0"; // current palette id
	state.tune = "0"; // current tune id ("0" === off)
	state.exits = []; // exits in current room
	state.endings = []; // endings in current room
}

// title helper functions
function getTitle() {
	return dialog[titleDialogId].src;
}
function setTitle(titleSrc) {
	dialog[titleDialogId] = { src:titleSrc, name:null };
}

/* FLAGS */
var flags = createDefaultFlags();

// feature flags for testing purposes
var engineFeatureFlags = {
	isSoundEnabled : true,
	isFontEnabled : true,
	isTransitionEnabled : true,
	isScriptEnabled : true,
	isDialogEnabled : true,
	isRendererEnabled : true,
};

function clearGameData() {
	room = {};
	tile = {};
	sprite = {};
	item = {};
	dialog = {};
	palette = { //start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
	isEnding = false; //todo - correct place for this?
	variable = {};

	updateNamesFromCurData();

	fontName = defaultFontName; // TODO : reset font manager too?
	textDirection = TextDirection.LeftToRight;

	resetGameState();

	isGameLoaded = false;
	isGameOver = false;
}

// engine event hooks for the editor
var onInventoryChanged = null;
var onVariableChanged = null;
var onGameReset = null;
var onInitRoom = null;

var isPlayerEmbeddedInEditor = false;

var renderer;
if (engineFeatureFlags.isRendererEnabled) {
	renderer = new TileRenderer("bitsy");
}

var curGameData = null;
var curDefaultFontData = null;

var isGameLoaded = false;
var isGameOver = false;

function load_game(gameData, defaultFontData, startWithTitle) {
	// bitsy.log("game data in: \n" + gameData);

	curGameData = gameData; //remember the current game (used to reset the game)

	if (dialogBuffer) {
		dialogBuffer.Reset();
	}

	if (scriptInterpreter) {
		scriptInterpreter.ResetEnvironment(); // ensures variables are reset -- is this the best way?
	}

	loadWorldFromGameData(gameData);

	bitsy.log("world loaded");

	if (fontManager && !isPlayerEmbeddedInEditor && defaultFontData) {
		bitsy.log("load font");

		curDefaultFontData = defaultFontData; // store for resetting game

		// todo : consider replacing this with a more general system for requesting resources from the system?
		// hack to ensure default font is available
		fontManager.AddResource(defaultFontName + fontManager.GetExtension(), defaultFontData);

		bitsy.log("load font end");
	}

	// request text mode
	if (flags.TXT_MODE === 1) {
		bitsy.textMode(bitsy.TXT_LOREZ);
	}
	else {
		// default to 2x scale for text rendering
		bitsy.textMode(bitsy.TXT_HIREZ);
	}

	if (fontManager && dialogBuffer) {
		bitsy.log("get font");

		var font = fontManager.Get( fontName );
		dialogBuffer.SetFont(font);
		dialogRenderer.SetFont(font);

		bitsy.log("get font end");
	}

	if (dialogBuffer) {
		// this feels a little silly to me - oh well??
		dialogBuffer.SetPixelsPerRow(dialogRenderer.GetPixelsPerRow());
	}

	setInitialVariables();

	bitsy.log("ready");

	onready(startWithTitle);

	isGameLoaded = true;
}

function loadWorldFromGameData(gameData) {
	bitsy.log("load world from game data");

	var world = parseWorld(gameData);

	bitsy.log("parse world done");

	// move world data into global scope
	palette = world.palette;
	room = world.room;
	tile = world.tile;
	sprite = world.sprite;
	item = world.item;
	dialog = world.dialog;
	end = world.end; // back compat endings
	variable = world.variable;
	fontName = world.fontName;
	textDirection = world.textDirection;
	tune = world.tune;
	blip = world.blip;
	flags = world.flags;
	names = world.names;

	if (renderer) {
		renderer.SetDrawings(world.drawings);
	}

	// find starting room and initialize it
	var roomIds = Object.keys(room);

	if (player() != undefined && player().room != null && roomIds.indexOf(player().room) != -1) {
		// player has valid room
		state.room = player().room;
	}
	else if (roomIds.length > 0) {
		// player not in any room! what the heck
		state.room = roomIds[0];
	}
	else {
		// uh oh there are no rooms I guess???
		state.room = null;
	}

	if (state.room != null) {
		bitsy.log("INIT ROOM " + state.room);
		initRoom(state.room);
	}
}

function reset_cur_game() {
	if (curGameData == null) {
		return; //can't reset if we don't have the game data
	}

	stopGame();
	clearGameData();

	if (isPlayerEmbeddedInEditor && onGameReset != null) {
		onGameReset();
	}
}

function onready(startWithTitle) {
	bitsy.log("game ready!");

	if (startWithTitle === undefined || startWithTitle === null) {
		startWithTitle = true;
	}

	if (startWithTitle) { // used by editor 
		startNarrating(getTitle());
	}
}

function setInitialVariables() {
	if (!scriptInterpreter) {
		return;
	}

	for(id in variable) {
		var value = variable[id]; // default to string
		if(value === "true") {
			value = true;
		}
		else if(value === "false") {
			value = false;
		}
		else if(!isNaN(parseFloat(value))) {
			value = parseFloat(value);
		}
		scriptInterpreter.SetVariable(id,value);
	}
	scriptInterpreter.SetOnVariableChangeHandler( onVariableChanged );
}

function getOffset(evt) {
	var offset = { x:0, y:0 };

	var el = evt.target;
	var rect = el.getBoundingClientRect();

	offset.x += rect.left + el.scrollLeft;
	offset.y += rect.top + el.scrollTop;

	offset.x = evt.clientX - offset.x;
	offset.y = evt.clientY - offset.y;

	return offset;
}

function stopGame() {
	if (soundPlayer) {
		soundPlayer.stopTune();
	}
	bitsy.log("stop GAME!");
}

function update(dt) {
	if (!isGameLoaded) {
		load_game(bitsy.getGameData(), bitsy.getFontData());
	}

	if (state.room == null) {
		// in the special case where there is no valid room, end the game
		startNarrating( "", true /*isEnding*/ );
	}

	if (!transition || !transition.IsTransitionActive()) {
		updateInput();
	}

	if (transition && transition.IsTransitionActive()) {
		// transition animation takes over everything!
		transition.UpdateTransition(dt);
	}
	else {
		if (bitsy.graphicsMode() != bitsy.GFX_MAP) {
			bitsy.graphicsMode(bitsy.GFX_MAP);
		}

		if (soundPlayer) {
			soundPlayer.update(dt);
		}

		if (!isNarrating && !isEnding) {
			// draw world if game has begun
			var didAnimate = updateAnimation(dt);

			// test whether player moved so we can redraw just the avatar
			playerCurX = player().x;
			playerCurY = player().y;
			var didPlayerMove = (playerPrevX != playerCurX) || (playerPrevY != playerCurY);

			drawRoom(room[state.room], { redrawAnimated: didAnimate, redrawAvatar: didPlayerMove });

			// store player's position for next frame
			playerPrevX = playerCurX;
			playerPrevY = playerCurY;
		}
		else {
			clearRoom();
		}

		if (dialogBuffer && dialogBuffer.IsActive() && !(soundPlayer && soundPlayer.isBlipPlaying())) {
			// bitsy.log("update dialog");
			// bitsy.log("renderer");
			dialogRenderer.Draw(dialogBuffer, dt);
			// bitsy.log("buffer");
			dialogBuffer.Update(dt);
			// bitsy.log("update dialog end");
		}

		// keep moving avatar if player holds down button
		if ((!dialogBuffer || !dialogBuffer.IsActive()) && !isEnding) {
			if (curPlayerDirection != Direction.None) {
				playerHoldToMoveTimer -= dt;

				if (playerHoldToMoveTimer <= 0) {
					movePlayer(curPlayerDirection, false /* isFirstMove */);
					playerHoldToMoveTimer = 150;
					// playerHoldToMoveTimer = 16; // PERF TEST
				}
			}
		}
	}

	// clean up state if the game is ending
	if (isGameOver) {
		bitsy.log("game over");
		reset_cur_game();
	}

	return true;
}

var isAnyButtonHeld = false;
var isMenuButtonHeld = false;
var isIgnoringInput = false;

function isAnyButtonDown() {
	return bitsy.button(bitsy.BTN_UP) ||
		bitsy.button(bitsy.BTN_DOWN) ||
		bitsy.button(bitsy.BTN_LEFT) ||
		bitsy.button(bitsy.BTN_RIGHT) ||
		bitsy.button(bitsy.BTN_OK);
}

function updateInput() {
	if (dialogBuffer && dialogBuffer.IsActive()) {
		if (!(soundPlayer && soundPlayer.isBlipPlaying())) {
			if (!isAnyButtonHeld && isAnyButtonDown()) {
				/* CONTINUE DIALOG */
				if (dialogBuffer.CanContinue()) {
					var hasMoreDialog = dialogBuffer.Continue();
					if (!hasMoreDialog) {
						// ignore currently held keys UNTIL they are released (stops player from insta-moving)
						isIgnoringInput = true;
						curPlayerDirection = Direction.None;
					}
				}
				else {
					dialogBuffer.Skip();
				}
			}
		}
	}
	else if (isEnding) {
		if (!isAnyButtonHeld && isAnyButtonDown()) {
			// tell game to restart
			isGameOver = true;
		}
	}
	else if (!isIgnoringInput) {
		/* WALK */
		var prevPlayerDirection = curPlayerDirection;

		if (bitsy.button(bitsy.BTN_UP)) {
			curPlayerDirection = Direction.Up;
		}
		else if (bitsy.button(bitsy.BTN_DOWN)) {
			curPlayerDirection = Direction.Down;
		}
		else if (bitsy.button(bitsy.BTN_LEFT)) {
			curPlayerDirection = Direction.Left;
		}
		else if (bitsy.button(bitsy.BTN_RIGHT)) {
			curPlayerDirection = Direction.Right;
		}
		else {
			curPlayerDirection = Direction.None;
		}

		if (curPlayerDirection != Direction.None && curPlayerDirection != prevPlayerDirection) {
			movePlayer(curPlayerDirection, true /* isFirstMove */);
			playerHoldToMoveTimer = 500;
			// playerHoldToMoveTimer = 32; // PERF TEST
		}
	}

	if (!isAnyButtonDown()) {
		isIgnoringInput = false;
	}

	// quit when the user releases the restart button
	// todo : should I rename it bitsy.BTN_RESTART or bitsy.BTN_QUIT or bitsy.BTN_OFF?
	if (isMenuButtonHeld && !bitsy.button(bitsy.BTN_MENU)) {
		isGameOver = true;
	}

	isAnyButtonHeld = isAnyButtonDown();
	isMenuButtonHeld = bitsy.button(bitsy.BTN_MENU);
}

var animationCounter = 0;
var animationTime = 400;
function updateAnimation(dt) {
	animationCounter += dt;
	// bitsy.log("anim " + animationCounter);
	if (animationCounter >= animationTime) {
		// animate sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.animation.isAnimated) {
				spr.animation.frameIndex = (spr.animation.frameIndex + 1) % spr.animation.frameCount;
			}
		}

		// animate tiles
		for (id in tile) {
			var til = tile[id];
			if (til.animation.isAnimated) {
				til.animation.frameIndex = (til.animation.frameIndex + 1) % til.animation.frameCount;
			}
		}

		// animate items
		for (id in item) {
			var itm = item[id];
			if (itm.animation.isAnimated) {
				itm.animation.frameIndex = (itm.animation.frameIndex + 1) % itm.animation.frameCount;
			}
		}

		// reset counter
		animationCounter = 0;

		// updated animations this frame
		return true;
	}

	// did *not* update animations this frame
	return false;
}

function resetAllAnimations() {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.animation.isAnimated) {
			spr.animation.frameIndex = 0;
		}
	}

	for (id in tile) {
		var til = tile[id];
		if (til.animation.isAnimated) {
			til.animation.frameIndex = 0;
		}
	}

	for (id in item) {
		var itm = item[id];
		if (itm.animation.isAnimated) {
			itm.animation.frameIndex = 0;
		}
	}
}

function getSpriteAt(x, y, roomId) {
	if (roomId === undefined) {
		roomId = state.room;
	}

	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === roomId) {
			if (spr.x == x && spr.y == y) {
				return id;
			}
		}
	}

	return null;
}

var Direction = {
	None : -1,
	Up : 0,
	Down : 1,
	Left : 2,
	Right : 3
};

var curPlayerDirection = Direction.None;
var playerHoldToMoveTimer = 0;
var playerPrevX = 0;
var playerPrevY = 0;

function movePlayer(direction, isFirstMove) {
	didPlayerMove = false;
	var roomIds = Object.keys(room);

	if (player().room == null || roomIds.indexOf(player().room) < 0) {
		return; // player room is missing or invalid.. can't move them!
	}

	var spr = null;

	if (direction == Direction.Left && !(spr = getSpriteLeft()) && !isWallLeft()) {
		player().x -= 1;
	}
	else if (direction == Direction.Right && !(spr = getSpriteRight()) && !isWallRight()) {
		player().x += 1;
	}
	else if (direction == Direction.Up && !(spr = getSpriteUp()) && !isWallUp()) {
		player().y -= 1;
	}
	else if (direction == Direction.Down && !(spr = getSpriteDown()) && !isWallDown()) {
		player().y += 1;
	}

	var ext = getExit( player().room, player().x, player().y );
	var end = getEnding( player().room, player().x, player().y );
	var itmIndex = getItemIndex( player().room, player().x, player().y );

	// only play one sound effect per "turn"
	var blipId = null;

	// do items first, because you can pick up an item AND go through a door
	if (itmIndex > -1) {
		var itm = room[player().room].items[itmIndex];
		var itemRoom = player().room;

		// play sound on pitck up item
		if (item[itm.id].blip != null) {
			blipId = item[itm.id].blip;
		}

		startItemDialog(itm.id, function() {
			// remove item from room
			room[itemRoom].items.splice(itmIndex, 1);

			// update player inventory
			if (player().inventory[itm.id]) {
				player().inventory[itm.id] += 1;
			}
			else {
				player().inventory[itm.id] = 1;
			}

			// show inventory change in UI
			if (onInventoryChanged != null) {
				onInventoryChanged(itm.id);
			}
		});
	}

	if (end) {
		startEndingDialog(end);
	}
	else if (ext) {
		movePlayerThroughExit(ext);
	}
	else if (spr) {
		// play sound on greet sprite
		if (sprite[spr].blip != null) {
			blipId = sprite[spr].blip;
		}

		startSpriteDialog(spr /*spriteId*/);
	}

	// TODO : maybe add in a future update?
	/*
	// play sound when player moves (if no other sound selected)
	if (isFirstMove && blipId === null && sprite[state.ava].blip != null) {
		blipId = sprite[state.ava].blip;
		randomizeBlip = true;
		blipChannel = bitsy.SOUND2; // play walking sfx *under* the tune melody
	}
	*/

	if (soundPlayer && blipId != null && blip[blipId]) {
		soundPlayer.playBlip(blip[blipId]);
	}
}

var transition;
if (engineFeatureFlags.isTransitionEnabled) {
	transition = new TransitionManager();
}

function movePlayerThroughExit(ext) {
	var GoToDest = function() {
		if (transition && ext.transition_effect != null) {
			transition.BeginTransition(
				player().room,
				player().x,
				player().y,
				ext.dest.room,
				ext.dest.x,
				ext.dest.y,
				ext.transition_effect);

			transition.UpdateTransition(0);

			transition.OnTransitionComplete(function() {
				player().room = ext.dest.room;
				player().x = ext.dest.x;
				player().y = ext.dest.y;
				state.room = ext.dest.room;
				initRoom(state.room);
			});
		}
		else {
			player().room = ext.dest.room;
			player().x = ext.dest.x;
			player().y = ext.dest.y;
			state.room = ext.dest.room;

			initRoom(state.room);
		}
	};

	if (ext.dlg != undefined && ext.dlg != null) {
		// TODO : I need to simplify dialog code,
		// so I don't have to get the ID and the source str
		// every time!
		startDialog(
			dialog[ext.dlg].src,
			ext.dlg,
			function(result) {
				var isLocked = ext.property && ext.property.locked === true;
				if (!isLocked) {
					GoToDest();
				}
			},
			ext);
	}
	else {
		GoToDest();
	}
}

/* PALETTE INDICES */
var backgroundIndex = 0;
var textBackgroundIndex = 1;
var textArrowIndex = 2;
var textColorIndex = 3;

// precalculated rainbow colors
var rainbowColorStartIndex = 4;
var rainbowColorCount = 10;
var rainbowColors = [
	[255,0,0],
	[255,217,0],
	[78,255,0],
	[0,255,125],
	[0,192,255],
	[0,18,255],
	[136,0,255],
	[255,0,242],
	[255,0,138],
	[255,0,61],
];

function updatePaletteWithTileColors(tileColors) {
	// the screen background color should match the first tile color
	if (tileColors.length > 0) {
		var color = tileColors[0];
		bitsy.color(backgroundIndex, color[0], color[1], color[2]);
	}
	else {
		// as a fallback, use black as the background
		bitsy.log("no tile colors!");
		bitsy.color(backgroundIndex, 0, 0, 0);
	}

	// textbox colors
	bitsy.color(textBackgroundIndex, 0, 0, 0); // black
	bitsy.color(textArrowIndex, 255, 255, 255); // white
	bitsy.color(textColorIndex, 255, 255, 255); // white

	// rainbow colors
	for (var i = 0; i < rainbowColorCount; i++) {
		var color = rainbowColors[i];
		bitsy.color(rainbowColorStartIndex + i, color[0], color[1], color[2]);
	}

	// tile colors
	for (var i = 0; i < tileColors.length; i++) {
		var color = tileColors[i];
		bitsy.color(tileColorStartIndex + i, color[0], color[1], color[2]);
	}
}

function updatePalette(palId) {
	state.pal = palId;
	var pal = palette[state.pal];
	updatePaletteWithTileColors(pal.colors);
}

function initRoom(roomId) {
	bitsy.log("init room " + roomId);

	updatePalette(getRoomPal(roomId));

	// update avatar appearance
	state.ava = (room[roomId].ava != null) ? room[roomId].ava : playerId;

	if (renderer) {
		renderer.ClearCache();
	}

	// init exit properties
	state.exits = [];
	for (var i = 0; i < room[roomId].exits.length; i++) {
		var exit = createExitData(
			/* x 			*/ room[roomId].exits[i].x,
			/* y 			*/ room[roomId].exits[i].y,
			/* destRoom 	*/ room[roomId].exits[i].dest.room,
			/* destX 		*/ room[roomId].exits[i].dest.x,
			/* destY 		*/ room[roomId].exits[i].dest.y,
			/* transition 	*/ room[roomId].exits[i].transition_effect,
			/* dlg 			*/ room[roomId].exits[i].dlg);
		exit.property = { locked: false };

		state.exits.push(exit);
	}

	// init ending properties
	state.endings = [];
	for (var i = 0; i < room[roomId].endings.length; i++) {
		var end = createEndingData(
			/* id */ room[roomId].endings[i].id,
			/* x  */ room[roomId].endings[i].x,
			/* y  */ room[roomId].endings[i].y);
		end.property = { locked: false };

		state.endings.push(end);
	}

	if (soundPlayer) {
		if (!room[roomId].tune || room[roomId].tune === "0" || !tune[room[roomId].tune]) {
			// stop music
			state.tune = "0";
			soundPlayer.stopTune();
		}
		else if (room[roomId].tune != state.tune) {
			// start music
			state.tune = room[roomId].tune;
			soundPlayer.playTune(tune[state.tune]);
		}
	}

	var drawArgs = { redrawAll: true };
	drawRoom(room[roomId], drawArgs);

	if (onInitRoom) {
		onInitRoom(roomId);
	}
}

function getItemIndex( roomId, x, y ) {
	for( var i = 0; i < room[roomId].items.length; i++ ) {
		var itm = room[roomId].items[i];
		if ( itm.x == x && itm.y == y)
			return i;
	}
	return -1;
}

function getSpriteLeft() { //repetitive?
	return getSpriteAt( player().x - 1, player().y );
}

function getSpriteRight() {
	return getSpriteAt( player().x + 1, player().y );
}

function getSpriteUp() {
	return getSpriteAt( player().x, player().y - 1 );
}

function getSpriteDown() {
	return getSpriteAt( player().x, player().y + 1 );
}

function isWallLeft() {
	return (player().x - 1 < 0) || isWall( player().x - 1, player().y );
}

function isWallRight() {
	return (player().x + 1 >= bitsy.MAP_SIZE) || isWall(player().x + 1, player().y);
}

function isWallUp() {
	return (player().y - 1 < 0) || isWall( player().x, player().y - 1 );
}

function isWallDown() {
	return (player().y + 1 >= bitsy.MAP_SIZE) || isWall(player().x, player().y + 1);
}

function isWall(x, y, roomId) {
	if (roomId == undefined || roomId == null) {
		roomId = state.room;
	}

	var tileId = getTile(x, y, roomId);
	if (tileId === '0') {
		return false; // Blank spaces aren't walls, ya doofus
	}

	if (tile[tileId].isWall === undefined || tile[tileId].isWall === null) {
		// No wall-state defined: check room-specific walls
		var i = room[roomId].walls.indexOf(getTile(x, y, roomId));
		return (i > -1);
	}

	// Otherwise, use the tile's own wall-state
	return tile[tileId].isWall;
}

function getItem(roomId,x,y) {
	for (i in room[roomId].items) {
		var item = room[roomId].items[i];
		if (x == item.x && y == item.y) {
			return item;
		}
	}
	return null;
}

// todo : roomId isn't useful in these functions anymore! safe to remove?
function getExit(roomId, x, y) {
	for (i in state.exits) {
		var e = state.exits[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getEnding(roomId, x, y) {
	for (i in state.endings) {
		var e = state.endings[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getTile(x, y, roomId) {
	// bitsy.log(x + " " + y);
	var t = getRoom(roomId).tilemap[y][x];
	return t;
}

function player() {
	return sprite[playerId];
}

// Sort of a hack for legacy palette code (when it was just an array)
function getPal(id) {
	if (palette[id] === undefined) {
		id = "default";
	}

	return palette[ id ].colors;
}

function getRoom(id) {
	return room[id === undefined ? state.room : id];
}

function isSpriteOffstage(id) {
	return sprite[id].room == null;
}

function serializeNote(note, key, useFriendlyName) {
	var isSolfa = (key != undefined && key != null);
	var noteType = (isSolfa === true) ? Solfa : Note;

	if (isSolfa && key.scale.indexOf(note) === -1) {
		// no matching note in key
		return null;
	}

	if (isSolfa && useFriendlyName != true) {
		for (var name in Solfa) {
			if (Solfa[name] === note) {
				return name.toLowerCase();
			}
		}

		// no solfa note found
		return null;
	}

	// for a solfa note's "friendly name" convert to the chromatic equivalent
	if (isSolfa && useFriendlyName === true) {
		note = key.notes[note];
	}

	// from this point on, we know the note we're looking for is chromatic
	for (var name in Note) {
		if (Note[name] === note) {
			name = name.replace("_SHARP", "#");
			if (useFriendlyName === true && name === "H") {
				name = "C";
			}
			return name;
		}
	}

	// no note found
	return symbol;
}

function serializeOctave(octave) {
	for (var symbol in Octave) {
		if (Octave[symbol] === octave) {
			return symbol;
		}
	}

	// default to middle octave
	return "4";
}

//TODO this is in progress and doesn't support all features
function serializeWorld(skipFonts) {
	if (skipFonts === undefined || skipFonts === null) {
		skipFonts = false;
	}

	// update version flags
	flags.VER_MAJ = version.major;
	flags.VER_MIN = version.minor;

	var worldStr = "";
	/* TITLE */
	worldStr += getTitle() + "\n";
	worldStr += "\n";
	/* VERSION */
	worldStr += "# BITSY VERSION " + getEngineVersion() + "\n"; // add version as a comment for debugging purposes
	if (version.devBuildPhase != "RELEASE") {
		worldStr += "# DEVELOPMENT BUILD -- " + version.devBuildPhase;
	}
	worldStr += "\n";
	/* FLAGS */
	for (f in flags) {
		worldStr += "! " + f + " " + flags[f] + "\n";
	}
	worldStr += "\n"
	/* FONT */
	if (fontName != defaultFontName) {
		worldStr += "DEFAULT_FONT " + fontName + "\n";
		worldStr += "\n"
	}
	if (textDirection != TextDirection.LeftToRight) {
		worldStr += "TEXT_DIRECTION " + textDirection + "\n";
		worldStr += "\n"
	}
	/* PALETTE */
	for (id in palette) {
		if (id != "default") {
			worldStr += "PAL " + id + "\n";
			for (i in getPal(id)) {
				for (j in getPal(id)[i]) {
					worldStr += getPal(id)[i][j];
					if (j < 2) worldStr += ",";
				}
				worldStr += "\n";
			}
			if (palette[id].name != null) {
				worldStr += "NAME " + palette[id].name + "\n";
			}
			worldStr += "\n";
		}
	}
	/* ROOM */
	for (id in room) {
		worldStr += "ROOM " + id + "\n";
		if ( flags.ROOM_FORMAT == 0 ) {
			// old non-comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];	
				}
				worldStr += "\n";
			}
		}
		else if ( flags.ROOM_FORMAT == 1 ) {
			// new comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];
					if (j < room[id].tilemap[i].length-1) worldStr += ","
				}
				worldStr += "\n";
			}
		}
		if (room[id].name != null) {
			/* NAME */
			worldStr += "NAME " + room[id].name + "\n";
		}
		if (room[id].walls.length > 0) {
			/* WALLS */
			worldStr += "WAL ";
			for (j in room[id].walls) {
				worldStr += room[id].walls[j];
				if (j < room[id].walls.length-1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		if (room[id].items.length > 0) {
			/* ITEMS */
			for (j in room[id].items) {
				var itm = room[id].items[j];
				worldStr += "ITM " + itm.id + " " + itm.x + "," + itm.y;
				worldStr += "\n";
			}
		}
		if (room[id].exits.length > 0) {
			/* EXITS */
			for (j in room[id].exits) {
				var e = room[id].exits[j];
				if ( isExitValid(e) ) {
					worldStr += "EXT " + e.x + "," + e.y + " " + e.dest.room + " " + e.dest.x + "," + e.dest.y;
					if (e.transition_effect != undefined && e.transition_effect != null) {
						worldStr += " FX " + e.transition_effect;
					}
					if (e.dlg != undefined && e.dlg != null) {
						worldStr += " DLG " + e.dlg;
					}
					worldStr += "\n";
				}
			}
		}
		if (room[id].endings.length > 0) {
			/* ENDINGS */
			for (j in room[id].endings) {
				var e = room[id].endings[j];
				// todo isEndingValid
				worldStr += "END " + e.id + " " + e.x + "," + e.y;
				worldStr += "\n";
			}
		}
		if (room[id].pal != null && room[id].pal != "default") {
			/* PALETTE */
			worldStr += "PAL " + room[id].pal + "\n";
		}
		if (room[id].ava != null) {
			/* AVATAR SPRITE */
			worldStr += "AVA " + room[id].ava + "\n";
		}
		if (room[id].tune != null && room[id].tune != "0") {
			/* TUNE */
			worldStr += "TUNE " + room[id].tune + "\n";
		}
		worldStr += "\n";
	}
	/* TILES */
	for (id in tile) {
		worldStr += "TIL " + id + "\n";
		worldStr += serializeDrawing( "TIL_" + id );
		if (tile[id].name != null && tile[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + tile[id].name + "\n";
		}
		if (tile[id].isWall != null && tile[id].isWall != undefined) {
			/* WALL */
			worldStr += "WAL " + tile[id].isWall + "\n";
		}
		if (tile[id].col != null && tile[id].col != undefined && tile[id].col != 1) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + tile[id].col + "\n";
		}
		if (tile[id].bgc != null && tile[id].bgc != undefined && tile[id].bgc != 0) {
			/* BACKGROUND COLOR OVERRIDE */
			if (tile[id].bgc < 0) {
				// transparent background
				worldStr += "BGC *\n";
			}
			else {
				worldStr += "BGC " + tile[id].bgc + "\n";
			}
		}
		worldStr += "\n";
	}
	/* SPRITES */
	for (id in sprite) {
		worldStr += "SPR " + id + "\n";
		worldStr += serializeDrawing( "SPR_" + id );
		if (sprite[id].name != null && sprite[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + sprite[id].name + "\n";
		}
		if (sprite[id].dlg != null) {
			worldStr += "DLG " + sprite[id].dlg + "\n";
		}
		if (sprite[id].room != null) {
			/* SPRITE POSITION */
			worldStr += "POS " + sprite[id].room + " " + sprite[id].x + "," + sprite[id].y + "\n";
		}
		if (sprite[id].inventory != null) {
			for(itemId in sprite[id].inventory) {
				worldStr += "ITM " + itemId + " " + sprite[id].inventory[itemId] + "\n";
			}
		}
		if (sprite[id].col != null && sprite[id].col != undefined && sprite[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + sprite[id].col + "\n";
		}
		if (sprite[id].bgc != null && sprite[id].bgc != undefined && sprite[id].bgc != 0) {
			/* BACKGROUND COLOR OVERRIDE */
			if (sprite[id].bgc < 0) {
				// transparent background
				worldStr += "BGC *\n";
			}
			else {
				worldStr += "BGC " + sprite[id].bgc + "\n";
			}
		}
		if (sprite[id].blip != null && sprite[id].blip != undefined) {
			/* BLIP */
			worldStr += "BLIP " + sprite[id].blip + "\n";
		}
		worldStr += "\n";
	}
	/* ITEMS */
	for (id in item) {
		worldStr += "ITM " + id + "\n";
		worldStr += serializeDrawing( "ITM_" + id );
		if (item[id].name != null && item[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + item[id].name + "\n";
		}
		if (item[id].dlg != null) {
			worldStr += "DLG " + item[id].dlg + "\n";
		}
		if (item[id].col != null && item[id].col != undefined && item[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + item[id].col + "\n";
		}
		if (item[id].bgc != null && item[id].bgc != undefined && item[id].bgc != 0) {
			/* BACKGROUND COLOR OVERRIDE */
			if (item[id].bgc < 0) {
				// transparent background
				worldStr += "BGC *\n";
			}
			else {
				worldStr += "BGC " + item[id].bgc + "\n";
			}
		}
		if (item[id].blip != null && item[id].blip != undefined) {
			/* BLIP */
			worldStr += "BLIP " + item[id].blip + "\n";
		}
		worldStr += "\n";
	}
	/* DIALOG */
	for (id in dialog) {
		if (id != titleDialogId) {
			worldStr += "DLG " + id + "\n";
			worldStr += dialog[id].src + "\n";
			if (dialog[id].name != null) {
				worldStr += "NAME " + dialog[id].name + "\n";
			}
			worldStr += "\n";
		}
	}
	/* ENDINGS (for backwards compability only) */
	for (id in end) {
		worldStr += "END " + id + "\n";
		worldStr += end[id].src + "\n";
		worldStr += "\n";
	}
	/* VARIABLES */
	for (id in variable) {
		worldStr += "VAR " + id + "\n";
		worldStr += variable[id] + "\n";
		worldStr += "\n";
	}
	/* TUNES */
	for (id in tune) {
		if (id === "0") {
			continue;
		}

		worldStr += "TUNE " + id + "\n";
		for (var i = 0; i < maxTuneLength && i < tune[id].melody.length; i++) {
			// MELODY
			for (var j = 0; j < barLength; j++) {
				var noteStr = serializeNote(tune[id].melody[i][j].note, tune[id].key);
				if (noteStr === null) {
					tune[id].melody[i][j].beats = 0;
				}
				if (tune[id].melody[i][j].beats != 1) {
					worldStr += tune[id].melody[i][j].beats;
				}
				if (tune[id].melody[i][j].beats > 0) {
					worldStr += noteStr;
				}
				if (tune[id].melody[i][j].beats > 0 && tune[id].melody[i][j].octave != Octave[4]) {
					worldStr += serializeOctave(tune[id].melody[i][j].octave);
				}
				if (tune[id].melody[i][j].beats > 0 && tune[id].melody[i][j].blip != undefined) {
					// todo : create constant for the blip separator?
					worldStr += "~" + tune[id].melody[i][j].blip;
				}
				if (j < 15) {
					worldStr += ",";
				}
			}
			worldStr += "\n";

			// HARMONY
			// todo : lots of copy-pasting - I could probably make some helper functions to simplify this
			for (var j = 0; j < barLength; j++) {
				var noteStr = serializeNote(tune[id].harmony[i][j].note, tune[id].key);
				if (noteStr === null) {
					tune[id].harmony[i][j].beats = 0;
				}
				if (tune[id].harmony[i][j].beats != 1) {
					worldStr += tune[id].harmony[i][j].beats;
				}
				if (tune[id].harmony[i][j].beats > 0) {
					worldStr += noteStr;
				}
				if (tune[id].harmony[i][j].beats > 0 && tune[id].harmony[i][j].octave != Octave[4]) {
					worldStr += serializeOctave(tune[id].harmony[i][j].octave);
				}
				if (tune[id].harmony[i][j].beats > 0 && tune[id].harmony[i][j].blip != undefined) {
					worldStr += "~" + tune[id].harmony[i][j].blip;
				}
				if (j < 15) {
					worldStr += ",";
				}
			}
			worldStr += "\n";

			if (i < (tune[id].melody.length - 1)) {
				worldStr += ">";
				worldStr += "\n";
			}
		}
		if (tune[id].name != null) {
			/* NAME */
			worldStr += "NAME " + tune[id].name + "\n";
		}
		if (tune[id].key != undefined && tune[id].key != null) {
			worldStr += "KEY ";
			for (var i = 0; i < Solfa.COUNT; i++) {
				worldStr += serializeNote(tune[id].key.notes[i]);
				if (i < Solfa.COUNT - 1) {
					worldStr += ",";
				}
			}
			worldStr += " ";
			for (var i = 0; i < tune[id].key.scale.length; i++) {
				worldStr += serializeNote(tune[id].key.scale[i], tune[id].key);
				if (i < tune[id].key.scale.length - 1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		worldStr += "TMP ";
		switch (tune[id].tempo) {
			case Tempo.SLW:
				worldStr += "SLW";
				break;
			case Tempo.MED:
				worldStr += "MED";
				break;
			case Tempo.FST:
				worldStr += "FST";
				break;
			case Tempo.XFST:
				worldStr += "XFST";
				break;
		}
		worldStr += "\n";
		worldStr += "SQR ";
		switch (tune[id].instrumentA) {
			case SquareWave.P8:
				worldStr += "P8";
				break;
			case SquareWave.P4:
				worldStr += "P4";
				break;
			case SquareWave.P2:
				worldStr += "P2";
				break;
		}
		worldStr += " ";
		switch (tune[id].instrumentB) {
			case SquareWave.P8:
				worldStr += "P8";
				break;
			case SquareWave.P4:
				worldStr += "P4";
				break;
			case SquareWave.P2:
				worldStr += "P2";
				break;
		}
		worldStr += "\n";
		if (tune[id].key != undefined && tune[id].key != null && tune[id].arpeggioPattern != ArpeggioPattern.OFF) {
			switch (tune[id].arpeggioPattern) {
				case ArpeggioPattern.UP:
					worldStr += "ARP UP\n";
					break;
				case ArpeggioPattern.DWN:
					worldStr += "ARP DWN\n";
					break;
				case ArpeggioPattern.INT5:
					worldStr += "ARP INT5\n";
					break;
				case ArpeggioPattern.INT8:
					worldStr += "ARP INT8\n";
					break;
			}
		}
		worldStr += "\n";
	}
	/* BLIP */
	for (id in blip) {
		if (id === "0") {
			continue;
		}

		worldStr += "BLIP " + id + "\n";
		// pitches
		if (blip[id].pitchA.beats > 0) {
			worldStr += serializeNote(blip[id].pitchA.note);
			if (blip[id].pitchA.octave != Octave[4]) {
				worldStr += serializeOctave(blip[id].pitchA.octave);
			}
		}
		else {
			worldStr += blip[id].pitchA.beats;
		}
		worldStr += ",";
		if (blip[id].pitchB.beats > 0) {
			worldStr += serializeNote(blip[id].pitchB.note);
			if (blip[id].pitchB.octave != Octave[4]) {
				worldStr += serializeOctave(blip[id].pitchB.octave);
			}
		}
		else {
			worldStr += blip[id].pitchB.beats;
		}
		worldStr += ",";
		if (blip[id].pitchC.beats > 0) {
			worldStr += serializeNote(blip[id].pitchC.note);
			if (blip[id].pitchC.octave != Octave[4]) {
				worldStr += serializeOctave(blip[id].pitchC.octave);
			}
		}
		else {
			worldStr += blip[id].pitchC.beats;
		}
		worldStr += "\n";
		if (blip[id].name != null) {
			/* NAME */
			worldStr += "NAME " + blip[id].name + "\n";
		}
		// envelope
		worldStr += "ENV " + blip[id].envelope.attack
			+ " " + blip[id].envelope.decay
			+ " " + blip[id].envelope.sustain
			+ " " + blip[id].envelope.length
			+ " " + blip[id].envelope.release + "\n";
		// beat
		worldStr += "BEAT " + blip[id].beat.time
			+ " " + blip[id].beat.delay + "\n";
		// instrument (square wave type)
		worldStr += "SQR ";
		switch (blip[id].instrument) {
			case SquareWave.P8:
				worldStr += "P8";
				break;
			case SquareWave.P4:
				worldStr += "P4";
				break;
			case SquareWave.P2:
				worldStr += "P2";
				break;
		}
		worldStr += "\n";
		// other parameters
		if (blip[id].doRepeat === true) {
			worldStr += "RPT 1\n";
		}
		// TODO : consider for future update
		// if (blip[id].doSlide === true) {
		// 	worldStr += "SLD 1\n";
		// }
		worldStr += "\n";
	}
	/* FONT */
	// TODO : support multiple fonts
	if (fontManager && fontName != defaultFontName && !skipFonts) {
		worldStr += fontManager.GetData(fontName);
	}

	return worldStr;
}

function serializeDrawing(drwId) {
	if (!renderer) {
		return "";
	}

	var drawingData = renderer.GetDrawingSource(drwId);
	var drwStr = "";
	for (f in drawingData) {
		for (y in drawingData[f]) {
			var rowStr = "";
			for (x in drawingData[f][y]) {
				rowStr += drawingData[f][y][x];
			}
			drwStr += rowStr + "\n";
		}
		if (f < (drawingData.length-1)) drwStr += ">\n";
	}
	return drwStr;
}

function isExitValid(e) {
	var hasValidStartPos = e.x >= 0 && e.x < bitsy.MAP_SIZE && e.y >= 0 && e.y < bitsy.MAP_SIZE;
	var hasDest = e.dest != null;
	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < bitsy.MAP_SIZE && e.dest.y >= 0 && e.dest.y < bitsy.MAP_SIZE);
	return hasValidStartPos && hasDest && hasValidRoomDest;
}

function setTile(mapId, x, y, tileId) {
	bitsy.set(mapId, (y * bitsy.MAP_SIZE) + x, tileId);
}

function drawTile(tileId, x, y) {
	setTile(bitsy.MAP1, x, y, tileId);
}

function drawSprite(tileId, x, y) {
	setTile(bitsy.MAP2, x, y, tileId);
}

function drawItem(tileId, x, y) {
	setTile(bitsy.MAP2, x, y, tileId);
}

// var debugLastRoomDrawn = "0";

function clearRoom() {
	var paletteId = "default";

	if (room === undefined) {
		// protect against invalid rooms
		return;
	}

	if (room.pal != null && palette[paletteId] != undefined) {
		paletteId = room.pal;
	}

	// clear background & foreground
	bitsy.fill(bitsy.MAP1, 0);
	bitsy.fill(bitsy.MAP2, 0);
}

function drawRoomBackground(room, frameIndex, redrawAnimatedOnly) {
	if (!redrawAnimatedOnly) {
		// clear background map
		bitsy.fill(bitsy.MAP1, 0);
	}

	// NOTE: interestingly the slowest part of this is iterating over all the tiles, not actually drawing them
	for (var y = 0; y < bitsy.MAP_SIZE; y++) {
		for (var x = 0; x < bitsy.MAP_SIZE; x++) {
			var id = room.tilemap[y][x];

			if (id != "0" && tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)
				id = "0";
				room.tilemap[y][x] = id;
			}

			if (id != "0" && (!redrawAnimatedOnly || tile[id].animation.isAnimated)) {
				drawTile(getTileFrame(tile[id], frameIndex), x, y);
			}
		}
	}
}

function drawRoomForeground(room, frameIndex, redrawAnimatedOnly) {
	if (!redrawAnimatedOnly) {
		// clear foreground map
		bitsy.fill(bitsy.MAP2, 0);
	}

	// draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		if (!redrawAnimatedOnly || item[itm.id].animation.isAnimated) {
			drawItem(getItemFrame(item[itm.id], frameIndex), itm.x, itm.y);
		}
	}

	// draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (id != playerId && spr.room === room.id && (!redrawAnimatedOnly || spr.animation.isAnimated)) {
			drawSprite(getSpriteFrame(spr, frameIndex), spr.x, spr.y);
		}
	}
}

function drawRoomForegroundTile(room, frameIndex, x, y) {
	// draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		if (itm.x === x && itm.y === y) {
			drawItem(getItemFrame(item[itm.id], frameIndex), itm.x, itm.y);
		}
	}

	// draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (id != playerId && spr.room === room.id && spr.x === x && spr.y === y) {
			drawSprite(getSpriteFrame(spr, frameIndex), spr.x, spr.y);
		}
	}
}

function drawRoom(room, args) {
	if (room === undefined || isNarrating) {
		// protect against invalid rooms
		return;
	}

	var redrawAll = args && (args.redrawAll === true);
	var redrawAnimated = args && (args.redrawAnimated === true);
	var redrawAvatar = args && (args.redrawAvatar === true);
	var frameIndex = args ? args.frameIndex : undefined;

	// if *only* redrawing the avatar, first clear its previous position
	if (redrawAvatar) {
		setTile(bitsy.MAP2, playerPrevX, playerPrevY, 0);
		// also redraw any sprite or item that might be "under" the player (todo: possible perf issue?)
		drawRoomForegroundTile(room, frameIndex, playerPrevX, playerPrevY);
	}

	// draw background & foreground tiles
	if (redrawAll || redrawAnimated) {
		// draw tiles
		drawRoomBackground(room, frameIndex, redrawAnimated);
		// draw sprites & items
		drawRoomForeground(room, frameIndex, redrawAnimated);
	}

	// draw the player's avatar at its current position
	if ((redrawAll || redrawAnimated || redrawAvatar) && sprite[playerId] && sprite[playerId].room === room.id) {
		var spr = sprite[playerId];
		var x = spr.x;
		var y = spr.y;

		// get the avatar override sprite (if there is one)
		if (state.ava && state.ava != playerId && sprite[state.ava]) {
			spr = sprite[state.ava];
		}

		drawSprite(getSpriteFrame(spr, frameIndex), x, y);
	}
}

// TODO : remove these get*Image methods
function getTileFrame(t, frameIndex) {
	if (!renderer) {
		return null;
	}
	return renderer.GetDrawingFrame(t, frameIndex);
}

function getSpriteFrame(s, frameIndex) {
	if (!renderer) {
		return null;
	}
	return renderer.GetDrawingFrame(s, frameIndex);
}

function getItemFrame(itm, frameIndex) {
	if (!renderer) {
		return null;
	}
	return renderer.GetDrawingFrame(itm, frameIndex);
}

function curDefaultPal() {
	return getRoomPal(state.room);
}

function getRoomPal(roomId) {
	var defaultId = "default";

	if (roomId == null) {
		return defaultId;
	}
	else if (room[roomId].pal != null) {
		//a specific palette was chosen
		return room[roomId].pal;
	}
	else {
		if (roomId in palette) {
			//there is a palette matching the name of the room
			return roomId;
		}
		else {
			//use the default palette
			return defaultId;
		}
	}
	return defaultId;
}

var isDialogMode = false;
var isNarrating = false;
var isEnding = false;

var dialogModule;
var dialogRenderer;
var dialogBuffer;
if (engineFeatureFlags.isDialogEnabled) {
	dialogModule = new Dialog();
	dialogRenderer = dialogModule.CreateRenderer();
	dialogBuffer = dialogModule.CreateBuffer();
}

var fontManager;
if (engineFeatureFlags.isFontEnabled) {
	fontManager = new FontManager();
}

// TODO : is this scriptResult thing being used anywhere???
function onExitDialog(scriptResult, dialogCallback) {
	isDialogMode = false;
	bitsy.textbox(false);

	if (isNarrating) {
		isNarrating = false;

		// redraw the room
		drawRoom(room[state.room], { redrawAll: true });
	}

	if (isDialogPreview) {
		isDialogPreview = false;

		if (onDialogPreviewEnd != null) {
			onDialogPreviewEnd();
		}
	}

	if (dialogCallback != undefined && dialogCallback != null) {
		dialogCallback(scriptResult);
	}

	if (soundPlayer) {
		soundPlayer.resumeTune();
	}
}

/*
TODO
- titles and endings should also take advantage of the script pre-compilation if possible??
- could there be a namespace collision?
- what about dialog NAMEs vs IDs?
- what about a special script block separate from DLG?
*/
function startNarrating(dialogStr, end) {
	bitsy.log("NARRATE " + dialogStr);

	if(end === undefined) {
		end = false;
	}

	isNarrating = true;
	isEnding = end;

	if (isEnding && soundPlayer) {
		soundPlayer.stopTune();
	}

	// clear the room tiles before narrating
	bitsy.fill(bitsy.MAP1, 0);
	bitsy.fill(bitsy.MAP2, 0);

	startDialog(dialogStr);
}

function startEndingDialog(ending) {
	isNarrating = true;
	isEnding = true;

	var endingScriptId = ending.id;
	var endingDialogStr = dialog[ending.id].src;

	// compatibility with pre-7.0 endings
	if (flags.DLG_COMPAT === 1 && end[ending.id]) {
		endingScriptId = "end_compat_" + ending.id;
		endingDialogStr = end[ending.id].src;
	}

	var tmpTuneId = null;
	if (isEnding && soundPlayer) {
		tmpTuneId = soundPlayer.getCurTuneId();
		soundPlayer.stopTune();
	}

	startDialog(
		endingDialogStr,
		endingScriptId,
		function() {
			var isLocked = ending.property && ending.property.locked === true;
			if (isLocked) {
				isEnding = false;

				// if the ending was cancelled, restart the music
				// todo : should it resume from where it started? (right now it starts over)
				if (tmpTuneId && soundPlayer && !soundPlayer.isTunePlaying()) {
					soundPlayer.playTune(tune[tmpTuneId]);
				}
			}
		},
		ending);
}

function startItemDialog(itemId, dialogCallback) {
	var dialogId = item[itemId].dlg;
	// bitsy.log("START ITEM DIALOG " + dialogId);
	if (dialog[dialogId]) {
		var dialogStr = dialog[dialogId].src;
		startDialog(dialogStr, dialogId, dialogCallback);
	}
	else {
		dialogCallback();
	}
}

function startSpriteDialog(spriteId) {
	var spr = sprite[spriteId];
	var dialogId = spr.dlg;

	// back compat for when dialog IDs were implicitly the same as sprite IDs
	if (flags.DLG_COMPAT === 1 && (dialogId === undefined || dialogId === null)) {
		dialogId = spr.id;
	}

	// bitsy.log("START SPRITE DIALOG " + dialogId);
	if (dialog[dialogId]){
		var dialogStr = dialog[dialogId].src;
		startDialog(dialogStr, dialogId);
	}
}

function startDialog(dialogStr, scriptId, dialogCallback, objectContext) {
	bitsy.log("START DIALOG");

	if (soundPlayer) {
		soundPlayer.pauseTune();
	}

	if (dialogStr.length <= 0) {
		onExitDialog(null, dialogCallback);
		return;
	}

	if (!dialogBuffer) {
		bitsy.log(dialogStr);
		onExitDialog(null, dialogCallback);
		return;
	}

	if (!scriptInterpreter) {
		dialogRenderer.Reset();
		dialogRenderer.SetCentered(isNarrating /*centered*/);
		dialogBuffer.Reset();
		dialogBuffer.AddText(dialogStr);
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(null, dialogCallback);
		});
		bitsy.log("dialog start end");
		return;
	};

	isDialogMode = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered(isNarrating /*centered*/);
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer(dialogBuffer);

	var onScriptEnd = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, dialogCallback);
		});
	};

	if (scriptId === undefined) { // TODO : what's this for again?
		scriptInterpreter.Interpret(dialogStr, onScriptEnd);
	}
	else {
		if (!scriptInterpreter.HasScript(scriptId)) {
			scriptInterpreter.Compile(scriptId, dialogStr);
		}
		// scriptInterpreter.DebugVisualizeScript(scriptId);
		scriptInterpreter.Run(scriptId, onScriptEnd, objectContext);
	}

}

var isDialogPreview = false;
function startPreviewDialog(script, dialogCallback) {
	if (!scriptInterpreter || !dialogBuffer) {
		return;
	}

	isNarrating = true;

	isDialogMode = true;

	isDialogPreview = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered(true);
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer(dialogBuffer);

	// TODO : do I really need a seperate callback for this debug mode??
	onDialogPreviewEnd = dialogCallback;

	var onScriptEndCallback = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, null);
		});
	};

	scriptInterpreter.Eval(script, onScriptEndCallback);
}

/* NEW SCRIPT STUFF */
var scriptModule;
var scriptInterpreter;
var scriptUtils;
// scriptInterpreter.SetDialogBuffer( dialogBuffer );
if (engineFeatureFlags.isScriptEnabled) {
	bitsy.log("init script module");
	scriptModule = new Script();
	bitsy.log("init interpreter");
	scriptInterpreter = scriptModule.CreateInterpreter();
	bitsy.log("init utils");
	scriptUtils = scriptModule.CreateUtils(); // TODO: move to editor.js?
	bitsy.log("init script module end");
}

/* SOUND */
var soundPlayer;
if (engineFeatureFlags.isSoundEnabled) {
	soundPlayer = new SoundPlayer();
}

/* EVENTS */
bitsy.loop(update);
</script>

<!-- store default font in separate script tag for back compat-->
<script type="text/bitsyFontData" id="ascii_small">
FONT ascii_small
SIZE 6 8
CHAR 0
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 32
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 33
000100
001110
001110
000100
000100
000000
000100
000000
CHAR 34
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 8220
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 8221
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 35
000000
001010
011111
001010
001010
011111
001010
000000
CHAR 36
001000
001110
010000
001100
000010
011100
000100
000000
CHAR 37
011001
011001
000010
000100
001000
010011
010011
000000
CHAR 38
001000
010100
010100
001000
010101
010010
001101
000000
CHAR 39
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 8216
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 8217
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 40
000100
001000
001000
001000
001000
001000
000100
000000
CHAR 41
001000
000100
000100
000100
000100
000100
001000
000000
CHAR 42
000000
001010
001110
011111
001110
001010
000000
000000
CHAR 43
000000
000100
000100
011111
000100
000100
000000
000000
CHAR 44
000000
000000
000000
000000
000000
001100
001100
001000
CHAR 45
000000
000000
000000
011111
000000
000000
000000
000000
CHAR 46
000000
000000
000000
000000
000000
001100
001100
000000
CHAR 47
000000
000001
000010
000100
001000
010000
000000
000000
CHAR 48
001110
010001
010011
010101
011001
010001
001110
000000
CHAR 49
000100
001100
000100
000100
000100
000100
001110
000000
CHAR 50
001110
010001
000001
000110
001000
010000
011111
000000
CHAR 51
001110
010001
000001
001110
000001
010001
001110
000000
CHAR 52
000010
000110
001010
010010
011111
000010
000010
000000
CHAR 53
011111
010000
010000
011110
000001
010001
001110
000000
CHAR 54
000110
001000
010000
011110
010001
010001
001110
000000
CHAR 55
011111
000001
000010
000100
001000
001000
001000
000000
CHAR 56
001110
010001
010001
001110
010001
010001
001110
000000
CHAR 57
001110
010001
010001
001111
000001
000010
001100
000000
CHAR 58
000000
000000
001100
001100
000000
001100
001100
000000
CHAR 59
000000
000000
001100
001100
000000
001100
001100
001000
CHAR 60
000010
000100
001000
010000
001000
000100
000010
000000
CHAR 61
000000
000000
011111
000000
000000
011111
000000
000000
CHAR 62
001000
000100
000010
000001
000010
000100
001000
000000
CHAR 63
001110
010001
000001
000110
000100
000000
000100
000000
CHAR 64
001110
010001
010111
010101
010111
010000
001110
000000
CHAR 65
001110
010001
010001
010001
011111
010001
010001
000000
CHAR 66
011110
010001
010001
011110
010001
010001
011110
000000
CHAR 67
001110
010001
010000
010000
010000
010001
001110
000000
CHAR 68
011110
010001
010001
010001
010001
010001
011110
000000
CHAR 69
011111
010000
010000
011110
010000
010000
011111
000000
CHAR 70
011111
010000
010000
011110
010000
010000
010000
000000
CHAR 71
001110
010001
010000
010111
010001
010001
001111
000000
CHAR 72
010001
010001
010001
011111
010001
010001
010001
000000
CHAR 73
001110
000100
000100
000100
000100
000100
001110
000000
CHAR 74
000001
000001
000001
000001
010001
010001
001110
000000
CHAR 75
010001
010010
010100
011000
010100
010010
010001
000000
CHAR 76
010000
010000
010000
010000
010000
010000
011111
000000
CHAR 77
010001
011011
010101
010001
010001
010001
010001
000000
CHAR 78
010001
011001
010101
010011
010001
010001
010001
000000
CHAR 79
001110
010001
010001
010001
010001
010001
001110
000000
CHAR 80
011110
010001
010001
011110
010000
010000
010000
000000
CHAR 81
001110
010001
010001
010001
010101
010010
001101
000000
CHAR 82
011110
010001
010001
011110
010010
010001
010001
000000
CHAR 83
001110
010001
010000
001110
000001
010001
001110
000000
CHAR 84
011111
000100
000100
000100
000100
000100
000100
000000
CHAR 85
010001
010001
010001
010001
010001
010001
001110
000000
CHAR 86
010001
010001
010001
010001
010001
001010
000100
000000
CHAR 87
010001
010001
010101
010101
010101
010101
001010
000000
CHAR 88
010001
010001
001010
000100
001010
010001
010001
000000
CHAR 89
010001
010001
010001
001010
000100
000100
000100
000000
CHAR 90
011110
000010
000100
001000
010000
010000
011110
000000
CHAR 91
001110
001000
001000
001000
001000
001000
001110
000000
CHAR 92
000000
010000
001000
000100
000010
000001
000000
000000
CHAR 93
001110
000010
000010
000010
000010
000010
001110
000000
CHAR 94
000100
001010
010001
000000
000000
000000
000000
000000
CHAR 95
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 96
001100
001100
000100
000000
000000
000000
000000
000000
CHAR 97
000000
000000
001110
000001
001111
010001
001111
000000
CHAR 98
010000
010000
011110
010001
010001
010001
011110
000000
CHAR 99
000000
000000
001110
010001
010000
010001
001110
000000
CHAR 100
000001
000001
001111
010001
010001
010001
001111
000000
CHAR 101
000000
000000
001110
010001
011110
010000
001110
000000
CHAR 102
000110
001000
001000
011110
001000
001000
001000
000000
CHAR 103
000000
000000
001111
010001
010001
001111
000001
001110
CHAR 104
010000
010000
011100
010010
010010
010010
010010
000000
CHAR 105
000100
000000
000100
000100
000100
000100
000110
000000
CHAR 106
000010
000000
000110
000010
000010
000010
010010
001100
CHAR 107
010000
010000
010010
010100
011000
010100
010010
000000
CHAR 108
000100
000100
000100
000100
000100
000100
000110
000000
CHAR 109
000000
000000
011010
010101
010101
010001
010001
000000
CHAR 110
000000
000000
011100
010010
010010
010010
010010
000000
CHAR 111
000000
000000
001110
010001
010001
010001
001110
000000
CHAR 112
000000
000000
011110
010001
010001
010001
011110
010000
CHAR 113
000000
000000
001111
010001
010001
010001
001111
000001
CHAR 114
000000
000000
010110
001001
001000
001000
011100
000000
CHAR 115
000000
000000
001110
010000
001110
000001
001110
000000
CHAR 116
000000
001000
011110
001000
001000
001010
000100
000000
CHAR 117
000000
000000
010010
010010
010010
010110
001010
000000
CHAR 118
000000
000000
010001
010001
010001
001010
000100
000000
CHAR 119
000000
000000
010001
010001
010101
011111
001010
000000
CHAR 120
000000
000000
010010
010010
001100
010010
010010
000000
CHAR 121
000000
000000
010010
010010
010010
001110
000100
011000
CHAR 122
000000
000000
011110
000010
001100
010000
011110
000000
CHAR 123
000110
001000
001000
011000
001000
001000
000110
000000
CHAR 124
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 125
001100
000010
000010
000011
000010
000010
001100
000000
CHAR 126
000000
000000
000000
001010
010100
000000
000000
000000
CHAR 160
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 161
000100
000000
000100
000100
001110
001110
000100
000000
CHAR 162
000000
000100
001110
010000
010000
001110
000100
000000
CHAR 163
000110
001001
001000
011110
001000
001001
010111
000000
CHAR 165
010001
001010
000100
011111
000100
011111
000100
000000
CHAR 167
001110
010001
001100
001010
000110
010001
001110
000000
CHAR 171
000000
000000
001001
010010
001001
000000
000000
000000
CHAR 172
000000
000000
111111
000001
000001
000000
000000
000000
CHAR 177
000000
000100
001110
000100
000000
001110
000000
000000
CHAR 178
011000
000100
001000
011100
000000
000000
000000
000000
CHAR 181
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 182
001111
010101
010101
001101
000101
000101
000101
000000
CHAR 187
000000
000000
010010
001001
010010
000000
000000
000000
CHAR 188
010000
010010
010100
001011
010101
000111
000001
000000
CHAR 189
010000
010010
010100
001110
010001
000010
000111
000000
CHAR 191
000100
000000
000100
001100
010000
010001
001110
000000
CHAR 196
001010
000000
000100
001010
010001
011111
010001
000000
CHAR 197
001110
001010
001110
011011
010001
011111
010001
000000
CHAR 198
001111
010100
010100
011111
010100
010100
010111
000000
CHAR 199
001110
010001
010000
010000
010001
001110
000100
001100
CHAR 201
000011
000000
011111
010000
011110
010000
011111
000000
CHAR 209
001010
010100
000000
010010
011010
010110
010010
000000
CHAR 214
010010
001100
010010
010010
010010
010010
001100
000000
CHAR 220
001010
000000
010010
010010
010010
010010
001100
000000
CHAR 223
000000
011100
010010
011100
010010
010010
011100
010000
CHAR 224
001100
000000
001110
000001
001111
010001
001111
000000
CHAR 225
000110
000000
001110
000001
001111
010001
001111
000000
CHAR 226
001110
000000
001110
000001
001111
010001
001111
000000
CHAR 228
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 229
001110
001010
001110
000001
001111
010001
001111
000000
CHAR 230
000000
000000
011110
000101
011111
010100
001111
000000
CHAR 231
000000
001110
010001
010000
010001
001110
000100
001100
CHAR 232
001100
000000
001110
010001
011110
010000
001110
000000
CHAR 233
000011
000000
001110
010001
011110
010000
001110
000000
CHAR 234
001110
000000
001110
010001
011110
010000
001110
000000
CHAR 235
001010
000000
001110
010001
011110
010000
001110
000000
CHAR 236
001000
000000
000100
000100
000100
000100
000110
000000
CHAR 237
000110
000000
000100
000100
000100
000100
000110
000000
CHAR 238
000100
001010
000000
000100
000100
000100
000110
000000
CHAR 239
001010
000000
000100
000100
000100
000100
000110
000000
CHAR 241
001010
010100
000000
011100
010010
010010
010010
000000
CHAR 242
011000
000000
001100
010010
010010
010010
001100
000000
CHAR 243
000110
000000
001100
010010
010010
010010
001100
000000
CHAR 244
001110
000000
001100
010010
010010
010010
001100
000000
CHAR 246
001010
000000
001100
010010
010010
010010
001100
000000
CHAR 247
001010
000000
001110
010001
010001
010001
001110
000000
CHAR 249
011000
000000
010010
010010
010010
010110
001010
000000
CHAR 250
000110
000000
010010
010010
010010
010110
001010
000000
CHAR 251
001110
000000
010010
010010
010010
010110
001010
000000
CHAR 252
010010
000000
010010
010010
010010
010110
001010
000000
CHAR 255
001010
000000
010010
010010
010010
001110
000100
011000
CHAR 402
000010
000101
000100
001110
000100
000100
010100
001000
CHAR 915
011110
010010
010000
010000
010000
010000
010000
000000
CHAR 920
001100
010010
010010
011110
010010
010010
001100
000000
CHAR 931
011111
010000
001000
000100
001000
010000
011111
000000
CHAR 934
001110
000100
001110
010001
001110
000100
001110
000000
CHAR 937
000000
001110
010001
010001
001010
001010
011011
000000
CHAR 948
001100
010000
001000
000100
001110
010010
001100
000000
CHAR 949
000000
001110
010000
011110
010000
001110
000000
000000
CHAR 960
000000
011111
001010
001010
001010
001010
001010
000000
CHAR 963
000000
000000
001111
010010
010010
001100
000000
000000
CHAR 964
000000
000000
001010
010100
000100
000100
000100
000000
CHAR 966
000000
000100
001110
010101
010101
001110
000100
000000
CHAR 8226
000000
000000
000000
001100
001100
000000
000000
000000
CHAR 8252
001010
001010
001010
001010
001010
000000
001010
000000
CHAR 8592
000000
000100
001100
011111
001100
000100
000000
000000
CHAR 8593
000100
001110
011111
000100
000100
000100
000100
000000
CHAR 8594
000000
000100
000110
011111
000110
000100
000000
000000
CHAR 8595
000100
000100
000100
000100
011111
001110
000100
000000
CHAR 8734
000000
000000
001010
010101
010101
001010
000000
000000
CHAR 8735
000000
000000
000000
010000
010000
010000
011111
000000
CHAR 8801
000000
011110
000000
011110
000000
011110
000000
000000
CHAR 8804
000010
001100
010000
001100
000010
000000
011110
000000
CHAR 8805
010000
001100
000010
001100
010000
000000
011110
000000
CHAR 8962
000100
001110
011011
010001
010001
011111
000000
000000
CHAR 8976
000000
000000
011111
010000
010000
010000
000000
000000
CHAR 9472
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 9474
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 9488
000000
000000
000000
111100
000100
000100
000100
000100
CHAR 9492
000100
000100
000100
000111
000000
000000
000000
000000
CHAR 9500
000100
000100
000100
000111
000100
000100
000100
000100
CHAR 9508
000100
000100
000100
111100
000100
000100
000100
000100
CHAR 9516
000000
000000
000000
111111
000100
000100
000100
000100
CHAR 9524
000100
000100
000100
111111
000000
000000
000000
000000
CHAR 9532
000100
000100
000100
111111
000100
000100
000100
000100
CHAR 9552
000000
111111
000000
111111
000000
000000
000000
000000
CHAR 9553
010100
010100
010100
010100
010100
010100
010100
010100
CHAR 9556
000000
011111
010000
010111
010100
010100
010100
010100
CHAR 9557
000000
111100
000100
111100
000100
000100
000100
000100
CHAR 9558
000000
000000
000000
111100
010100
010100
010100
010100
CHAR 9559
000000
111100
000100
110100
010100
010100
010100
010100
CHAR 9561
010100
010100
010100
011111
000000
000000
000000
000000
CHAR 9562
010100
010111
010000
011111
000000
000000
000000
000000
CHAR 9563
000100
111100
000100
111100
000000
000000
000000
000000
CHAR 9564
010100
010100
010100
111100
000000
000000
000000
000000
CHAR 9565
010100
110100
000100
111100
000000
000000
000000
000000
CHAR 9566
000100
000111
000100
000111
000100
000100
000100
000100
CHAR 9567
010100
010100
010100
010111
010100
010100
010100
010100
CHAR 9568
010100
010111
010000
010111
010100
010100
010100
010100
CHAR 9569
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 9570
010100
010100
010100
110100
010100
010100
010100
010100
CHAR 9571
010100
110100
000100
110100
010100
010100
010100
010100
CHAR 9572
000000
111111
000000
111111
000100
000100
000100
000100
CHAR 9573
000000
000000
000000
111111
010100
010100
010100
010100
CHAR 9574
000000
111111
000000
110111
010100
010100
010100
010100
CHAR 9575
000100
111111
000000
111111
000000
000000
000000
000000
CHAR 9576
010100
010100
010100
111111
000000
000000
000000
000000
CHAR 9577
010100
110111
000000
111111
000000
000000
000000
000000
CHAR 9580
010100
110111
000000
110111
010100
010100
010100
010100
CHAR 9601
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 9602
000000
000000
000000
000000
000000
000000
111111
111111
CHAR 9603
000000
000000
000000
000000
000000
111111
111111
111111
CHAR 9604
000000
000000
000000
000000
111111
111111
111111
111111
CHAR 9605
000000
000000
000000
111111
111111
111111
111111
111111
CHAR 9606
000000
000000
111111
111111
111111
111111
111111
111111
CHAR 9607
000000
111111
111111
111111
111111
111111
111111
111111
CHAR 9608
111111
111111
111111
111111
111111
111111
111111
111111
CHAR 9609
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9610
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9611
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 9613
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 9615
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 9617
010101
000000
101010
000000
010101
000000
101010
000000
CHAR 9618
010101
101010
010101
101010
010101
101010
010101
101010
CHAR 9619
101010
111111
010101
111111
101010
111111
010101
111111
CHAR 9644
000000
000000
000000
000000
000000
011110
011110
000000
CHAR 9650
000100
000100
001110
001110
011111
011111
000000
000000
CHAR 9658
001000
001100
001110
001111
001110
001100
001000
000000
CHAR 9660
011111
011111
001110
001110
000100
000100
000000
000000
CHAR 9668
000010
000110
001110
011110
001110
000110
000010
000000
CHAR 9675
000000
000000
011110
010010
010010
011110
000000
000000
CHAR 9688
111111
111111
111111
110011
110011
111111
111111
111111
CHAR 9689
111111
111111
100001
101101
101101
100001
111111
111111
CHAR 9786
001110
010001
011011
010001
010101
010001
001110
000000
CHAR 9787
001110
011111
010101
011111
010001
011111
001110
000000
CHAR 9788
000000
010101
001110
011011
001110
010101
000000
000000
CHAR 9792
001110
010001
010001
001110
000100
001110
000100
000000
CHAR 9794
000000
000111
000011
001101
010010
010010
001100
000000
CHAR 9824
000000
000100
001110
011111
011111
000100
001110
000000
CHAR 9827
000100
001110
001110
000100
011111
011111
000100
000000
CHAR 9829
000000
001010
011111
011111
011111
001110
000100
000000
CHAR 9830
000000
000100
001110
011111
011111
001110
000100
000000
CHAR 9834
000100
000110
000101
000100
001100
011100
011000
000000
CHAR 9835
000011
001101
001011
001101
001011
011011
011000
000000
</script>

<!-- BORKSY HACKS -->
<script type="text/javascript" id="borksyHacks">
/**
🎺
@file dialog audio vocal synth
@summary animal crossing-style audio powered by the pink trombone vocal synth
@license MIT
@author Sean S. LeBlanc
@version 22.1.0
@requires Bitsy 8.12


@description
An extension of the dialog audio hack which incorporates
a vocal synth with multiple voice support

Voices are defined in `hackOptions.voices` below
A default voice is required, but the volume can be set to zero if needed
Other voices don't need to have every property specified:
if one is missing, it will use the default voice's value instead

Usage:
	(voice "<voice name>")

Parameter notes:
	- Valid voice names are the keys in `hackOptions.voices`
	- If a voice name is used that does not exist, the default voice will be used instead

Examples:
	(voice "myVoice")
	(voice "default")
	(voice "") // same effect as default

Note: most of the credit for this goes to Neil Thapen,
the creator of the Pink Trombone vocal synth;
this uses a fork of its source code to drive the audio

HOW TO USE:
1. Copy-paste into a script tag after the bitsy source
2. Edit `hackOptions` below as needed
3. Add (voice "<voice name>") commands to your dialog as needed
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions =  {
	autoReset: true, // if true, automatically resets the voice to default when dialog is exited
	// list of voices that can be used with the provided dialog command
	// the values use for voice parameters are [base, range] pairs for RNG;
	// e.g. [0.5, 0.1] will produce values between 0.4 and 0.6
	voices: {
		default: {
			// volume randomly applied to each letter
			volume: [0.3, 0.1],
			// pitch randomly applied to each letter
			pitch: [240, 200],
			// vibrato randomly applied to each letter
			vibrato: [0.01, 0.005],
			// how much phonemes to affect tract shape
			phoneme: [0.9, 0.1],
			// multiplier for nasalness (based on phoneme)
			nasal: [0.9, 0.1],
			// multiplier for voiced (based on phoneme)
			voiced: [0.4, 0.2],
			// note: tongue is a modification *on top* of the phoneme modification
			// where to modify
			tonguePosition: [0.5, 0.5],
			// range from the position in which points are modified
			tongueSize: [0.3, 0.2],
			// how much modification is applied (this is a multiplier, so base: 1, range: 0 means no modification)
			tongueAmount: [1.0, 0.1],
		},
		// an example voice which overrides the default's pitch and vibrato
		overrideExample: {
			pitch: [650, 325],
			vibrato: [0.3, 0.1],
		},
	},
};

/*
 * A speed-improved perlin and simplex noise algorithms for 2D.
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 * Converted to Javascript by Joseph Gentle.
 *
 * Version 2012-03-09
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 *
 */

var module = {};

function Grad(x, y, z) {
	this.x = x;
	this.y = y;
	this.z = z;
}

Grad.prototype.dot2 = function (x, y) {
	return this.x * x + this.y * y;
};

Grad.prototype.dot3 = function (x, y, z) {
	return this.x * x + this.y * y + this.z * z;
};

var grad3 = [new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0),
	new Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1),
	new Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)
];

var p = [151, 160, 137, 91, 90, 15,
	131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,
	190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
	88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,
	77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,
	102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
	135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
	5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,
	223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,
	129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,
	251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,
	49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
	138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180
];
// To remove the need for index wrapping, double the permutation table length
var perm = new Array(512);
var gradP = new Array(512);

// This isn't a very good seeding function, but it works ok. It supports 2^16
// different seed values. Write something better if you need more seeds.
module.seed = function (seed) {
	if (seed > 0 && seed < 1) {
		// Scale the seed out
		seed *= 65536;
	}

	seed = Math.floor(seed);
	if (seed < 256) {
		seed |= seed << 8;
	}

	for (var i = 0; i < 256; i++) {
		var v;
		if (i & 1) {
			v = p[i] ^ (seed & 255);
		} else {
			v = p[i] ^ ((seed >> 8) & 255);
		}

		perm[i] = perm[i + 256] = v;
		gradP[i] = gradP[i + 256] = grad3[v % 12];
	}
};

module.seed(Date.now());

/*
for(var i=0; i<256; i++) {
  perm[i] = perm[i + 256] = p[i];
  gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];
}*/

// Skewing and unskewing factors for 2, 3, and 4 dimensions
var F2 = 0.5 * (Math.sqrt(3) - 1);
var G2 = (3 - Math.sqrt(3)) / 6;

// 2D simplex noise
module.simplex2 = function (xin, yin) {
	var n0, n1, n2; // Noise contributions from the three corners
	// Skew the input space to determine which simplex cell we're in
	var s = (xin + yin) * F2; // Hairy factor for 2D
	var i = Math.floor(xin + s);
	var j = Math.floor(yin + s);
	var t = (i + j) * G2;
	var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.
	var y0 = yin - j + t;
	// For the 2D case, the simplex shape is an equilateral triangle.
	// Determine which simplex we are in.
	var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
	if (x0 > y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)
		i1 = 1;
		j1 = 0;
	} else { // upper triangle, YX order: (0,0)->(0,1)->(1,1)
		i1 = 0;
		j1 = 1;
	}
	// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
	// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
	// c = (3-sqrt(3))/6
	var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
	var y1 = y0 - j1 + G2;
	var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords
	var y2 = y0 - 1 + 2 * G2;
	// Work out the hashed gradient indices of the three simplex corners
	i &= 255;
	j &= 255;
	var gi0 = gradP[i + perm[j]];
	var gi1 = gradP[i + i1 + perm[j + j1]];
	var gi2 = gradP[i + 1 + perm[j + 1]];
	// Calculate the contribution from the three corners
	var t0 = 0.5 - x0 * x0 - y0 * y0;
	if (t0 < 0) {
		n0 = 0;
	} else {
		t0 *= t0;
		n0 = t0 * t0 * gi0.dot2(x0, y0); // (x,y) of grad3 used for 2D gradient
	}
	var t1 = 0.5 - x1 * x1 - y1 * y1;
	if (t1 < 0) {
		n1 = 0;
	} else {
		t1 *= t1;
		n1 = t1 * t1 * gi1.dot2(x1, y1);
	}
	var t2 = 0.5 - x2 * x2 - y2 * y2;
	if (t2 < 0) {
		n2 = 0;
	} else {
		t2 *= t2;
		n2 = t2 * t2 * gi2.dot2(x2, y2);
	}
	// Add contributions from each corner to get the final noise value.
	// The result is scaled to return values in the interval [-1,1].
	return 70 * (n0 + n1 + n2);
};

module.simplex1 = function (x) {
	return module.simplex2(x * 1.2, -x * 0.7);
};

/**
P I N K   T R O M B O N E

Bare-handed procedural speech synthesis

version 1.1, March 2017
by Neil Thapen
venuspatrol.nfshost.com


Bibliography

Julius O. Smith III, "Physical audio signal processing for virtual musical instruments and audio effects."
https://ccrma.stanford.edu/~jos/pasp/

Story, Brad H. "A parametric model of the vocal tract area function for vowel and consonant simulation." 
The Journal of the Acoustical Society of America 117.5 (2005): 3231-3254.

Lu, Hui-Ling, and J. O. Smith. "Glottal source modeling for singing voice synthesis." 
Proceedings of the 2000 International Computer Music Conference. 2000.

Mullen, Jack. Physical modelling of the vocal tract with the 2D digital waveguide mesh. 
PhD thesis, University of York, 2006.


Copyright 2017 Neil Thapen 

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the 
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
IN THE SOFTWARE.
*/

function clamp$1(number, min, max) {
	if (number < min) return min;
	else if (number > max) return max;
	else return number;
}

function moveTowards(current, target, amountUp, amountDown) {
	if (current < target) return Math.min(current + amountUp, target);
	else return Math.max(current - amountDown, target);
}

var sampleRate;
var alwaysVoice = false;

var AudioSystem = {
	blockLength: 512,
	blockTime: 1,
	started: false,
	soundOn: false,

	init: function () {
		window.AudioContext = window.AudioContext || window.webkitAudioContext;
		this.audioContext = new window.AudioContext();
		sampleRate = this.audioContext.sampleRate;

		this.blockTime = this.blockLength / sampleRate;

		var unmute = () => {
			if (!this.started) {
				this.started = true;
				this.startSound();
				document.removeEventListener('pointerup', unmute);
				document.removeEventListener('keydown', unmute);
			}
		};

		document.addEventListener('pointerup', unmute);
		document.addEventListener('keydown', unmute);
	},

	startSound: function () {
		//scriptProcessor may need a dummy input channel on iOS
		this.scriptProcessor = this.audioContext.createScriptProcessor(this.blockLength, 2, 1);
		this.scriptProcessor.connect(this.audioContext.destination);
		this.scriptProcessor.onaudioprocess = AudioSystem.doScriptProcessor;

		var whiteNoise = this.createWhiteNoiseNode(2 * sampleRate); // 2 seconds of noise

		var aspirateFilter = this.audioContext.createBiquadFilter();
		aspirateFilter.type = "bandpass";
		aspirateFilter.frequency.value = 500;
		aspirateFilter.Q.value = 0.5;
		whiteNoise.connect(aspirateFilter);
		aspirateFilter.connect(this.scriptProcessor);

		var fricativeFilter = this.audioContext.createBiquadFilter();
		fricativeFilter.type = "bandpass";
		fricativeFilter.frequency.value = 1000;
		fricativeFilter.Q.value = 0.5;
		whiteNoise.connect(fricativeFilter);
		fricativeFilter.connect(this.scriptProcessor);

		whiteNoise.start(0);
	},

	createWhiteNoiseNode: function (frameCount) {
		var myArrayBuffer = this.audioContext.createBuffer(1, frameCount, sampleRate);

		var nowBuffering = myArrayBuffer.getChannelData(0);
		for (var i = 0; i < frameCount; i++) {
			nowBuffering[i] = Math.random(); // gaussian();
		}

		var source = this.audioContext.createBufferSource();
		source.buffer = myArrayBuffer;
		source.loop = true;

		return source;
	},


	doScriptProcessor: function (event) {
		var inputArray1 = event.inputBuffer.getChannelData(0);
		var inputArray2 = event.inputBuffer.getChannelData(1);
		var outArray = event.outputBuffer.getChannelData(0);
		for (var j = 0, N = outArray.length; j < N; j++) {
			var lambda1 = j / N;
			var lambda2 = (j + 0.5) / N;
			var glottalOutput = Glottis.runStep(lambda1, inputArray1[j]);

			var vocalOutput = 0;
			//Tract runs at twice the sample rate 
			Tract.runStep(glottalOutput, inputArray2[j], lambda1);
			vocalOutput += Tract.lipOutput + Tract.noseOutput;
			Tract.runStep(glottalOutput, inputArray2[j], lambda2);
			vocalOutput += Tract.lipOutput + Tract.noseOutput;
			outArray[j] = vocalOutput * 0.125;
		}
		Glottis.finishBlock();
		Tract.finishBlock();
	},

	mute: function () {
		this.scriptProcessor.disconnect();
	},

	unmute: function () {
		this.scriptProcessor.connect(this.audioContext.destination);
	}
};

var Glottis = {
	timeInWaveform: 0,
	oldFrequency: 140,
	newFrequency: 140,
	UIFrequency: 140,
	smoothFrequency: 140,
	oldTenseness: 0.6,
	newTenseness: 0.6,
	UITenseness: 0.6,
	totalTime: 0,
	vibratoAmount: 0.005,
	vibratoFrequency: 6,
	intensity: 0,
	loudness: 1,
	isTouched: false,

	init: function () {
		this.setupWaveform(0);
	},

	runStep: function (lambda, noiseSource) {
		var timeStep = 1.0 / sampleRate;
		this.timeInWaveform += timeStep;
		this.totalTime += timeStep;
		if (this.timeInWaveform > this.waveformLength) {
			this.timeInWaveform -= this.waveformLength;
			this.setupWaveform(lambda);
		}
		var out = this.normalizedLFWaveform(this.timeInWaveform / this.waveformLength);
		var aspiration = this.intensity * (1 - Math.sqrt(this.UITenseness)) * this.getNoiseModulator() * noiseSource;
		aspiration *= 0.2 + 0.02 * module.simplex1(this.totalTime * 1.99);
		out += aspiration;
		return out;
	},

	getNoiseModulator: function () {
		var voiced = 0.1 + 0.2 * Math.max(0, Math.sin(Math.PI * 2 * this.timeInWaveform / this.waveformLength));
		//return 0.3;
		return this.UITenseness * this.intensity * voiced + (1 - this.UITenseness * this.intensity) * 0.3;
	},

	finishBlock: function () {
		var vibrato = 0;
		vibrato += this.vibratoAmount * Math.sin(2 * Math.PI * this.totalTime * this.vibratoFrequency);
		vibrato += 0.02 * module.simplex1(this.totalTime * 4.07);
		vibrato += 0.04 * module.simplex1(this.totalTime * 2.15);
		if (this.UIFrequency > this.smoothFrequency)
			this.smoothFrequency = Math.min(this.smoothFrequency * 1.1, this.UIFrequency);
		if (this.UIFrequency < this.smoothFrequency)
			this.smoothFrequency = Math.max(this.smoothFrequency / 1.1, this.UIFrequency);
		this.oldFrequency = this.newFrequency;
		this.newFrequency = this.smoothFrequency * (1 + vibrato);
		this.oldTenseness = this.newTenseness;
		this.newTenseness = this.UITenseness +
			0.1 * module.simplex1(this.totalTime * 0.46) + 0.05 * module.simplex1(this.totalTime * 0.36);
		if (!this.isTouched && alwaysVoice) this.newTenseness += (3 - this.UITenseness) * (1 - this.intensity);

		if (this.isTouched || alwaysVoice) this.intensity += 0.13;
		else this.intensity -= 0.05;
		this.intensity = clamp$1(this.intensity, 0, 1);
	},

	setupWaveform: function (lambda) {
		this.frequency = this.oldFrequency * (1 - lambda) + this.newFrequency * lambda;
		var tenseness = this.oldTenseness * (1 - lambda) + this.newTenseness * lambda;
		this.Rd = 3 * (1 - tenseness);
		this.waveformLength = 1.0 / this.frequency;

		var Rd = this.Rd;
		if (Rd < 0.5) Rd = 0.5;
		if (Rd > 2.7) Rd = 2.7;
		// normalized to time = 1, Ee = 1
		var Ra = -0.01 + 0.048 * Rd;
		var Rk = 0.224 + 0.118 * Rd;
		var Rg = (Rk / 4) * (0.5 + 1.2 * Rk) / (0.11 * Rd - Ra * (0.5 + 1.2 * Rk));

		var Ta = Ra;
		var Tp = 1 / (2 * Rg);
		var Te = Tp + Tp * Rk; //

		var epsilon = 1 / Ta;
		var shift = Math.exp(-epsilon * (1 - Te));
		var Delta = 1 - shift; //divide by this to scale RHS

		var RHSIntegral = (1 / epsilon) * (shift - 1) + (1 - Te) * shift;
		RHSIntegral = RHSIntegral / Delta;

		var totalLowerIntegral = -(Te - Tp) / 2 + RHSIntegral;
		var totalUpperIntegral = -totalLowerIntegral;

		var omega = Math.PI / Tp;
		var s = Math.sin(omega * Te);
		// need E0*e^(alpha*Te)*s = -1 (to meet the return at -1)
		// and E0*e^(alpha*Tp/2) * Tp*2/pi = totalUpperIntegral 
		//             (our approximation of the integral up to Tp)
		// writing x for e^alpha,
		// have E0*x^Te*s = -1 and E0 * x^(Tp/2) * Tp*2/pi = totalUpperIntegral
		// dividing the second by the first,
		// letting y = x^(Tp/2 - Te),
		// y * Tp*2 / (pi*s) = -totalUpperIntegral;
		var y = -Math.PI * s * totalUpperIntegral / (Tp * 2);
		var z = Math.log(y);
		var alpha = z / (Tp / 2 - Te);
		var E0 = -1 / (s * Math.exp(alpha * Te));
		this.alpha = alpha;
		this.E0 = E0;
		this.epsilon = epsilon;
		this.shift = shift;
		this.Delta = Delta;
		this.Te = Te;
		this.omega = omega;
	},

	normalizedLFWaveform: function (t) {
		var output;
		if (t > this.Te) output = (-Math.exp(-this.epsilon * (t - this.Te)) + this.shift) / this.Delta;
		else output = this.E0 * Math.exp(this.alpha * t) * Math.sin(this.omega * t);

		return output * this.intensity * this.loudness;
	}
};


var Tract = {
	n: 44,
	bladeStart: 10,
	tipStart: 32,
	lipStart: 39,
	R: [], //component going right
	L: [], //component going left
	reflection: [],
	junctionOutputR: [],
	junctionOutputL: [],
	maxAmplitude: [],
	diameter: [],
	restDiameter: [],
	targetDiameter: [],
	newDiameter: [],
	A: [],
	glottalReflection: 0.75,
	lipReflection: -0.85,
	lastObstruction: -1,
	fade: 1.0, //0.9999,
	movementSpeed: 15, //cm per second
	transients: [],
	lipOutput: 0,
	noseOutput: 0,
	velumTarget: 0.01,

	init: function () {
		this.bladeStart = Math.floor(this.bladeStart * this.n / 44);
		this.tipStart = Math.floor(this.tipStart * this.n / 44);
		this.lipStart = Math.floor(this.lipStart * this.n / 44);
		this.diameter = new Float64Array(this.n);
		this.restDiameter = new Float64Array(this.n);
		this.targetDiameter = new Float64Array(this.n);
		this.newDiameter = new Float64Array(this.n);
		for (var i = 0; i < this.n; i++) {
			var diameter = 0;
			if (i < 7 * this.n / 44 - 0.5) diameter = 0.6;
			else if (i < 12 * this.n / 44) diameter = 1.1;
			else diameter = 1.5;
			this.diameter[i] = this.restDiameter[i] = this.targetDiameter[i] = this.newDiameter[i] = diameter;
		}
		this.R = new Float64Array(this.n);
		this.L = new Float64Array(this.n);
		this.reflection = new Float64Array(this.n + 1);
		this.newReflection = new Float64Array(this.n + 1);
		this.junctionOutputR = new Float64Array(this.n + 1);
		this.junctionOutputL = new Float64Array(this.n + 1);
		this.A = new Float64Array(this.n);
		this.maxAmplitude = new Float64Array(this.n);

		this.noseLength = Math.floor(28 * this.n / 44);
		this.noseStart = this.n - this.noseLength + 1;
		this.noseR = new Float64Array(this.noseLength);
		this.noseL = new Float64Array(this.noseLength);
		this.noseJunctionOutputR = new Float64Array(this.noseLength + 1);
		this.noseJunctionOutputL = new Float64Array(this.noseLength + 1);
		this.noseReflection = new Float64Array(this.noseLength + 1);
		this.noseDiameter = new Float64Array(this.noseLength);
		this.noseA = new Float64Array(this.noseLength);
		this.noseMaxAmplitude = new Float64Array(this.noseLength);
		for (var i = 0; i < this.noseLength; i++) {
			var diameter;
			var d = 2 * (i / this.noseLength);
			if (d < 1) diameter = 0.4 + 1.6 * d;
			else diameter = 0.5 + 1.5 * (2 - d);
			diameter = Math.min(diameter, 1.9);
			this.noseDiameter[i] = diameter;
		}
		this.newReflectionLeft = this.newReflectionRight = this.newReflectionNose = 0;
		this.calculateReflections();
		this.calculateNoseReflections();
		this.noseDiameter[0] = this.velumTarget;
	},

	reshapeTract: function (deltaTime) {
		var amount = deltaTime * this.movementSpeed;		var newLastObstruction = -1;
		for (var i = 0; i < this.n; i++) {
			var diameter = this.diameter[i];
			var targetDiameter = this.targetDiameter[i];
			if (diameter <= 0) newLastObstruction = i;
			var slowReturn;
			if (i < this.noseStart) slowReturn = 0.6;
			else if (i >= this.tipStart) slowReturn = 1.0;
			else slowReturn = 0.6 + 0.4 * (i - this.noseStart) / (this.tipStart - this.noseStart);
			this.diameter[i] = moveTowards(diameter, targetDiameter, slowReturn * amount, 2 * amount);
		}
		if (this.lastObstruction > -1 && newLastObstruction == -1 && this.noseA[0] < 0.05) {
			this.addTransient(this.lastObstruction);
		}
		this.lastObstruction = newLastObstruction;

		amount = deltaTime * this.movementSpeed;
		this.noseDiameter[0] = moveTowards(this.noseDiameter[0], this.velumTarget,
			amount * 0.25, amount * 0.1);
		this.noseA[0] = this.noseDiameter[0] * this.noseDiameter[0];
	},

	calculateReflections: function () {
		for (var i = 0; i < this.n; i++) {
			this.A[i] = this.diameter[i] * this.diameter[i]; //ignoring PI etc.
		}
		for (var i = 1; i < this.n; i++) {
			this.reflection[i] = this.newReflection[i];
			if (this.A[i] == 0) this.newReflection[i] = 0.999; //to prevent some bad behaviour if 0
			else this.newReflection[i] = (this.A[i - 1] - this.A[i]) / (this.A[i - 1] + this.A[i]);
		}

		//now at junction with nose

		this.reflectionLeft = this.newReflectionLeft;
		this.reflectionRight = this.newReflectionRight;
		this.reflectionNose = this.newReflectionNose;
		var sum = this.A[this.noseStart] + this.A[this.noseStart + 1] + this.noseA[0];
		this.newReflectionLeft = (2 * this.A[this.noseStart] - sum) / sum;
		this.newReflectionRight = (2 * this.A[this.noseStart + 1] - sum) / sum;
		this.newReflectionNose = (2 * this.noseA[0] - sum) / sum;
	},

	calculateNoseReflections: function () {
		for (var i = 0; i < this.noseLength; i++) {
			this.noseA[i] = this.noseDiameter[i] * this.noseDiameter[i];
		}
		for (var i = 1; i < this.noseLength; i++) {
			this.noseReflection[i] = (this.noseA[i - 1] - this.noseA[i]) / (this.noseA[i - 1] + this.noseA[i]);
		}
	},

	runStep: function (glottalOutput, turbulenceNoise, lambda) {
		var updateAmplitudes = (Math.random() < 0.1);

		//mouth
		this.processTransients();

		//this.glottalReflection = -0.8 + 1.6 * Glottis.newTenseness;
		this.junctionOutputR[0] = this.L[0] * this.glottalReflection + glottalOutput;
		this.junctionOutputL[this.n] = this.R[this.n - 1] * this.lipReflection;

		for (var i = 1; i < this.n; i++) {
			var r = this.reflection[i] * (1 - lambda) + this.newReflection[i] * lambda;
			var w = r * (this.R[i - 1] + this.L[i]);
			this.junctionOutputR[i] = this.R[i - 1] - w;
			this.junctionOutputL[i] = this.L[i] + w;
		}

		//now at junction with nose
		var i = this.noseStart;
		var r = this.newReflectionLeft * (1 - lambda) + this.reflectionLeft * lambda;
		this.junctionOutputL[i] = r * this.R[i - 1] + (1 + r) * (this.noseL[0] + this.L[i]);
		r = this.newReflectionRight * (1 - lambda) + this.reflectionRight * lambda;
		this.junctionOutputR[i] = r * this.L[i] + (1 + r) * (this.R[i - 1] + this.noseL[0]);
		r = this.newReflectionNose * (1 - lambda) + this.reflectionNose * lambda;
		this.noseJunctionOutputR[0] = r * this.noseL[0] + (1 + r) * (this.L[i] + this.R[i - 1]);

		for (var i = 0; i < this.n; i++) {
			this.R[i] = this.junctionOutputR[i] * 0.999;
			this.L[i] = this.junctionOutputL[i + 1] * 0.999;

			//this.R[i] = clamp(this.junctionOutputR[i] * this.fade, -1, 1);
			//this.L[i] = clamp(this.junctionOutputL[i+1] * this.fade, -1, 1);    

			if (updateAmplitudes) {
				var amplitude = Math.abs(this.R[i] + this.L[i]);
				if (amplitude > this.maxAmplitude[i]) this.maxAmplitude[i] = amplitude;
				else this.maxAmplitude[i] *= 0.999;
			}
		}

		this.lipOutput = this.R[this.n - 1];

		//nose     
		this.noseJunctionOutputL[this.noseLength] = this.noseR[this.noseLength - 1] * this.lipReflection;

		for (var i = 1; i < this.noseLength; i++) {
			var w = this.noseReflection[i] * (this.noseR[i - 1] + this.noseL[i]);
			this.noseJunctionOutputR[i] = this.noseR[i - 1] - w;
			this.noseJunctionOutputL[i] = this.noseL[i] + w;
		}

		for (var i = 0; i < this.noseLength; i++) {
			this.noseR[i] = this.noseJunctionOutputR[i] * this.fade;
			this.noseL[i] = this.noseJunctionOutputL[i + 1] * this.fade;

			//this.noseR[i] = clamp(this.noseJunctionOutputR[i] * this.fade, -1, 1);
			//this.noseL[i] = clamp(this.noseJunctionOutputL[i+1] * this.fade, -1, 1);    

			if (updateAmplitudes) {
				var amplitude = Math.abs(this.noseR[i] + this.noseL[i]);
				if (amplitude > this.noseMaxAmplitude[i]) this.noseMaxAmplitude[i] = amplitude;
				else this.noseMaxAmplitude[i] *= 0.999;
			}
		}

		this.noseOutput = this.noseR[this.noseLength - 1];

	},

	finishBlock: function () {
		this.reshapeTract(AudioSystem.blockTime);
		this.calculateReflections();
	},

	addTransient: function (position) {
		var trans = {};
		trans.position = position;
		trans.timeAlive = 0;
		trans.lifeTime = 0.2;
		trans.strength = 0.3;
		trans.exponent = 200;
		this.transients.push(trans);
	},

	processTransients: function () {
		for (var i = 0; i < this.transients.length; i++) {
			var trans = this.transients[i];
			var amplitude = trans.strength * Math.pow(2, -trans.exponent * trans.timeAlive);
			this.R[trans.position] += amplitude / 2;
			this.L[trans.position] += amplitude / 2;
			trans.timeAlive += 1.0 / (sampleRate * 2);
		}
		for (var i = this.transients.length - 1; i >= 0; i--) {
			var trans = this.transients[i];
			if (trans.timeAlive > trans.lifeTime) {
				this.transients.splice(i, 1);
			}
		}
	},
};

AudioSystem.init();
Glottis.init();
Tract.init();

/**
 * Helper used to replace code in a script tag based on a search regex.
 * To inject code without erasing original string, using capturing groups; e.g.
 * ```js
 * inject(/(some string)/,'injected before $1 injected after');
 * ```
 * @param searcher Regex to search and replace
 * @param replacer Replacer string/fn
 */
function inject$1(searcher, replacer) {
    // find the relevant script tag
    var scriptTags = document.getElementsByTagName('script');
    var scriptTag;
    var code = '';
    for (var i = 0; i < scriptTags.length; ++i) {
        scriptTag = scriptTags[i];
        if (!scriptTag.textContent)
            continue;
        var matchesSearch = scriptTag.textContent.search(searcher) !== -1;
        var isCurrentScript = scriptTag === document.currentScript;
        if (matchesSearch && !isCurrentScript) {
            code = scriptTag.textContent;
            break;
        }
    }
    // error-handling
    if (!code || !scriptTag) {
        throw new Error('Couldn\'t find "' + searcher + '" in script tags');
    }
    // modify the content
    code = code.replace(searcher, replacer);
    // replace the old script tag with a new one using our modified code
    var newScriptTag = document.createElement('script');
    newScriptTag.textContent = code;
    scriptTag.insertAdjacentElement('afterend', newScriptTag);
    scriptTag.remove();
}
/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
    return array.filter(function (item, idx) {
        return array.indexOf(item) === idx;
    });
}
// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
/** test */
function kitsyInject(searcher, replacer) {
    if (!kitsy.queuedInjectScripts.some(function (script) {
        return searcher.toString() === script.searcher.toString() && replacer === script.replacer;
    })) {
        kitsy.queuedInjectScripts.push({
            searcher: searcher,
            replacer: replacer,
        });
    }
    else {
        console.warn('Ignored duplicate inject');
    }
}
// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before$1(targetFuncName, beforeFn) {
    kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
    kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}
// Ex: after('load_game', function run() { alert('Loaded!'); });
function after$1(targetFuncName, afterFn) {
    kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
    kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}
function applyInjects() {
    kitsy.queuedInjectScripts.forEach(function (injectScript) {
        inject$1(injectScript.searcher, injectScript.replacer);
    });
}
function applyHooks(root) {
    var allHooks = unique(Object.keys(kitsy.queuedBeforeScripts).concat(Object.keys(kitsy.queuedAfterScripts)));
    allHooks.forEach(applyHook.bind(this, root || window));
}
function applyHook(root, functionName) {
    var functionNameSegments = functionName.split('.');
    var obj = root;
    while (functionNameSegments.length > 1) {
        obj = obj[functionNameSegments.shift()];
    }
    var lastSegment = functionNameSegments[0];
    var superFn = obj[lastSegment];
    var superFnLength = superFn ? superFn.length : 0;
    var functions = [];
    // start with befores
    functions = functions.concat(kitsy.queuedBeforeScripts[functionName] || []);
    // then original
    if (superFn) {
        functions.push(superFn);
    }
    // then afters
    functions = functions.concat(kitsy.queuedAfterScripts[functionName] || []);
    // overwrite original with one which will call each in order
    obj[lastSegment] = function () {
        var returnVal;
        var args = [].slice.call(arguments);
        var i = 0;
        function runBefore() {
            // All outta functions? Finish
            if (i === functions.length) {
                return returnVal;
            }
            // Update args if provided.
            if (arguments.length > 0) {
                args = [].slice.call(arguments);
            }
            if (functions[i].length > superFnLength) {
                // Assume funcs that accept more args than the original are
                // async and accept a callback as an additional argument.
                return functions[i++].apply(this, args.concat(runBefore.bind(this)));
            }
            // run synchronously
            returnVal = functions[i++].apply(this, args);
            if (returnVal && returnVal.length) {
                args = returnVal;
            }
            return runBefore.apply(this, args);
        }
        return runBefore.apply(this, arguments);
    };
}
/**
@file kitsy-script-toolkit
@summary Monkey-patching toolkit to make it easier and cleaner to run code before and after functions or to inject new code into script tags
@license WTFPL (do WTF you want)
@author Original by mildmojo; modified by Sean S. LeBlanc
@version 22.1.0
@requires Bitsy 8.12

*/
var kitsy = (window.kitsy = window.kitsy || {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {},
    inject: kitsyInject,
    before: before$1,
    after: after$1,
    /**
     * Applies all queued `inject` calls.
     *
     * An object that instantiates an class modified via injection will still refer to the original class,
     * so make sure to reinitialize globals that refer to injected scripts before calling `applyHooks`.
     */
    applyInjects,
    /** Apples all queued `before`/`after` calls. */
    applyHooks,
});

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".*?"|.+?))?)\\\\?\\)', 'g'), function (match, group) {
		if (match.substr(0, 1) === '\\') {
			return '(' + group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
		}
		return '{' + group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
	});
}

var hooked = kitsy.hooked;
if (!hooked) {
	kitsy.hooked = true;
	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts
		kitsy.applyInjects();

		// recreate the script and dialog objects so that they'll be
		// referencing the code with injections instead of the original
		bitsy.scriptModule = new bitsy.Script();
		bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

		bitsy.dialogModule = new bitsy.Dialog();
		bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
		bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
		bitsy.renderer = new bitsy.TileRenderer(bitsy.tilesize);
		bitsy.transition = new bitsy.TransitionManager();

		// Hook everything
		kitsy.applyHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};
}

/** @see kitsy.inject */
var inject = kitsy.inject;
/** @see kitsy.before */
var before = kitsy.before;
/** @see kitsy.after */
var after = kitsy.after;

function addDialogFunction(tag, fn) {
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		console.warn('The dialog function "' + tag + '" already exists.');
		return;
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (gameData) {
		return [convertDialogTags(gameData, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

function injectDialogTag(tag, code) {
	inject(/(var functionMap = \{\};[^]*?)(this.HasFunction)/m, '$1\nfunctionMap["' + tag + '"] = ' + code + ';\n$2');
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	injectDialogTag(tag, 'kitsy.dialogFunctions["' + tag + '"]');
}

/**
💬
@file dialog audio
@summary animal crossing-style audio
@license MIT
@author Sean S. LeBlanc
@version 22.1.0
@requires Bitsy 8.12


@description
Executes some logic for every letter of text printed,
with a default implementation of animal crossing-style audio.

HOW TO USE:
1. Copy-paste into a script tag after the bitsy source
2. Edit `onLetter` below as needed
*/

var hackOptions$1 = {
	// function called for each character printed to the dialog box
	// the single parameter is the character with the following properties:
	// 	offset: offset from actual position in pixels. starts at {x:0, y:0}
	// 	color: color of rendered text in [0-255]. starts at {r:255, g:255, b:255, a:255}
	// 	bitmap: character bitmap as array of pixels
	// 	row: vertical position in rows
	// 	col: horizontal position in characters
	// 	char: the letter as a string (note: this is hacked in)
	//
	// this function can be customized to create a variety of effects,
	// but a default implementation is provided which will play a sound
	// mapped by letter to an HTML audio tag with a specific id, e.g. <audio id="dialog-a" src="./a.mp3"></audio>
	//
	// some examples of how this could be modified for more complex audio:
	// 	- set `audioEl.volume` based on character position
	// 	- use `bitsy.scriptInterpreter.GetVariable('voice')` to map to a different set of sounds
	// 	- use an HTML5 AudioContext or library instead of audio tags to control pitch or play generative audio
	//
	// note that the character may not always be defined (e.g. during bitsy dialog commands)
	// so be sure to guard against null data if modifying the implementation
	onLetter: function (dialogChar) {
		var character = (dialogChar || {}).char || '';
		var id = 'dialog-' + character.toLowerCase();
		var audioEl = document.getElementById(id);
		if (audioEl) {
			audioEl.currentTime = 0.0;
			audioEl.play();
		}
	},
};

// save the character on dialog font characters so we can read it back post-render
inject(/(function DialogFontChar\(font, char, effectList, effectParameterList\) {)/, '$1\nthis.char = char;');

// hook up letter function
before('dialogBuffer.DoNextChar', function () {
	hackOptions$1.onLetter(bitsy.dialogBuffer.CurChar());
});

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
@version 22.1.0
@requires Bitsy 8.12

*/


/**
 * @param {number} value number to clamp
 * @param {number} min minimum
 * @param {number} max maximum
 * @return min if value < min, max if value > max, value otherwise
 */
function clamp(value, min, max) {
	return Math.max(min, Math.min(max, value));
}





var defaultVoice = hackOptions.voices.default;
var voice;

// these are mostly guess-work based on playing around with the original pink trombone UI
// some are pretty good but definitely could use some refinement
var phonemes = {
	h: {
		voiced: 0.1,
		nasal: 0.1,
		tongue: {
			position: 0.5,
			size: 0.25,
			amount: 1,
		},
	},
	a: {
		voiced: 1,
		nasal: 0.1,
		tongue: {
			position: 0.5,
			size: 0.25,
			amount: 1,
		},
	},
	o: {
		voiced: 1,
		nasal: 0.1,
		tongue: {
			position: 0.25,
			size: 0.25,
			amount: 0.1,
		},
	},
	ee: {
		voiced: 1,
		nasal: 0.1,
		tongue: {
			position: 0.5,
			size: 0.25,
			amount: 0.1,
		},
	},
	u: {
		voiced: 1,
		nasal: 0.1,
		tongue: {
			position: 0.5,
			size: 0.25,
			amount: 0.5,
		},
	},
	l: {
		voiced: 1,
		nasal: 0.1,
		tongue: {
			position: 0.75,
			size: 0.1,
			amount: 0.25,
		},
	},
	s: {
		voiced: 0.1,
		nasal: 0,
		tongue: {
			position: 0.75,
			size: 0.1,
			amount: 0.1,
		},
	},
	z: {
		voiced: 1,
		nasal: 0,
		tongue: {
			position: 0.75,
			size: 0.1,
			amount: 0.1,
		},
	},
	m: {
		voiced: 1,
		nasal: 1,
		tongue: {
			position: 1.0,
			size: 0.3,
			amount: 0,
		},
	},
	v: {
		voiced: 1,
		nasal: 0.1,
		tongue: {
			position: 1.0,
			size: 0.1,
			amount: 0.05,
		},
	},
	f: {
		voiced: 0.1,
		nasal: 0.1,
		tongue: {
			position: 1.0,
			size: 0.1,
			amount: 0.05,
		},
	},
	n: {
		voiced: 1,
		nasal: 1,
		tongue: {
			position: 0.75,
			size: 0.3,
			amount: 0,
		},
	},
	p: {
		voiced: 0.1,
		nasal: 1,
		tongue: {
			position: 0.9,
			size: 0.2,
			amount: 0,
		},
	},
	b: {
		voiced: 1,
		nasal: 0.1,
		tongue: {
			position: 0.9,
			size: 0.2,
			amount: 0,
		},
	},
	w: {
		voiced: 1,
		nasal: 1,
		tongue: {
			position: 0.8,
			size: 0.1,
			amount: 0,
		},
	},
	g: {
		voiced: 1,
		nasal: 0.1,
		tongue: {
			position: 0.5,
			size: 0.3,
			amount: 0,
		},
	},
	k: {
		voiced: 1,
		nasal: 0.1,
		tongue: {
			position: 0.25,
			size: 0.2,
			amount: 0,
		},
	},
	t: {
		voiced: 0,
		nasal: 0.1,
		tongue: {
			position: 0.6,
			size: 0.3,
			amount: 0,
		},
	},
	d: {
		voiced: 1,
		nasal: 0.1,
		tongue: {
			position: 0.6,
			size: 0.3,
			amount: 0,
		},
	},
	yr: {
		voiced: 1,
		nasal: 0.1,
		tongue: {
			position: 0.7,
			size: 0.3,
			amount: 0.5,
		},
	},
};

function getPhoneme(letter) {
	switch (letter) {
		case 'e':
		case 'i':
			return 'ee';
		case 'r':
		case 'y':
			return 'yr';
		case 'c':
		case 'k':
		case 'q':
		case 'x':
			return 'k';
		default:
			return letter;
	}
}

function lerp(from, to, by) {
	return from + (to - from) * by;
}

// helper for random values
function getValue(randomOption) {
	var rnd = 1.0 - (Math.random() * 2 - 1) ** 2;
	return randomOption[0] + randomOption[1] * rnd;
}

function resetTract() {
	Tract.targetDiameter = Tract.restDiameter.slice();
}

hackOptions$1.onLetter = function (character) {
	var first = !Glottis.isTouched;
	resetTract();
	Glottis.isTouched = false;
	// skip pre-setup, nulls, and if dialog is skipping
	if (!character || !character.char || skipping) {
		return;
	}
	var char = character.char.toLowerCase().match(/[a-z0-9]/);
	// skip non-alphanumeric
	if (!char) {
		return;
	}
	char = char[0];
	var phoneme = phonemes[getPhoneme(char)];
	if (!phoneme) {
		return;
	}

	Glottis.isTouched = true;
	applyVoice();

	// apply phoneme
	Glottis.UITenseness = phoneme.voiced * getValue(voice.voiced || defaultVoice.voiced);
	var l = Tract.targetDiameter.length;
	var adjustPoint = phoneme.tongue.position;
	var adjustSize = phoneme.tongue.size;
	var adjustAmp = lerp(1, phoneme.tongue.amount, getValue(voice.phoneme || defaultVoice.phoneme));
	var adjustNasal = phoneme.nasal;
	Tract.velumTarget *= adjustNasal;
	Tract.targetDiameter = Tract.targetDiameter.map((v, i) => {
		var pointInTract = i / l;
		var distanceFromAdjust = Math.abs(adjustPoint - pointInTract);
		var adjustAmount = 1.0 - clamp(distanceFromAdjust / adjustSize, 0, 1);
		return lerp(v, v * adjustAmp, adjustAmount);
	});

	adjustPoint = getValue(voice.tonguePosition || defaultVoice.tonguePosition);
	adjustSize = getValue(voice.tongueSize || defaultVoice.tongueSize);
	adjustAmp = getValue(voice.tongueAmount || defaultVoice.tongueAmount);
	Tract.targetDiameter = Tract.targetDiameter.map((v, i) => {
		var pointInTract = i / l;
		var distanceFromAdjust = Math.abs(adjustPoint - pointInTract);
		var adjustAmount = 1.0 - clamp(distanceFromAdjust / adjustSize, 0, 1);
		return lerp(v, v * adjustAmp, adjustAmount);
	});

	if (first) {
		Tract.diameter = Tract.targetDiameter.slice();
	}
};

function applyVoice() {
	Glottis.loudness = getValue(voice.volume || defaultVoice.volume);
	Glottis.vibratoAmount = getValue(voice.vibrato || defaultVoice.vibrato);
	Glottis.UIFrequency = getValue(voice.pitch || defaultVoice.pitch);
	Tract.velumTarget = getValue(voice.nasal || defaultVoice.nasal);
}

var skipping = false;
before('dialogBuffer.Skip', () => {
	skipping = true;
});
after('dialogBuffer.Skip', () => {
	skipping = false;
});
// always stop speaking at end of dialog
after('dialogRenderer.DrawNextArrow', () => {
	Glottis.isTouched = false;
	resetTract();
});

after('onExitDialog', function () {
	if (hackOptions.autoReset) {
		voice = defaultVoice;
		resetTract();
		applyVoice();
	}
});

addDialogTag('voice', function (environment, parameters, onReturn) {
	voice = hackOptions.voices[parameters[0]] || defaultVoice;
	onReturn(null);
});

after('onready', function () {
	defaultVoice = hackOptions.voices.default;
	voice = defaultVoice;
});

exports.Glottis = Glottis;
exports.Tract = Tract;
exports.hackOptions = hackOptions;

})(this.hacks.dialog_audio_vocal_synth = this.hacks.dialog_audio_vocal_synth || {}, window);

/**
🌐
@file favicon-from-sprite
@summary generate a browser favicon (tab icon) from a Bitsy sprite, including animation!
@license WTFPL (do WTF you want)
@author @mildmojo
@version 22.1.0
@requires Bitsy 8.12


@description
Use one of your game sprites as the page favicon. It'll even animate if the
sprite has multiple frames!

HOW TO USE:
  1. Copy-paste this script into a new script tag after the Bitsy source code.
  2. Edit the configuration below to set which sprite and colors this mod
     should use for the favicon. By default, it will render the player avatar
     sprite in the first available palette's colors.
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions =  {
	SPRITE_NAME: '', // Sprite name as entered in editor (not case-sensitive). Defaults to player avatar.
	PALETTE_ID: 0, // Palette name or number to draw colors from. (Names not case-sensitive.)
	BG_COLOR_NUM: 0, // Favicon background color in palette. 0 = BG, 1 = Tile, 2 = Sprite.
	FG_COLOR_NUM: 2, // Favicon sprite color in palette. 0 = BG, 1 = Tile, 2 = Sprite.
	PIXEL_PADDING: 1, // Padding around sprite, in Bitsy pixel units.
	ROUNDED_CORNERS: true, // Should the favicon have rounded corners? (Suggest margin 2px if rounding.)
	FRAME_DELAY: 400, // Frame change interval (ms) if sprite is animated. Use `Infinity` to disable.
};

/**
 * Helper used to replace code in a script tag based on a search regex.
 * To inject code without erasing original string, using capturing groups; e.g.
 * ```js
 * inject(/(some string)/,'injected before $1 injected after');
 * ```
 * @param searcher Regex to search and replace
 * @param replacer Replacer string/fn
 */
function inject(searcher, replacer) {
    // find the relevant script tag
    var scriptTags = document.getElementsByTagName('script');
    var scriptTag;
    var code = '';
    for (var i = 0; i < scriptTags.length; ++i) {
        scriptTag = scriptTags[i];
        if (!scriptTag.textContent)
            continue;
        var matchesSearch = scriptTag.textContent.search(searcher) !== -1;
        var isCurrentScript = scriptTag === document.currentScript;
        if (matchesSearch && !isCurrentScript) {
            code = scriptTag.textContent;
            break;
        }
    }
    // error-handling
    if (!code || !scriptTag) {
        throw new Error('Couldn\'t find "' + searcher + '" in script tags');
    }
    // modify the content
    code = code.replace(searcher, replacer);
    // replace the old script tag with a new one using our modified code
    var newScriptTag = document.createElement('script');
    newScriptTag.textContent = code;
    scriptTag.insertAdjacentElement('afterend', newScriptTag);
    scriptTag.remove();
}
/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
    return array.filter(function (item, idx) {
        return array.indexOf(item) === idx;
    });
}
// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
/** test */
function kitsyInject(searcher, replacer) {
    if (!kitsy.queuedInjectScripts.some(function (script) {
        return searcher.toString() === script.searcher.toString() && replacer === script.replacer;
    })) {
        kitsy.queuedInjectScripts.push({
            searcher: searcher,
            replacer: replacer,
        });
    }
    else {
        console.warn('Ignored duplicate inject');
    }
}
// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
    kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
    kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}
// Ex: after('load_game', function run() { alert('Loaded!'); });
function after$1(targetFuncName, afterFn) {
    kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
    kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}
function applyInjects() {
    kitsy.queuedInjectScripts.forEach(function (injectScript) {
        inject(injectScript.searcher, injectScript.replacer);
    });
}
function applyHooks(root) {
    var allHooks = unique(Object.keys(kitsy.queuedBeforeScripts).concat(Object.keys(kitsy.queuedAfterScripts)));
    allHooks.forEach(applyHook.bind(this, root || window));
}
function applyHook(root, functionName) {
    var functionNameSegments = functionName.split('.');
    var obj = root;
    while (functionNameSegments.length > 1) {
        obj = obj[functionNameSegments.shift()];
    }
    var lastSegment = functionNameSegments[0];
    var superFn = obj[lastSegment];
    var superFnLength = superFn ? superFn.length : 0;
    var functions = [];
    // start with befores
    functions = functions.concat(kitsy.queuedBeforeScripts[functionName] || []);
    // then original
    if (superFn) {
        functions.push(superFn);
    }
    // then afters
    functions = functions.concat(kitsy.queuedAfterScripts[functionName] || []);
    // overwrite original with one which will call each in order
    obj[lastSegment] = function () {
        var returnVal;
        var args = [].slice.call(arguments);
        var i = 0;
        function runBefore() {
            // All outta functions? Finish
            if (i === functions.length) {
                return returnVal;
            }
            // Update args if provided.
            if (arguments.length > 0) {
                args = [].slice.call(arguments);
            }
            if (functions[i].length > superFnLength) {
                // Assume funcs that accept more args than the original are
                // async and accept a callback as an additional argument.
                return functions[i++].apply(this, args.concat(runBefore.bind(this)));
            }
            // run synchronously
            returnVal = functions[i++].apply(this, args);
            if (returnVal && returnVal.length) {
                args = returnVal;
            }
            return runBefore.apply(this, args);
        }
        return runBefore.apply(this, arguments);
    };
}
/**
@file kitsy-script-toolkit
@summary Monkey-patching toolkit to make it easier and cleaner to run code before and after functions or to inject new code into script tags
@license WTFPL (do WTF you want)
@author Original by mildmojo; modified by Sean S. LeBlanc
@version 22.1.0
@requires Bitsy 8.12

*/
var kitsy = (window.kitsy = window.kitsy || {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {},
    inject: kitsyInject,
    before,
    after: after$1,
    /**
     * Applies all queued `inject` calls.
     *
     * An object that instantiates an class modified via injection will still refer to the original class,
     * so make sure to reinitialize globals that refer to injected scripts before calling `applyHooks`.
     */
    applyInjects,
    /** Apples all queued `before`/`after` calls. */
    applyHooks,
});

var hooked = kitsy.hooked;
if (!hooked) {
	kitsy.hooked = true;
	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts
		kitsy.applyInjects();

		// recreate the script and dialog objects so that they'll be
		// referencing the code with injections instead of the original
		bitsy.scriptModule = new bitsy.Script();
		bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

		bitsy.dialogModule = new bitsy.Dialog();
		bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
		bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
		bitsy.renderer = new bitsy.TileRenderer(bitsy.tilesize);
		bitsy.transition = new bitsy.TransitionManager();

		// Hook everything
		kitsy.applyHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};
}

/** @see kitsy.inject */
kitsy.inject;
/** @see kitsy.before */
kitsy.before;
/** @see kitsy.after */
var after = kitsy.after;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
@version 22.1.0
@requires Bitsy 8.12

*/


/*
Helper for getting image by name or id

Args:
	name: id or name of image to return
	 map: map of images (e.g. `sprite`, `tile`, `item`)

Returns: the image in the given map with the given name/id
 */
function getImage(name, map) {
	var id = Object.prototype.hasOwnProperty.call(map, name)
		? name
		: Object.keys(map).find(function (e) {
				return map[e].name === name;
			});
	return map[id];
}




// CONFIGURATION FOR FAVICON

// END CONFIG

var FAVICON_SIZE = 16; // pixels
var ONE_PIXEL_SCALED = FAVICON_SIZE / bitsy.tilesize;
hackOptions.PIXEL_PADDING *= ONE_PIXEL_SCALED;
var canvas = document.createElement('canvas');
canvas.width = FAVICON_SIZE + 2 * hackOptions.PIXEL_PADDING;
canvas.height = FAVICON_SIZE + 2 * hackOptions.PIXEL_PADDING;
var ctx = canvas.getContext('2d');
var faviconLinkElem;
var faviconFrameURLs = [];
var isStarted = false;

after('load_game', function () {
	if (isStarted) {
		return;
	}
	isStarted = true;

	var frameNum = 0;
	var frames = getFrames(hackOptions.SPRITE_NAME);

	faviconFrameURLs = frames.map(drawFrame);

	// Only one frame? Don't even bother with the loop, just paint the icon once.
	if (frames.length === 1) {
		updateBrowserFavicon(faviconFrameURLs[0]);
		return;
	}

	setInterval(function () {
		frameNum = ++frameNum % frames.length;
		updateBrowserFavicon(faviconFrameURLs[frameNum]);
	}, hackOptions.FRAME_DELAY);
});

function drawFrame(frameData) {
	var pal = getPalette(hackOptions.PALETTE_ID);
	var bgColor = (pal && pal[hackOptions.BG_COLOR_NUM]) || [20, 20, 20];
	var spriteColor = (pal && pal[hackOptions.FG_COLOR_NUM]) || [245, 245, 245];
	var roundingOffset = hackOptions.ROUNDED_CORNERS ? ONE_PIXEL_SCALED : 0;

	// Approximate a squircle-shaped background by drawing a fat plus sign with
	// two overlapping rects, leaving some empty pixels in the corners.
	var longSide = FAVICON_SIZE + 2 * hackOptions.PIXEL_PADDING;
	var shortSide = longSide - roundingOffset * ONE_PIXEL_SCALED;
	ctx.fillStyle = rgb(bgColor);
	ctx.fillRect(roundingOffset, 0, shortSide, longSide);
	ctx.fillRect(0, roundingOffset, longSide, shortSide);

	// Draw sprite foreground.
	ctx.fillStyle = rgb(spriteColor);
	Object.keys(frameData).forEach(function (y) {
		Object.keys(frameData).forEach(function (x) {
			if (frameData[y][x] === 1) {
				ctx.fillRect(x * ONE_PIXEL_SCALED + hackOptions.PIXEL_PADDING, y * ONE_PIXEL_SCALED + hackOptions.PIXEL_PADDING, ONE_PIXEL_SCALED, ONE_PIXEL_SCALED);
			}
		});
	});

	return canvas.toDataURL('image/x-icon');
}

function updateBrowserFavicon(dataURL) {
	// Add or modify favicon link tag in document.
	faviconLinkElem = faviconLinkElem || document.querySelector('#favicon');
	if (!faviconLinkElem) {
		faviconLinkElem = document.createElement('link');
		faviconLinkElem.id = 'favicon';
		faviconLinkElem.type = 'image/x-icon';
		faviconLinkElem.rel = 'shortcut icon';
		document.head.appendChild(faviconLinkElem);
	}
	faviconLinkElem.href = dataURL;
}

function getFrames(spriteName) {
	var frames = bitsy.renderer.GetDrawingSource(getImage(spriteName || bitsy.playerId, bitsy.sprite).drw);
	return frames;
}

function getPalette(id) {
	var palId = id;

	if (Number.isNaN(Number(palId))) {
		// Search palettes by name. `palette` is an object with numbers as keys. Yuck.
		// Palette names are case-insensitive to avoid Bitsydev headaches.
		palId = Object.keys(bitsy.palette).find(function (i) {
			return bitsy.palette[i].name && bitsy.palette[i].name.toLowerCase() === palId.toLowerCase();
		});
	}

	return bitsy.getPal(palId);
}

// Expects values = [r, g, b]
function rgb(values) {
	return 'rgb(' + values.join(',') + ')';
}

exports.hackOptions = hackOptions;

})(this.hacks["favicon-from-sprite"] = this.hacks["favicon-from-sprite"] || {}, window);

/**
🎮
@file gamepad input
@summary HTML5 gamepad support
@license MIT
@author Sean S. LeBlanc
@version 22.1.0
@requires Bitsy 8.12


@description
Adds support for gamepad input.

Directional input is mapped to the left and right analog sticks, the dpad, and the face buttons (e.g. ABXY).
The same hold-to-move logic used for keyboard input is shared with the gamepad input.

HOW TO USE:
Copy-paste this script into a script tag after the bitsy source
*/
(function (bitsy) {
'use strict';

var Buttons;
(function (Buttons) {
    // XBOX360 wired controller configuration
    Buttons[Buttons["A"] = 0] = "A";
    Buttons[Buttons["X"] = 2] = "X";
    Buttons[Buttons["B"] = 1] = "B";
    Buttons[Buttons["Y"] = 3] = "Y";
    Buttons[Buttons["LB"] = 4] = "LB";
    Buttons[Buttons["RB"] = 5] = "RB";
    Buttons[Buttons["LT"] = 6] = "LT";
    Buttons[Buttons["RT"] = 7] = "RT";
    Buttons[Buttons["BACK"] = 8] = "BACK";
    Buttons[Buttons["START"] = 9] = "START";
    Buttons[Buttons["LHAT"] = 10] = "LHAT";
    Buttons[Buttons["RHAT"] = 11] = "RHAT";
    Buttons[Buttons["DPAD_UP"] = 12] = "DPAD_UP";
    Buttons[Buttons["DPAD_DOWN"] = 13] = "DPAD_DOWN";
    Buttons[Buttons["DPAD_LEFT"] = 14] = "DPAD_LEFT";
    Buttons[Buttons["DPAD_RIGHT"] = 15] = "DPAD_RIGHT";
})(Buttons || (Buttons = {}));
var Axes;
(function (Axes) {
    Axes[Axes["LSTICK_H"] = 0] = "LSTICK_H";
    Axes[Axes["LSTICK_V"] = 1] = "LSTICK_V";
    Axes[Axes["RSTICK_H"] = 2] = "RSTICK_H";
    Axes[Axes["RSTICK_V"] = 3] = "RSTICK_V";
})(Axes || (Axes = {}));
var nullGamepad = {
    original: {
        axes: [],
        buttons: [],
        connected: false,
    },
    disabled: true,
    down: {},
    justDown: {},
    justUp: {},
    axesPrev: {},
};
var Gamepads = /** @class */ (function () {
    /**
    * initialize gamepads
    */
    function Gamepads() {
        var _this = this;
        // settings
        /** if `abs(an axis value)` is < `deadZone`, returns 0 instead */
        this.deadZone = 0.25;
        /** if `abs(1-an axis value)` is < `snapZone`, returns 1 instead */
        this.snapZone = 0.25;
        /** axis values between `deadZone` and `snapZone` will be run through this function
        *
        * defaults to normalizing between the two thresholds */
        this.interpolate = function (value) {
            var v = Math.max(0, Math.min(1, (value - _this.deadZone) / (1.0 - _this.snapZone - _this.deadZone)));
            return v;
        };
        // internal vars
        this.players = {};
        this.available = false;
        this.pollEveryFrame = false;
        this.connected = false;
        /**
        * update gamepads (clears arrays, polls connections, etc.)
        */
        this.pollconnections = function () {
            _this.connected = false;
            // assume existing players' gamepads aren't enabled until they're found
            Object.values(_this.players).forEach(function (player) {
                player.disabled = true;
            });
            var gps = navigator.getGamepads();
            for (var i = 0; i < gps.length; ++i) {
                var gp = gps[i];
                if (gp) {
                    if (gp.connected) {
                        if (_this.players[gp.index] == null) {
                            // new player
                            _this.players[gp.index] = {
                                disabled: false,
                                original: gp,
                                down: {},
                                justDown: {},
                                justUp: {},
                                axesPrev: {},
                            };
                        }
                        else {
                            // returning player, just assign the gamepad
                            _this.players[gp.index].original = gp;
                        }
                        _this.connected = true;
                        _this.players[gp.index].disabled = false;
                    }
                    else {
                        delete _this.players[gp.index];
                    }
                }
            }
        };
        /**
        * update gamepads (clears arrays, polls connections, etc.)
        */
        this.update = function () {
            // store the previous axis values
            // has to be done before pollConnections since that will get the new axis values
            Object.keys(_this.players).forEach(function (i) {
                var _a;
                var p = _this.getPlayer(i);
                if ((_a = p === null || p === void 0 ? void 0 : p.original) === null || _a === void 0 ? void 0 : _a.axes) {
                    p.axesPrev = p.original.axes.slice();
                }
            });
            // poll connections and update gamepad states every frame because chrome's a lazy bum
            if (_this.pollEveryFrame) {
                _this.pollconnections();
            }
            Object.keys(_this.players).forEach(function (i) {
                var _a;
                var p = _this.getPlayer(i);
                if ((_a = p === null || p === void 0 ? void 0 : p.original) === null || _a === void 0 ? void 0 : _a.buttons) {
                    for (var j = 0; j < p.original.buttons.length; ++j) {
                        if (p.original.buttons[j].pressed) {
                            p.justDown[j] = !(p.down[j] === true);
                            p.down[j] = true;
                            p.justUp[j] = false;
                        }
                        else {
                            p.justUp[j] = p.down[j] === true;
                            p.down[j] = false;
                            p.justDown[j] = false;
                        }
                    }
                }
            });
        };
        /**
        * @returns `player`'s gamepad
        *
        * if one doesn't exist, returns an object with gamepad properties reflecting a null state
        */
        this.getPlayer = function (player) {
            var _a, _b, _c;
            if (((_b = (_a = _this.players[player]) === null || _a === void 0 ? void 0 : _a.original) === null || _b === void 0 ? void 0 : _b.connected) && !((_c = _this.players[player]) === null || _c === void 0 ? void 0 : _c.disabled)) {
                return _this.players[player];
            }
            return nullGamepad;
        };
        /**
        * @returns an array representing `length` axes for `player` at `offset`
        *
        * if `abs(an axis value)` is < `deadZone`, returns 0 instead
        * if `abs(1-an axis value)` is < `snapZone`, returns 1/-1 instead
        * otherwise, returns the axis value normalized between `deadZone` and `(1-snapZone)`
        * @param {Number} offset axis index
        * @param {Number} length number of axes to return
        * @param {Number} player player index (`undefined` for "sum of all")
        * @param {boolean} prev if `true` uses axis values from previous update
        */
        this.getAxes = function (offset, length, player, prev) {
            if (offset === void 0) { offset = 0; }
            if (length === void 0) { length = 2; }
            if (prev === void 0) { prev = false; }
            var axes = [];
            for (var i = 0; i < length; ++i) {
                axes[i] = 0;
            }
            if (player === undefined) {
                Object.keys(_this.players).forEach(function (i) {
                    var a = _this.getAxes(offset, length, i, prev);
                    for (var j = 0; j < a.length; ++j) {
                        axes[j] += a[j];
                    }
                });
            }
            else {
                var p = _this.getPlayer(player);
                if (p === null || p === void 0 ? void 0 : p.original) {
                    var axesSource = prev ? p.axesPrev : p.original.axes;
                    var a = Object.values(axesSource).slice(offset, offset + length);
                    for (var i = 0; i < a.length; ++i) {
                        if (Math.abs(a[i]) < _this.deadZone) {
                            axes[i] += 0;
                        }
                        else if (Math.abs(1.0 - a[i]) < _this.snapZone) {
                            axes[i] += 1;
                        }
                        else if (Math.abs(-1.0 - a[i]) < _this.snapZone) {
                            axes[i] -= 1;
                        }
                        else {
                            axes[i] += Math.sign(a[i]) * _this.interpolate(Math.abs(a[i]));
                        }
                    }
                }
            }
            return axes;
        };
        /**
       * @returns equivalent to `getAxes(axis, 1, player, prev)[0]`
       */
        this.getAxis = function (axis, player, prev) { return _this.getAxes(axis, 1, player, prev)[0]; };
        /**
        * @returns `true` if `axis` is past `threshold` in `direction`
        * @param {Number} axis axis index
        * @param {Number} threshold threshold (-1 to 1)
        * @param {Number} direction direction (-1|1) (if `undefined`, assumes the sign of `theshold` is the direction (e.g. if `theshold` is -0.5, it will check if the axis is < -0.5))
        * @param {Number} player player index (`undefined` for "any")
        * @param {boolean} prev if `true` uses axis values from previous update
        */
        this.axisPast = function (axis, threshold, direction, player, prev) {
            if (!threshold) {
                throw new Error('must specify a non-zero threshold');
            }
            if (!direction) {
                direction = threshold > 0 ? 1 : -1;
            }
            var a = _this.getAxis(axis, player, prev);
            return direction < 0 ? a < threshold : a > threshold;
        };
        /**
        * @returns `true` if `axis` is past `threshold` in `direction` and WAS NOT in previous update
        * @param {Number} axis axis index
        * @param {Number} threshold threshold (-1 to 1)
        * @param {Number} direction direction (-1|1) (if `undefined`, assumes the sign of `theshold` is the direction (e.g. if `theshold` is -0.5, it will check if the axis is < -0.5))
        * @param {Number} player player index (`undefined` for "any")
        */
        this.axisJustPast = function (axis, threshold, direction, player) { return _this.axisPast(axis, threshold, direction, player, false)
            && !_this.axisPast(axis, threshold, direction, player, true); };
        /**
        * @returns `[x,y]` representing the dpad for `player`
        * @param {Number} player player index (`undefined` for "sum of all")
        */
        this.getDpad = function (player) {
            var x = 0;
            var y = 0;
            if (player === undefined) {
                Object.keys(_this.players).forEach(function (i) {
                    var _a = _this.getDpad(i), ix = _a[0], iy = _a[1];
                    x += ix;
                    y += iy;
                });
            }
            else {
                if (_this.isDown(Buttons.DPAD_RIGHT, player)) {
                    x += 1;
                }
                if (_this.isDown(Buttons.DPAD_LEFT, player)) {
                    x -= 1;
                }
                if (_this.isDown(Buttons.DPAD_UP, player)) {
                    y += 1;
                }
                if (_this.isDown(Buttons.DPAD_DOWN, player)) {
                    y -= 1;
                }
            }
            return [x, y];
        };
        /**
        * @returns `true` if `player`'s `btn` is currently down
        * @param {Number} btn button index
        * @param {Number} player player index (`undefined` for "any")
        */
        this.isDown = function (btn, player) {
            if (btn === undefined) {
                throw new Error('must specify a button');
            }
            if (player === undefined) {
                return Object.keys(_this.players).some(function (i) { return _this.isDown(btn, i); });
            }
            return _this.getPlayer(player).down[btn];
        };
        /**
        * @returns equivalent to `!isDown(btn, player)`
        * @param {Number} btn button index
        * @param {Number} player player index (`undefined` for "any")
        */
        this.isUp = function (btn, player) { return !_this.isDown(btn, player); };
        /**
        * @returns `true` if `player`'s `btn` is currently down and WAS NOT in previous update
        * @param {Number} btn button index
        * @param {Number} player player index (`undefined` for "any")
        */
        this.isJustDown = function (btn, player) {
            if (btn === undefined) {
                throw new Error('must specify a button');
            }
            if (player === undefined) {
                return Object.keys(_this.players).some(function (i) { return _this.isJustDown(btn, i); });
            }
            return _this.getPlayer(player).justDown[btn];
        };
        /**
        * @returns `true` if `player`'s `btn` is currently NOT down and WAS down in previous update
        * @param {Number} btn button index
        * @param {Number} player player index (`undefined` for "any")
        */
        this.isJustUp = function (btn, player) {
            if (btn === undefined) {
                throw new Error('must specify a button');
            }
            if (player === undefined) {
                return Object.keys(_this.players).some(function (i) { return _this.isJustUp(btn, i); });
            }
            return _this.getPlayer(player).justUp[btn];
        };
        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
        // @ts-ignore
        if (navigator.getGamepads) {
            this.available = true;
        }
        else if (navigator.webkitGetGamepads) {
            navigator.getGamepads = navigator.webkitGetGamepads;
            this.available = true;
        }
        if (this.available) {
            if (navigator.userAgent.includes('Firefox')) {
                // listen to connection events for firefox
                window.addEventListener('gamepadconnected', this.pollconnections.bind(this));
                window.addEventListener('gamepaddisconnected', this.pollconnections.bind(this));
            }
            else {
                this.pollEveryFrame = true;
            }
        }
    }
    return Gamepads;
}());

/**
 * Helper used to replace code in a script tag based on a search regex.
 * To inject code without erasing original string, using capturing groups; e.g.
 * ```js
 * inject(/(some string)/,'injected before $1 injected after');
 * ```
 * @param searcher Regex to search and replace
 * @param replacer Replacer string/fn
 */
function inject(searcher, replacer) {
    // find the relevant script tag
    var scriptTags = document.getElementsByTagName('script');
    var scriptTag;
    var code = '';
    for (var i = 0; i < scriptTags.length; ++i) {
        scriptTag = scriptTags[i];
        if (!scriptTag.textContent)
            continue;
        var matchesSearch = scriptTag.textContent.search(searcher) !== -1;
        var isCurrentScript = scriptTag === document.currentScript;
        if (matchesSearch && !isCurrentScript) {
            code = scriptTag.textContent;
            break;
        }
    }
    // error-handling
    if (!code || !scriptTag) {
        throw new Error('Couldn\'t find "' + searcher + '" in script tags');
    }
    // modify the content
    code = code.replace(searcher, replacer);
    // replace the old script tag with a new one using our modified code
    var newScriptTag = document.createElement('script');
    newScriptTag.textContent = code;
    scriptTag.insertAdjacentElement('afterend', newScriptTag);
    scriptTag.remove();
}
/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
    return array.filter(function (item, idx) {
        return array.indexOf(item) === idx;
    });
}
// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
/** test */
function kitsyInject(searcher, replacer) {
    if (!kitsy.queuedInjectScripts.some(function (script) {
        return searcher.toString() === script.searcher.toString() && replacer === script.replacer;
    })) {
        kitsy.queuedInjectScripts.push({
            searcher: searcher,
            replacer: replacer,
        });
    }
    else {
        console.warn('Ignored duplicate inject');
    }
}
// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before$1(targetFuncName, beforeFn) {
    kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
    kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}
// Ex: after('load_game', function run() { alert('Loaded!'); });
function after$1(targetFuncName, afterFn) {
    kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
    kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}
function applyInjects() {
    kitsy.queuedInjectScripts.forEach(function (injectScript) {
        inject(injectScript.searcher, injectScript.replacer);
    });
}
function applyHooks(root) {
    var allHooks = unique(Object.keys(kitsy.queuedBeforeScripts).concat(Object.keys(kitsy.queuedAfterScripts)));
    allHooks.forEach(applyHook.bind(this, root || window));
}
function applyHook(root, functionName) {
    var functionNameSegments = functionName.split('.');
    var obj = root;
    while (functionNameSegments.length > 1) {
        obj = obj[functionNameSegments.shift()];
    }
    var lastSegment = functionNameSegments[0];
    var superFn = obj[lastSegment];
    var superFnLength = superFn ? superFn.length : 0;
    var functions = [];
    // start with befores
    functions = functions.concat(kitsy.queuedBeforeScripts[functionName] || []);
    // then original
    if (superFn) {
        functions.push(superFn);
    }
    // then afters
    functions = functions.concat(kitsy.queuedAfterScripts[functionName] || []);
    // overwrite original with one which will call each in order
    obj[lastSegment] = function () {
        var returnVal;
        var args = [].slice.call(arguments);
        var i = 0;
        function runBefore() {
            // All outta functions? Finish
            if (i === functions.length) {
                return returnVal;
            }
            // Update args if provided.
            if (arguments.length > 0) {
                args = [].slice.call(arguments);
            }
            if (functions[i].length > superFnLength) {
                // Assume funcs that accept more args than the original are
                // async and accept a callback as an additional argument.
                return functions[i++].apply(this, args.concat(runBefore.bind(this)));
            }
            // run synchronously
            returnVal = functions[i++].apply(this, args);
            if (returnVal && returnVal.length) {
                args = returnVal;
            }
            return runBefore.apply(this, args);
        }
        return runBefore.apply(this, arguments);
    };
}
/**
@file kitsy-script-toolkit
@summary Monkey-patching toolkit to make it easier and cleaner to run code before and after functions or to inject new code into script tags
@license WTFPL (do WTF you want)
@author Original by mildmojo; modified by Sean S. LeBlanc
@version 22.1.0
@requires Bitsy 8.12

*/
var kitsy = (window.kitsy = window.kitsy || {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {},
    inject: kitsyInject,
    before: before$1,
    after: after$1,
    /**
     * Applies all queued `inject` calls.
     *
     * An object that instantiates an class modified via injection will still refer to the original class,
     * so make sure to reinitialize globals that refer to injected scripts before calling `applyHooks`.
     */
    applyInjects,
    /** Apples all queued `before`/`after` calls. */
    applyHooks,
});

var hooked = kitsy.hooked;
if (!hooked) {
	kitsy.hooked = true;
	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts
		kitsy.applyInjects();

		// recreate the script and dialog objects so that they'll be
		// referencing the code with injections instead of the original
		bitsy.scriptModule = new bitsy.Script();
		bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

		bitsy.dialogModule = new bitsy.Dialog();
		bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
		bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
		bitsy.renderer = new bitsy.TileRenderer(bitsy.tilesize);
		bitsy.transition = new bitsy.TransitionManager();

		// Hook everything
		kitsy.applyHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};
}

/** @see kitsy.inject */
kitsy.inject;
/** @see kitsy.before */
var before = kitsy.before;
/** @see kitsy.after */
var after = kitsy.after;



var gamepads = new Gamepads();

var move = function (dpad, face, axis, axis2, axispast, axisdir, key) {
	// keydown
	if (
		gamepads.isJustDown(dpad) ||
		gamepads.isJustDown(face) ||
		gamepads.axisJustPast(axis, axispast, axisdir) ||
		gamepads.axisJustPast(axis2, axispast, axisdir) ||
		(bitsy.playerHoldToMoveTimer <= 0 && (gamepads.isDown(dpad) || gamepads.isDown(face) || gamepads.axisPast(axis, axispast, axisdir)))
	) {
		// eslint-disable-next-line no-underscore-dangle
		bitsy.bitsy._poke(bitsy.bitsy._buttonBlock, key, 1);
	}

	// keyup
	if (gamepads.isJustUp(dpad) || gamepads.isJustUp(face) || gamepads.axisJustPast(axis, axispast, -axisdir) || gamepads.axisJustPast(axis2, axispast, -axisdir)) {
		// eslint-disable-next-line no-underscore-dangle
		bitsy.bitsy._poke(bitsy.bitsy._buttonBlock, key, 0);
	}
};

before('updateInput', function () {
	move(Buttons.DPAD_LEFT, Buttons.X, Axes.LSTICK_H, Axes.RSTICK_H, -0.5, -1, bitsy.bitsy.BTN_LEFT);
	move(Buttons.DPAD_RIGHT, Buttons.B, Axes.LSTICK_H, Axes.RSTICK_H, 0.5, 1, bitsy.bitsy.BTN_RIGHT);
	move(Buttons.DPAD_UP, Buttons.Y, Axes.LSTICK_V, Axes.RSTICK_V, -0.5, -1, bitsy.bitsy.BTN_UP);
	move(Buttons.DPAD_DOWN, Buttons.A, Axes.LSTICK_V, Axes.RSTICK_V, 0.5, 1, bitsy.bitsy.BTN_DOWN);
	if (gamepads.isJustDown(Buttons.START) || gamepads.isJustDown(Buttons.BACK)) {
		// eslint-disable-next-line no-underscore-dangle
		bitsy.bitsy._poke(bitsy.bitsy._buttonBlock, bitsy.bitsy.BTN_MENU, 1);
	}
	if (gamepads.isJustUp(Buttons.START) || gamepads.isJustUp(Buttons.BACK)) {
		// eslint-disable-next-line no-underscore-dangle
		bitsy.bitsy._poke(bitsy.bitsy._buttonBlock, bitsy.bitsy.BTN_MENU, 0);
	}
});
after('bitsy._update', function () {
	gamepads.update();
});

})(window);


</script>

<script type="text/javascript" id="borksyAdditionalJS">

</script>

</head>


<!-- DOCUMENT BODY -->
<body onload='startExportedGame()'>
<!-- GAME CANVAS -->
<canvas id='game'></canvas>
</body>


</html>
